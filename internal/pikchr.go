/* This file is automatically generated by Lemon from input grammar
** source file "pikchr.y". */
/*
** Zero-Clause BSD license:
**
** Copyright (C) 2020-09-01 by D. Richard Hipp <drh@sqlite.org>
**
** Permission to use, copy, modify, and/or distribute this software for
** any purpose with or without fee is hereby granted.
**
****************************************************************************
**
** This software translates a PIC-inspired diagram language into SVG.
**
** PIKCHR (pronounced like "picture") is *mostly* backwards compatible
** with legacy PIC, though some features of legacy PIC are removed
** (for example, the "sh" command is removed for security) and
** many enhancements are added.
**
** PIKCHR is designed for use in an internet facing web environment.
** In particular, PIKCHR is designed to safely generate benign SVG from
** source text that provided by a hostile agent.
**
** This code was originally written by D. Richard Hipp using documentation
** from prior PIC implementations but without reference to prior code.
** All of the code in this project is original.
**
** This file implements a C-language subroutine that accepts a string
** of PIKCHR language text and generates a second string of SVG output that
** renders the drawing defined by the input.  Space to hold the returned
** string is obtained from malloc() and should be freed by the caller.
** NULL might be returned if there is a memory allocation error.
**
** If there are errors in the PIKCHR input, the output will consist of an
** error message and the original PIKCHR input text (inside of <pre>...</pre>).
**
** The subroutine implemented by this file is intended to be stand-alone.
** It uses no external routines other than routines commonly found in
** the standard C library.
**
****************************************************************************
** COMPILING:
**
** The original source text is a mixture of C99 and "Lemon"
** (See https://sqlite.org/src/file/doc/lemon.html).  Lemon is an LALR(1)
** parser generator program, similar to Yacc.  The grammar of the
** input language is specified in Lemon.  C-code is attached.  Lemon
** runs to generate a single output file ("pikchr.c") which is then
** compiled to generate the Pikchr library.  This header comment is
** preserved in the Lemon output, so you might be reading this in either
** the generated "pikchr.c" file that is output by Lemon, or in the
** "pikchr.y" source file that is input into Lemon.  If you make changes,
** you should change the input source file "pikchr.y", not the
** Lemon-generated output file.
**
** Basic compilation steps:
**
**      lemon pikchr.y
**      cc pikchr.c -o pikchr.o
**
** Add -DPIKCHR_SHELL to add a main() routine that reads input files
** and sends them through Pikchr, for testing.  Add -DPIKCHR_FUZZ for
** -fsanitizer=fuzzer testing.
**
****************************************************************************
** IMPLEMENTATION NOTES (for people who want to understand the internal
** operation of this software, perhaps to extend the code or to fix bugs):
**
** Each call to pikchr() uses a single instance of the Pik structure to
** track its internal state.  The Pik structure lives for the duration
** of the pikchr() call.
**
** The input is a sequence of objects or "statements".  Each statement is
** parsed into a PObj object.  These are stored on an extensible array
** called PList.  All parameters to each PObj are computed as the
** object is parsed.  (Hence, the parameters to a PObj may only refer
** to prior statements.) Once the PObj is completely assembled, it is
** added to the end of a PList and never changes thereafter - except,
** PObj objects that are part of a "[...]" block might have their
** absolute position shifted when the outer [...] block is positioned.
** But apart from this repositioning, PObj objects are unchanged once
** they are added to the list. The order of statements on a PList does
** not change.
**
** After all input has been parsed, the top-level PList is walked to
** generate output.  Sub-lists resulting from [...] blocks are scanned
** as they are encountered.  All input must be collected and parsed ahead
** of output generation because the size and position of statements must be
** known in order to compute a bounding box on the output.
**
** Each PObj is on a "layer".  (The common case is that all PObj's are
** on a single layer, but multiple layers are possible.)  A separate pass
** is made through the list for each layer.
**
** After all output is generated, the Pik object and all the PList
** and PObj objects are deallocated and the generated output string is
** returned.  Upon any error, the Pik.nErr flag is set, processing quickly
** stops, and the stack unwinds.  No attempt is made to continue reading
** input after an error.
**
** Most statements begin with a class name like "box" or "arrow" or "move".
** There is a class named "text" which is used for statements that begin
** with a string literal.  You can also specify the "text" class.
** A Sublist ("[...]") is a single object that contains a pointer to
** its substatements, all gathered onto a separate PList object.
**
** Variables go into PVar objects that form a linked list.
**
** Each PObj has zero or one names.  Input constructs that attempt
** to assign a new name from an older name, for example:
**
**      Abc:  Abc + (0.5cm, 0)
**
** Statements like these generate a new "noop" object at the specified
** place and with the given name. As place-names are searched by scanning
** the list in reverse order, this has the effect of overriding the "Abc"
** name when referenced by subsequent objects.
 */

package internal

import (
	"bytes"
	"fmt"
	"io"
	"math"
	"os"
	"regexp"
	"strconv"
	"strings"
)

// Numeric value
type PNum = float64

// Compass points
const (
	CP_N uint8 = iota + 1
	CP_NE
	CP_E
	CP_SE
	CP_S
	CP_SW
	CP_W
	CP_NW
	CP_C     /* .center or .c */
	CP_END   /* .end */
	CP_START /* .start */
)

const PIKCHR_TOKEN_LIMIT = 100000

/* Heading angles corresponding to compass points */
var pik_hdg_angle = []PNum{
	/* none  */ 0.0,
	/* N  */ 0.0,
	/* NE */ 45.0,
	/* E  */ 90.0,
	/* SE */ 135.0,
	/* S  */ 180.0,
	/* SW */ 225.0,
	/* W  */ 270.0,
	/* NW */ 315.0,
	/* C  */ 0.0,
}

/* Built-in functions */
const (
	FN_ABS  = 0
	FN_COS  = 1
	FN_INT  = 2
	FN_MAX  = 3
	FN_MIN  = 4
	FN_SIN  = 5
	FN_SQRT = 6
)

/* Text position and style flags.  Stored in PToken.eCode so limited
** to 15 bits. */
const (
	TP_LJUST  = 0x0001 /* left justify......          */
	TP_RJUST  = 0x0002 /*            ...Right justify */
	TP_JMASK  = 0x0003 /* Mask for justification bits */
	TP_ABOVE2 = 0x0004 /* Position text way above PObj.ptAt */
	TP_ABOVE  = 0x0008 /* Position text above PObj.ptAt */
	TP_CENTER = 0x0010 /* On the line */
	TP_BELOW  = 0x0020 /* Position text below PObj.ptAt */
	TP_BELOW2 = 0x0040 /* Position text way below PObj.ptAt */
	TP_VMASK  = 0x007c /* Mask for text positioning flags */
	TP_BIG    = 0x0100 /* Larger font */
	TP_SMALL  = 0x0200 /* Smaller font */
	TP_XTRA   = 0x0400 /* Amplify TP_BIG or TP_SMALL */
	TP_SZMASK = 0x0700 /* Font size mask */
	TP_ITALIC = 0x1000 /* Italic font */
	TP_BOLD   = 0x2000 /* Bold font */
	TP_FMASK  = 0x3000 /* Mask for font style */
	TP_ALIGN  = 0x4000 /* Rotate to align with the line */
)

/* An object to hold a position in 2-D space */
type PPoint struct {
	/* X and Y coordinates */
	x PNum
	y PNum
}

/* A bounding box */
type PBox struct {
	/* Lower-left and top-right corners */
	sw PPoint
	ne PPoint
}

/* An Absolute or a relative distance.  The absolute distance
** is stored in rAbs and the relative distance is stored in rRel.
** Usually, one or the other will be 0.0.  When using a PRel to
** update an existing value, the computation is usually something
** like this:
**
**          value = PRel.rAbs + value*PRel.rRel
**
 */
type PRel struct {
	rAbs PNum /* Absolute value */
	rRel PNum /* Value relative to current value */
}

/* A variable created by the ID = EXPR construct of the PIKCHR script
**
** PIKCHR (and PIC) scripts do not use many varaibles, so it is reasonable
** to store them all on a linked list.
 */
type PVar struct {
	zName string /* Name of the variable */
	val   PNum   /* Value of the variable */
	pNext *PVar  /* Next variable in a list of them all */
}

/* A single token in the parser input stream
 */
type PToken struct {
	z []byte /* Pointer to the token text */
	n int    /* Length of the token in bytes */

	eCode int16 /* Auxiliary code */
	eType uint8 /* The numeric parser code */
	eEdge uint8 /* Corner value for corner keywords */
}

func (p PToken) String() string {
	return string(p.z[:p.n])
}

/* Return negative, zero, or positive if pToken is less than, equal to
** or greater than the zero-terminated string z[]
 */
func pik_token_eq(pToken *PToken, z string) int {
	c := bytencmp(pToken.z, z, pToken.n)
	if c == 0 && len(z) > pToken.n && z[pToken.n] != 0 {
		c = -1
	}
	return c
}

/* Extra token types not generated by LEMON but needed by the
** tokenizer
 */
const (
	T_PARAMETER  = 253 /* $1, $2, ..., $9 */
	T_WHITESPACE = 254 /* Whitespace of comments */
	T_ERROR      = 255 /* Any text that is not a valid token */
)

/* Directions of movement */
const (
	DIR_RIGHT = 0
	DIR_DOWN  = 1
	DIR_LEFT  = 2
	DIR_UP    = 3
)

func ValidDir(x uint8) bool {
	return x >= 0 && x <= 3
}

func IsUpDown(x uint8) bool {
	return x&1 == 1
}

func IsLeftRight(x uint8) bool {
	return x&1 == 0
}

/* Bitmask for the various attributes for PObj.  These bits are
** collected in PObj.mProp and PObj.mCalc to check for constraint
** errors. */
const (
	A_WIDTH     = 0x0001
	A_HEIGHT    = 0x0002
	A_RADIUS    = 0x0004
	A_THICKNESS = 0x0008
	A_DASHED    = 0x0010 /* Includes "dotted" */
	A_FILL      = 0x0020
	A_COLOR     = 0x0040
	A_ARROW     = 0x0080
	A_FROM      = 0x0100
	A_CW        = 0x0200
	A_AT        = 0x0400
	A_TO        = 0x0800 /* one or more movement attributes */
	A_FIT       = 0x1000
)

/* A single graphics object */
type PObj struct {
	typ      *PClass /* Object type or class */
	errTok   PToken  /* Reference token for error messages */
	ptAt     PPoint  /* Reference point for the object */
	ptEnter  PPoint  /* Entry and exit points */
	ptExit   PPoint
	pSublist []*PObj   /* Substructure for [...] objects */
	zName    string    /* Name assigned to this statement */
	w        PNum      /* "width" property */
	h        PNum      /* "height" property */
	rad      PNum      /* "radius" property */
	sw       PNum      /* "thickness" property. (Mnemonic: "stroke width")*/
	dotted   PNum      /* "dotted" property.   <=0.0 for off */
	dashed   PNum      /* "dashed" property.   <=0.0 for off */
	fill     PNum      /* "fill" property.  Negative for off */
	color    PNum      /* "color" property */
	with     PPoint    /* Position constraint from WITH clause */
	eWith    uint8     /* Type of heading point on WITH clause */
	cw       bool      /* True for clockwise arc */
	larrow   bool      /* Arrow at beginning (<- or <->) */
	rarrow   bool      /* Arrow at end  (-> or <->) */
	bClose   bool      /* True if "close" is seen */
	bChop    bool      /* True if "chop" is seen */
	nTxt     uint8     /* Number of text values */
	mProp    uint      /* Masks of properties set so far */
	mCalc    uint      /* Values computed from other constraints */
	aTxt     [5]PToken /* Text with .eCode holding TP flags */
	iLayer   int       /* Rendering order */
	inDir    uint8     /* Entry and exit directions */
	outDir   uint8
	nPath    int      /* Number of path points */
	aPath    []PPoint /* Array of path points */
	pFrom    *PObj    /* End-point objects of a path */
	pTo      *PObj
	bbox     PBox /* Bounding box */
}

// /* A list of graphics objects */
//
//	type PList struct {
//	  int n;          /* Number of statements in the list */
//	  int nAlloc;     /* Allocated slots in a[] */
//	  PObj **a;       /* Pointers to individual objects */
//	};
type PList = []*PObj

/* A macro definition */
type PMacro struct {
	pNext     *PMacro /* Next in the list */
	macroName PToken  /* Name of the macro */
	macroBody PToken  /* Body of the macro */
	inUse     bool    /* Do not allow recursion */
}

/* Each call to the pikchr() subroutine uses an instance of the following
** object to pass around context to all of its subroutines.
 */
type Pik struct {
	nErr      int          /* Number of errors seen */
	nToken    uint         /* Number of tokens parsed */
	sIn       PToken       /* Input Pikchr-language text */
	zOut      bytes.Buffer /* Result accumulates here */
	nOut      uint         /* Bytes written to zOut[] so far */
	nOutAlloc uint         /* Space allocated to zOut[] */
	eDir      uint8        /* Current direction */
	mFlags    uint         /* Flags passed to pikchr() */
	cur       *PObj        /* Object under construction */
	lastRef   *PObj        /* Last object references by name */
	list      []*PObj      /* Object list under construction */
	pMacros   *PMacro      /* List of all defined macros */
	pVar      *PVar        /* Application-defined variables */
	bbox      PBox         /* Bounding box around all statements */
	/* Cache of layout values.  <=0.0 for unknown... */
	rScale      PNum   /* Multiply to convert inches to pixels */
	fontScale   PNum   /* Scale fonts by this percent */
	charWidth   PNum   /* Character width */
	charHeight  PNum   /* Character height */
	wArrow      PNum   /* Width of arrowhead at the fat end */
	hArrow      PNum   /* Ht of arrowhead - dist from tip to fat end */
	bLayoutVars bool   /* True if cache is valid */
	thenFlag    bool   /* True if "then" seen */
	samePath    bool   /* aTPath copied by "same" */
	zClass      string /* Class name for the <svg> */
	wSVG        int    /* Width and height of the <svg> */
	hSVG        int
	fgcolor     int /* foreground color value, or -1 for none */
	bgcolor     int /* background color value, or -1 for none */
	/* Paths for lines are constructed here first, then transferred into
	 ** the PObj object at the end: */
	nTPath int          /* Number of entries on aTPath[] */
	mTPath int          /* For last entry, 1: x set,  2: y set */
	aTPath [1000]PPoint /* Path under construction */
	/* Error contexts */
	nCtx int        /* Number of error contexts */
	aCtx [10]PToken /* Nested error contexts */
}

/* Include PIKCHR_PLAINTEXT_ERRORS among the bits of mFlags on the 3rd
** argument to pikchr() in order to cause error message text to come out
** as text/plain instead of as text/html
 */
const PIKCHR_PLAINTEXT_ERRORS = 0x0001

/* Include PIKCHR_DARK_MODE among the mFlag bits to invert colors.
 */
const PIKCHR_DARK_MODE = 0x0002

/*
** The behavior of an object class is defined by an instance of
** this structure. This is the "virtual method" table.
 */
type PClass struct {
	zName  string /* Name of class */
	isLine bool   /* True if a line class */
	eJust  int8   /* Use box-style text justification */

	xInit    func(*Pik, *PObj)                          /* Initializer */
	xNumProp func(*Pik, *PObj, *PToken)                 /* Value change notification */
	xCheck   func(*Pik, *PObj)                          /* Checks to do after parsing */
	xChop    func(*Pik, *PObj, *PPoint) PPoint          /* Chopper */
	xOffset  func(*Pik, *PObj, uint8) PPoint            /* Offset from .c to edge point */
	xFit     func(pik *Pik, pobj *PObj, w PNum, h PNum) /* Size to fit text */
	xRender  func(*Pik, *PObj)                          /* Render */
}

func yytestcase(condition bool) {}

//line 473 "pikchr.go"

/**************** End of %include directives **********************************/
/* These constants specify the various numeric values for terminal symbols.
***************** Begin token definitions *************************************/

const (
	T_ID        = 1
	T_EDGEPT    = 2
	T_OF        = 3
	T_PLUS      = 4
	T_MINUS     = 5
	T_STAR      = 6
	T_SLASH     = 7
	T_PERCENT   = 8
	T_UMINUS    = 9
	T_EOL       = 10
	T_ASSIGN    = 11
	T_PLACENAME = 12
	T_COLON     = 13
	T_ASSERT    = 14
	T_LP        = 15
	T_EQ        = 16
	T_RP        = 17
	T_DEFINE    = 18
	T_CODEBLOCK = 19
	T_FILL      = 20
	T_COLOR     = 21
	T_THICKNESS = 22
	T_PRINT     = 23
	T_STRING    = 24
	T_COMMA     = 25
	T_CLASSNAME = 26
	T_LB        = 27
	T_RB        = 28
	T_UP        = 29
	T_DOWN      = 30
	T_LEFT      = 31
	T_RIGHT     = 32
	T_CLOSE     = 33
	T_CHOP      = 34
	T_FROM      = 35
	T_TO        = 36
	T_THEN      = 37
	T_HEADING   = 38
	T_GO        = 39
	T_AT        = 40
	T_WITH      = 41
	T_SAME      = 42
	T_AS        = 43
	T_FIT       = 44
	T_BEHIND    = 45
	T_UNTIL     = 46
	T_EVEN      = 47
	T_DOT_E     = 48
	T_HEIGHT    = 49
	T_WIDTH     = 50
	T_RADIUS    = 51
	T_DIAMETER  = 52
	T_DOTTED    = 53
	T_DASHED    = 54
	T_CW        = 55
	T_CCW       = 56
	T_LARROW    = 57
	T_RARROW    = 58
	T_LRARROW   = 59
	T_INVIS     = 60
	T_THICK     = 61
	T_THIN      = 62
	T_SOLID     = 63
	T_CENTER    = 64
	T_LJUST     = 65
	T_RJUST     = 66
	T_ABOVE     = 67
	T_BELOW     = 68
	T_ITALIC    = 69
	T_BOLD      = 70
	T_ALIGNED   = 71
	T_BIG       = 72
	T_SMALL     = 73
	T_AND       = 74
	T_LT        = 75
	T_GT        = 76
	T_ON        = 77
	T_WAY       = 78
	T_BETWEEN   = 79
	T_THE       = 80
	T_NTH       = 81
	T_VERTEX    = 82
	T_TOP       = 83
	T_BOTTOM    = 84
	T_START     = 85
	T_END       = 86
	T_IN        = 87
	T_THIS      = 88
	T_DOT_U     = 89
	T_LAST      = 90
	T_NUMBER    = 91
	T_FUNC1     = 92
	T_FUNC2     = 93
	T_DIST      = 94
	T_DOT_XY    = 95
	T_X         = 96
	T_Y         = 97
	T_DOT_L     = 98
)

/**************** End token definitions ***************************************/

/* The next sections is a series of control #defines.
** various aspects of the generated parser.
**    YYCODETYPE         is the data type used to store the integer codes
**                       that represent terminal and non-terminal symbols.
**                       "unsigned char" is used if there are fewer than
**                       256 symbols.  Larger types otherwise.
**    YYNOCODE           is a number of type YYCODETYPE that is not used for
**                       any terminal or nonterminal symbol.
**    YYFALLBACK         If defined, this indicates that one or more tokens
**                       (also known as: "terminal symbols") have fall-back
**                       values which should be used if the original symbol
**                       would not parse.  This permits keywords to sometimes
**                       be used as identifiers, for example.
**    YYACTIONTYPE       is the data type used for "action codes" - numbers
**                       that indicate what to do in response to the next
**                       token.
**    pik_parserTOKENTYPE     is the data type used for minor type for terminal
**                       symbols.  Background: A "minor type" is a semantic
**                       value associated with a terminal or non-terminal
**                       symbols.  For example, for an "ID" terminal symbol,
**                       the minor type might be the name of the identifier.
**                       Each non-terminal can have a different minor type.
**                       Terminal symbols all have the same minor type, though.
**                       This macros defines the minor type for terminal
**                       symbols.
**    YYMINORTYPE        is the data type used for all minor types.
**                       This is typically a union of many types, one of
**                       which is pik_parserTOKENTYPE.  The entry in the union
**                       for terminal symbols is called "yy0".
**    YYSTACKDEPTH       is the maximum depth of the parser's stack.  If
**                       zero the stack is dynamically sized using realloc()
**    pik_parserARG_SDECL     A static variable declaration for the %extra_argument
**    pik_parserARG_PDECL     A parameter declaration for the %extra_argument
**    pik_parserARG_PARAM     Code to pass %extra_argument as a subroutine parameter
**    pik_parserARG_STORE     Code to store %extra_argument into yypParser
**    pik_parserARG_FETCH     Code to extract %extra_argument from yypParser
**    pik_parserCTX_*         As pik_parserARG_ except for %extra_context
**    YYERRORSYMBOL      is the code number of the error symbol.  If not
**                       defined, then do no error processing.
**    YYNSTATE           the combined number of states.
**    YYNRULE            the number of rules in the grammar
**    YYNTOKEN           Number of terminal symbols
**    YY_MAX_SHIFT       Maximum value for shift actions
**    YY_MIN_SHIFTREDUCE Minimum value for shift-reduce actions
**    YY_MAX_SHIFTREDUCE Maximum value for shift-reduce actions
**    YY_ERROR_ACTION    The yy_action[] code for syntax error
**    YY_ACCEPT_ACTION   The yy_action[] code for accept
**    YY_NO_ACTION       The yy_action[] code for no-op
**    YY_MIN_REDUCE      Minimum value for reduce actions
**    YY_MAX_REDUCE      Maximum value for reduce actions
 */
/************* Begin control #defines *****************************************/
const YYNOCODE = 135

type YYCODETYPE = uint8
type YYACTIONTYPE = uint16
type pik_parserTOKENTYPE = PToken
type YYMINORTYPE struct {
	yyinit int
	yy0    pik_parserTOKENTYPE
	yy10   PRel
	yy79   PPoint
	yy104  *PObj
	yy112  int
	yy153  PNum
	yy186  []*PObj
}

const YYWILDCARD = 0
const YYSTACKDEPTH = 100
const YYNOERRORRECOVERY = false
const YYCOVERAGE = false
const YYTRACKMAXSTACKDEPTH = false
const NDEBUG = false
const YYERRORSYMBOL = 0
const YYFALLBACK = true
const YYNSTATE = 164
const YYNRULE = 156
const YYNRULE_WITH_ACTION = 116
const YYNTOKEN = 99
const YY_MAX_SHIFT = 163
const YY_MIN_SHIFTREDUCE = 287
const YY_MAX_SHIFTREDUCE = 442
const YY_ERROR_ACTION = 443
const YY_ACCEPT_ACTION = 444
const YY_NO_ACTION = 445
const YY_MIN_REDUCE = 446
const YY_MAX_REDUCE = 601

/************* End control #defines *******************************************/

/* Applications can choose to define yytestcase() in the %include section
** to a macro that can assist in verifying code coverage.  For production
** code the yytestcase() macro should be turned off.  But it is useful
** for testing.
 */

/* Next are the tables used to determine what action to take based on the
** current state and lookahead token.  These tables are used to implement
** functions that take a state number and lookahead value and return an
** action integer.
**
** Suppose the action integer is N.  Then the action is determined as
** follows
**
**   0 <= N <= YY_MAX_SHIFT             Shift N.  That is, push the lookahead
**                                      token onto the stack and goto state N.
**
**   N between YY_MIN_SHIFTREDUCE       Shift to an arbitrary state then
**     and YY_MAX_SHIFTREDUCE           reduce by rule N-YY_MIN_SHIFTREDUCE.
**
**   N == YY_ERROR_ACTION               A syntax error has occurred.
**
**   N == YY_ACCEPT_ACTION              The parser accepts its input.
**
**   N == YY_NO_ACTION                  No such action.  Denotes unused
**                                      slots in the yy_action[] table.
**
**   N between YY_MIN_REDUCE            Reduce by rule N-YY_MIN_REDUCE
**     and YY_MAX_REDUCE
**
** The action table is constructed as a single large table named yy_action[].
** Given state S and lookahead X, the action is computed as either:
**
**    (A)   N = yy_action[ yy_shift_ofst[S] + X ]
**    (B)   N = yy_default[S]
**
** The (A) formula is preferred.  The B formula is used instead if
** yy_lookahead[yy_shift_ofst[S]+X] is not equal to X.
**
** The formulas above are for computing the action when the lookahead is
** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
** a reduce action) then the yy_reduce_ofst[] array is used in place of
** the yy_shift_ofst[] array.
**
** The following are the tables generated in this section:
**
**  yy_action[]        A single table containing all actions.
**  yy_lookahead[]     A table containing the lookahead for each entry in
**                     yy_action.  Used to detect hash collisions.
**  yy_shift_ofst[]    For each state, the offset into yy_action for
**                     shifting terminals.
**  yy_reduce_ofst[]   For each state, the offset into yy_action for
**                     shifting non-terminals after a reduce.
**  yy_default[]       Default action for each state.
**
*********** Begin parsing tables **********************************************/
const YY_ACTTAB_COUNT = 1303

var yy_action = []YYACTIONTYPE{
	/* 0 */ 575, 495, 161, 119, 25, 452, 29, 74, 129, 148,
	/* 10 */ 575, 492, 161, 119, 453, 113, 120, 161, 119, 530,
	/* 20 */ 427, 428, 339, 559, 81, 30, 560, 561, 575, 64,
	/* 30 */ 63, 62, 61, 322, 323, 9, 8, 33, 149, 32,
	/* 40 */ 7, 71, 127, 38, 335, 66, 48, 37, 28, 339,
	/* 50 */ 339, 339, 339, 425, 426, 340, 341, 342, 343, 344,
	/* 60 */ 345, 346, 347, 348, 474, 528, 161, 119, 577, 77,
	/* 70 */ 577, 73, 376, 148, 474, 533, 161, 119, 112, 113,
	/* 80 */ 120, 161, 119, 128, 427, 428, 339, 357, 81, 531,
	/* 90 */ 161, 119, 474, 36, 330, 13, 306, 322, 323, 9,
	/* 100 */ 8, 33, 149, 32, 7, 71, 127, 328, 335, 66,
	/* 110 */ 579, 310, 31, 339, 339, 339, 339, 425, 426, 340,
	/* 120 */ 341, 342, 343, 344, 345, 346, 347, 348, 394, 435,
	/* 130 */ 46, 59, 60, 64, 63, 62, 61, 54, 51, 376,
	/* 140 */ 69, 108, 2, 47, 403, 83, 297, 435, 375, 84,
	/* 150 */ 117, 80, 35, 308, 79, 133, 122, 126, 441, 440,
	/* 160 */ 299, 123, 3, 404, 405, 406, 408, 80, 298, 308,
	/* 170 */ 79, 4, 411, 412, 413, 414, 441, 440, 350, 350,
	/* 180 */ 350, 350, 350, 350, 350, 350, 350, 350, 62, 61,
	/* 190 */ 67, 434, 1, 75, 378, 158, 74, 76, 148, 411,
	/* 200 */ 412, 413, 414, 124, 113, 120, 161, 119, 106, 434,
	/* 210 */ 436, 437, 438, 439, 5, 375, 6, 117, 393, 155,
	/* 220 */ 154, 153, 394, 435, 69, 59, 60, 149, 436, 437,
	/* 230 */ 438, 439, 535, 376, 398, 399, 2, 424, 427, 428,
	/* 240 */ 339, 156, 156, 156, 423, 394, 435, 65, 59, 60,
	/* 250 */ 162, 131, 441, 440, 397, 72, 376, 148, 118, 2,
	/* 260 */ 380, 157, 125, 113, 120, 161, 119, 339, 339, 339,
	/* 270 */ 339, 425, 426, 535, 11, 441, 440, 394, 356, 535,
	/* 280 */ 59, 60, 535, 379, 159, 434, 149, 12, 102, 446,
	/* 290 */ 432, 42, 138, 14, 435, 139, 301, 302, 303, 36,
	/* 300 */ 305, 430, 106, 16, 436, 437, 438, 439, 434, 375,
	/* 310 */ 18, 117, 393, 155, 154, 153, 44, 142, 140, 64,
	/* 320 */ 63, 62, 61, 441, 440, 106, 19, 436, 437, 438,
	/* 330 */ 439, 45, 375, 20, 117, 393, 155, 154, 153, 68,
	/* 340 */ 55, 114, 64, 63, 62, 61, 147, 146, 394, 473,
	/* 350 */ 359, 59, 60, 43, 23, 391, 434, 106, 26, 376,
	/* 360 */ 57, 58, 42, 49, 375, 392, 117, 393, 155, 154,
	/* 370 */ 153, 64, 63, 62, 61, 436, 437, 438, 439, 384,
	/* 380 */ 382, 383, 22, 21, 377, 473, 160, 70, 39, 445,
	/* 390 */ 24, 445, 145, 141, 431, 142, 140, 64, 63, 62,
	/* 400 */ 61, 394, 15, 445, 59, 60, 64, 63, 62, 61,
	/* 410 */ 391, 445, 376, 445, 445, 42, 445, 445, 55, 391,
	/* 420 */ 156, 156, 156, 445, 147, 146, 445, 52, 106, 445,
	/* 430 */ 445, 43, 445, 445, 445, 375, 445, 117, 393, 155,
	/* 440 */ 154, 153, 445, 394, 143, 445, 59, 60, 64, 63,
	/* 450 */ 62, 61, 313, 445, 376, 378, 158, 42, 445, 445,
	/* 460 */ 22, 21, 121, 447, 454, 29, 445, 445, 24, 450,
	/* 470 */ 145, 141, 431, 142, 140, 64, 63, 62, 61, 445,
	/* 480 */ 163, 106, 445, 445, 444, 27, 445, 445, 375, 445,
	/* 490 */ 117, 393, 155, 154, 153, 445, 55, 74, 445, 148,
	/* 500 */ 445, 445, 147, 146, 497, 113, 120, 161, 119, 43,
	/* 510 */ 445, 394, 445, 445, 59, 60, 445, 445, 445, 118,
	/* 520 */ 445, 445, 376, 106, 445, 42, 445, 445, 149, 445,
	/* 530 */ 375, 445, 117, 393, 155, 154, 153, 445, 22, 21,
	/* 540 */ 394, 144, 445, 59, 60, 445, 24, 445, 145, 141,
	/* 550 */ 431, 376, 445, 445, 42, 445, 132, 130, 394, 445,
	/* 560 */ 445, 59, 60, 109, 447, 454, 29, 445, 445, 376,
	/* 570 */ 450, 445, 42, 445, 394, 445, 445, 59, 60, 445,
	/* 580 */ 445, 163, 445, 445, 445, 102, 27, 445, 42, 445,
	/* 590 */ 445, 106, 445, 64, 63, 62, 61, 445, 375, 445,
	/* 600 */ 117, 393, 155, 154, 153, 394, 355, 445, 59, 60,
	/* 610 */ 445, 445, 445, 445, 445, 74, 376, 148, 445, 40,
	/* 620 */ 106, 445, 496, 113, 120, 161, 119, 375, 445, 117,
	/* 630 */ 393, 155, 154, 153, 445, 448, 454, 29, 106, 445,
	/* 640 */ 445, 450, 445, 445, 445, 375, 149, 117, 393, 155,
	/* 650 */ 154, 153, 163, 445, 106, 445, 445, 27, 445, 445,
	/* 660 */ 445, 375, 445, 117, 393, 155, 154, 153, 394, 445,
	/* 670 */ 445, 59, 60, 64, 63, 62, 61, 445, 445, 376,
	/* 680 */ 445, 445, 41, 445, 445, 106, 354, 64, 63, 62,
	/* 690 */ 61, 445, 375, 445, 117, 393, 155, 154, 153, 445,
	/* 700 */ 445, 445, 74, 445, 148, 445, 88, 445, 445, 490,
	/* 710 */ 113, 120, 161, 119, 445, 120, 161, 119, 17, 74,
	/* 720 */ 445, 148, 110, 110, 445, 445, 484, 113, 120, 161,
	/* 730 */ 119, 445, 445, 149, 74, 445, 148, 152, 445, 445,
	/* 740 */ 445, 483, 113, 120, 161, 119, 445, 445, 106, 445,
	/* 750 */ 149, 445, 445, 107, 445, 375, 445, 117, 393, 155,
	/* 760 */ 154, 153, 120, 161, 119, 149, 478, 74, 445, 148,
	/* 770 */ 445, 88, 445, 445, 480, 113, 120, 161, 119, 445,
	/* 780 */ 120, 161, 119, 74, 152, 148, 10, 479, 479, 445,
	/* 790 */ 134, 113, 120, 161, 119, 445, 445, 445, 149, 74,
	/* 800 */ 445, 148, 152, 445, 445, 445, 517, 113, 120, 161,
	/* 810 */ 119, 445, 445, 74, 149, 148, 445, 445, 445, 445,
	/* 820 */ 137, 113, 120, 161, 119, 74, 445, 148, 445, 445,
	/* 830 */ 149, 445, 525, 113, 120, 161, 119, 445, 74, 445,
	/* 840 */ 148, 445, 445, 445, 149, 527, 113, 120, 161, 119,
	/* 850 */ 445, 445, 74, 445, 148, 445, 149, 445, 445, 524,
	/* 860 */ 113, 120, 161, 119, 74, 445, 148, 445, 445, 149,
	/* 870 */ 445, 526, 113, 120, 161, 119, 445, 445, 74, 445,
	/* 880 */ 148, 445, 88, 149, 445, 523, 113, 120, 161, 119,
	/* 890 */ 445, 120, 161, 119, 74, 149, 148, 85, 111, 111,
	/* 900 */ 445, 522, 113, 120, 161, 119, 120, 161, 119, 149,
	/* 910 */ 74, 445, 148, 152, 445, 445, 445, 521, 113, 120,
	/* 920 */ 161, 119, 445, 445, 74, 149, 148, 445, 152, 445,
	/* 930 */ 445, 520, 113, 120, 161, 119, 74, 445, 148, 445,
	/* 940 */ 445, 149, 445, 519, 113, 120, 161, 119, 445, 74,
	/* 950 */ 445, 148, 445, 445, 445, 149, 150, 113, 120, 161,
	/* 960 */ 119, 445, 445, 74, 445, 148, 445, 149, 445, 445,
	/* 970 */ 151, 113, 120, 161, 119, 74, 445, 148, 445, 445,
	/* 980 */ 149, 445, 136, 113, 120, 161, 119, 445, 445, 74,
	/* 990 */ 445, 148, 107, 445, 149, 445, 135, 113, 120, 161,
	/* 1000 */ 119, 120, 161, 119, 445, 463, 149, 445, 88, 445,
	/* 1010 */ 445, 445, 78, 78, 445, 445, 107, 120, 161, 119,
	/* 1020 */ 149, 445, 445, 152, 82, 120, 161, 119, 445, 463,
	/* 1030 */ 445, 466, 86, 34, 445, 88, 445, 569, 445, 152,
	/* 1040 */ 445, 120, 161, 119, 120, 161, 119, 152, 107, 445,
	/* 1050 */ 445, 475, 64, 63, 62, 61, 445, 120, 161, 119,
	/* 1060 */ 98, 451, 445, 152, 89, 396, 152, 90, 445, 120,
	/* 1070 */ 161, 119, 445, 120, 161, 119, 120, 161, 119, 152,
	/* 1080 */ 445, 64, 63, 62, 61, 445, 445, 445, 445, 445,
	/* 1090 */ 87, 152, 445, 99, 395, 152, 100, 445, 152, 120,
	/* 1100 */ 161, 119, 120, 161, 119, 120, 161, 119, 445, 101,
	/* 1110 */ 64, 63, 62, 61, 445, 445, 445, 445, 120, 161,
	/* 1120 */ 119, 152, 91, 391, 152, 445, 445, 152, 103, 445,
	/* 1130 */ 445, 120, 161, 119, 445, 92, 445, 120, 161, 119,
	/* 1140 */ 152, 93, 445, 445, 120, 161, 119, 104, 445, 445,
	/* 1150 */ 120, 161, 119, 152, 445, 445, 120, 161, 119, 152,
	/* 1160 */ 445, 445, 445, 445, 94, 445, 152, 445, 445, 445,
	/* 1170 */ 105, 445, 152, 120, 161, 119, 445, 95, 152, 120,
	/* 1180 */ 161, 119, 96, 445, 445, 445, 120, 161, 119, 445,
	/* 1190 */ 445, 120, 161, 119, 97, 152, 445, 445, 445, 445,
	/* 1200 */ 549, 152, 445, 120, 161, 119, 548, 445, 152, 120,
	/* 1210 */ 161, 119, 445, 152, 445, 120, 161, 119, 445, 445,
	/* 1220 */ 445, 445, 445, 547, 445, 152, 445, 445, 445, 445,
	/* 1230 */ 445, 152, 120, 161, 119, 546, 445, 152, 445, 115,
	/* 1240 */ 445, 445, 116, 445, 120, 161, 119, 445, 120, 161,
	/* 1250 */ 119, 120, 161, 119, 152, 64, 63, 62, 61, 64,
	/* 1260 */ 63, 62, 61, 445, 445, 445, 152, 445, 445, 445,
	/* 1270 */ 152, 445, 445, 152, 445, 445, 50, 445, 445, 445,
	/* 1280 */ 53, 64, 63, 62, 61, 445, 445, 445, 445, 445,
	/* 1290 */ 445, 445, 445, 445, 445, 445, 445, 445, 445, 445,
	/* 1300 */ 445, 445, 56,
}
var yy_lookahead = []YYCODETYPE{
	/* 0 */ 0, 112, 113, 114, 133, 101, 102, 103, 105, 105,
	/* 10 */ 10, 112, 113, 114, 110, 111, 112, 113, 114, 105,
	/* 20 */ 20, 21, 22, 104, 24, 125, 107, 108, 28, 4,
	/* 30 */ 5, 6, 7, 33, 34, 35, 36, 37, 134, 39,
	/* 40 */ 40, 41, 42, 104, 44, 45, 107, 108, 106, 49,
	/* 50 */ 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
	/* 60 */ 60, 61, 62, 63, 0, 112, 113, 114, 129, 130,
	/* 70 */ 131, 103, 12, 105, 10, 112, 113, 114, 110, 111,
	/* 80 */ 112, 113, 114, 105, 20, 21, 22, 17, 24, 112,
	/* 90 */ 113, 114, 28, 10, 2, 25, 25, 33, 34, 35,
	/* 100 */ 36, 37, 134, 39, 40, 41, 42, 2, 44, 45,
	/* 110 */ 132, 28, 127, 49, 50, 51, 52, 53, 54, 55,
	/* 120 */ 56, 57, 58, 59, 60, 61, 62, 63, 1, 2,
	/* 130 */ 38, 4, 5, 4, 5, 6, 7, 4, 5, 12,
	/* 140 */ 3, 81, 15, 38, 1, 115, 17, 2, 88, 115,
	/* 150 */ 90, 24, 128, 26, 27, 12, 1, 14, 31, 32,
	/* 160 */ 19, 18, 16, 20, 21, 22, 23, 24, 17, 26,
	/* 170 */ 27, 15, 29, 30, 31, 32, 31, 32, 64, 65,
	/* 180 */ 66, 67, 68, 69, 70, 71, 72, 73, 6, 7,
	/* 190 */ 43, 64, 13, 48, 26, 27, 103, 48, 105, 29,
	/* 200 */ 30, 31, 32, 110, 111, 112, 113, 114, 81, 64,
	/* 210 */ 83, 84, 85, 86, 40, 88, 40, 90, 91, 92,
	/* 220 */ 93, 94, 1, 2, 87, 4, 5, 134, 83, 84,
	/* 230 */ 85, 86, 48, 12, 96, 97, 15, 41, 20, 21,
	/* 240 */ 22, 20, 21, 22, 41, 1, 2, 98, 4, 5,
	/* 250 */ 82, 47, 31, 32, 17, 103, 12, 105, 90, 15,
	/* 260 */ 26, 27, 110, 111, 112, 113, 114, 49, 50, 51,
	/* 270 */ 52, 53, 54, 89, 25, 31, 32, 1, 17, 95,
	/* 280 */ 4, 5, 98, 26, 27, 64, 134, 74, 12, 0,
	/* 290 */ 79, 15, 78, 3, 2, 80, 20, 21, 22, 10,
	/* 300 */ 24, 79, 81, 3, 83, 84, 85, 86, 64, 88,
	/* 310 */ 3, 90, 91, 92, 93, 94, 38, 2, 3, 4,
	/* 320 */ 5, 6, 7, 31, 32, 81, 3, 83, 84, 85,
	/* 330 */ 86, 16, 88, 3, 90, 91, 92, 93, 94, 3,
	/* 340 */ 25, 95, 4, 5, 6, 7, 31, 32, 1, 2,
	/* 350 */ 76, 4, 5, 38, 25, 17, 64, 81, 15, 12,
	/* 360 */ 15, 15, 15, 25, 88, 17, 90, 91, 92, 93,
	/* 370 */ 94, 4, 5, 6, 7, 83, 84, 85, 86, 28,
	/* 380 */ 28, 28, 67, 68, 12, 38, 89, 3, 11, 135,
	/* 390 */ 75, 135, 77, 78, 79, 2, 3, 4, 5, 6,
	/* 400 */ 7, 1, 35, 135, 4, 5, 4, 5, 6, 7,
	/* 410 */ 17, 135, 12, 135, 135, 15, 135, 135, 25, 17,
	/* 420 */ 20, 21, 22, 135, 31, 32, 135, 25, 81, 135,
	/* 430 */ 135, 38, 135, 135, 135, 88, 135, 90, 91, 92,
	/* 440 */ 93, 94, 135, 1, 2, 135, 4, 5, 4, 5,
	/* 450 */ 6, 7, 8, 135, 12, 26, 27, 15, 135, 135,
	/* 460 */ 67, 68, 99, 100, 101, 102, 135, 135, 75, 106,
	/* 470 */ 77, 78, 79, 2, 3, 4, 5, 6, 7, 135,
	/* 480 */ 117, 81, 135, 135, 121, 122, 135, 135, 88, 135,
	/* 490 */ 90, 91, 92, 93, 94, 135, 25, 103, 135, 105,
	/* 500 */ 135, 135, 31, 32, 110, 111, 112, 113, 114, 38,
	/* 510 */ 135, 1, 135, 135, 4, 5, 135, 135, 135, 90,
	/* 520 */ 135, 135, 12, 81, 135, 15, 135, 135, 134, 135,
	/* 530 */ 88, 135, 90, 91, 92, 93, 94, 135, 67, 68,
	/* 540 */ 1, 2, 135, 4, 5, 135, 75, 135, 77, 78,
	/* 550 */ 79, 12, 135, 135, 15, 135, 46, 47, 1, 135,
	/* 560 */ 135, 4, 5, 99, 100, 101, 102, 135, 135, 12,
	/* 570 */ 106, 135, 15, 135, 1, 135, 135, 4, 5, 135,
	/* 580 */ 135, 117, 135, 135, 135, 12, 122, 135, 15, 135,
	/* 590 */ 135, 81, 135, 4, 5, 6, 7, 135, 88, 135,
	/* 600 */ 90, 91, 92, 93, 94, 1, 17, 135, 4, 5,
	/* 610 */ 135, 135, 135, 135, 135, 103, 12, 105, 135, 15,
	/* 620 */ 81, 135, 110, 111, 112, 113, 114, 88, 135, 90,
	/* 630 */ 91, 92, 93, 94, 135, 100, 101, 102, 81, 135,
	/* 640 */ 135, 106, 135, 135, 135, 88, 134, 90, 91, 92,
	/* 650 */ 93, 94, 117, 135, 81, 135, 135, 122, 135, 135,
	/* 660 */ 135, 88, 135, 90, 91, 92, 93, 94, 1, 135,
	/* 670 */ 135, 4, 5, 4, 5, 6, 7, 135, 135, 12,
	/* 680 */ 135, 135, 15, 135, 135, 81, 17, 4, 5, 6,
	/* 690 */ 7, 135, 88, 135, 90, 91, 92, 93, 94, 135,
	/* 700 */ 135, 135, 103, 135, 105, 135, 103, 135, 135, 110,
	/* 710 */ 111, 112, 113, 114, 135, 112, 113, 114, 35, 103,
	/* 720 */ 135, 105, 119, 120, 135, 135, 110, 111, 112, 113,
	/* 730 */ 114, 135, 135, 134, 103, 135, 105, 134, 135, 135,
	/* 740 */ 135, 110, 111, 112, 113, 114, 135, 135, 81, 135,
	/* 750 */ 134, 135, 135, 103, 135, 88, 135, 90, 91, 92,
	/* 760 */ 93, 94, 112, 113, 114, 134, 116, 103, 135, 105,
	/* 770 */ 135, 103, 135, 135, 110, 111, 112, 113, 114, 135,
	/* 780 */ 112, 113, 114, 103, 134, 105, 118, 119, 120, 135,
	/* 790 */ 110, 111, 112, 113, 114, 135, 135, 135, 134, 103,
	/* 800 */ 135, 105, 134, 135, 135, 135, 110, 111, 112, 113,
	/* 810 */ 114, 135, 135, 103, 134, 105, 135, 135, 135, 135,
	/* 820 */ 110, 111, 112, 113, 114, 103, 135, 105, 135, 135,
	/* 830 */ 134, 135, 110, 111, 112, 113, 114, 135, 103, 135,
	/* 840 */ 105, 135, 135, 135, 134, 110, 111, 112, 113, 114,
	/* 850 */ 135, 135, 103, 135, 105, 135, 134, 135, 135, 110,
	/* 860 */ 111, 112, 113, 114, 103, 135, 105, 135, 135, 134,
	/* 870 */ 135, 110, 111, 112, 113, 114, 135, 135, 103, 135,
	/* 880 */ 105, 135, 103, 134, 135, 110, 111, 112, 113, 114,
	/* 890 */ 135, 112, 113, 114, 103, 134, 105, 103, 119, 120,
	/* 900 */ 135, 110, 111, 112, 113, 114, 112, 113, 114, 134,
	/* 910 */ 103, 135, 105, 134, 135, 135, 135, 110, 111, 112,
	/* 920 */ 113, 114, 135, 135, 103, 134, 105, 135, 134, 135,
	/* 930 */ 135, 110, 111, 112, 113, 114, 103, 135, 105, 135,
	/* 940 */ 135, 134, 135, 110, 111, 112, 113, 114, 135, 103,
	/* 950 */ 135, 105, 135, 135, 135, 134, 110, 111, 112, 113,
	/* 960 */ 114, 135, 135, 103, 135, 105, 135, 134, 135, 135,
	/* 970 */ 110, 111, 112, 113, 114, 103, 135, 105, 135, 135,
	/* 980 */ 134, 135, 110, 111, 112, 113, 114, 135, 135, 103,
	/* 990 */ 135, 105, 103, 135, 134, 135, 110, 111, 112, 113,
	/* 1000 */ 114, 112, 113, 114, 135, 116, 134, 135, 103, 135,
	/* 1010 */ 135, 135, 123, 124, 135, 135, 103, 112, 113, 114,
	/* 1020 */ 134, 135, 135, 134, 119, 112, 113, 114, 135, 116,
	/* 1030 */ 135, 126, 103, 128, 135, 103, 135, 124, 135, 134,
	/* 1040 */ 135, 112, 113, 114, 112, 113, 114, 134, 103, 135,
	/* 1050 */ 135, 119, 4, 5, 6, 7, 135, 112, 113, 114,
	/* 1060 */ 103, 116, 135, 134, 103, 17, 134, 103, 135, 112,
	/* 1070 */ 113, 114, 135, 112, 113, 114, 112, 113, 114, 134,
	/* 1080 */ 135, 4, 5, 6, 7, 135, 135, 135, 135, 135,
	/* 1090 */ 103, 134, 135, 103, 17, 134, 103, 135, 134, 112,
	/* 1100 */ 113, 114, 112, 113, 114, 112, 113, 114, 135, 103,
	/* 1110 */ 4, 5, 6, 7, 135, 135, 135, 135, 112, 113,
	/* 1120 */ 114, 134, 103, 17, 134, 135, 135, 134, 103, 135,
	/* 1130 */ 135, 112, 113, 114, 135, 103, 135, 112, 113, 114,
	/* 1140 */ 134, 103, 135, 135, 112, 113, 114, 103, 135, 135,
	/* 1150 */ 112, 113, 114, 134, 135, 135, 112, 113, 114, 134,
	/* 1160 */ 135, 135, 135, 135, 103, 135, 134, 135, 135, 135,
	/* 1170 */ 103, 135, 134, 112, 113, 114, 135, 103, 134, 112,
	/* 1180 */ 113, 114, 103, 135, 135, 135, 112, 113, 114, 135,
	/* 1190 */ 135, 112, 113, 114, 103, 134, 135, 135, 135, 135,
	/* 1200 */ 103, 134, 135, 112, 113, 114, 103, 135, 134, 112,
	/* 1210 */ 113, 114, 135, 134, 135, 112, 113, 114, 135, 135,
	/* 1220 */ 135, 135, 135, 103, 135, 134, 135, 135, 135, 135,
	/* 1230 */ 135, 134, 112, 113, 114, 103, 135, 134, 135, 103,
	/* 1240 */ 135, 135, 103, 135, 112, 113, 114, 135, 112, 113,
	/* 1250 */ 114, 112, 113, 114, 134, 4, 5, 6, 7, 4,
	/* 1260 */ 5, 6, 7, 135, 135, 135, 134, 135, 135, 135,
	/* 1270 */ 134, 135, 135, 134, 135, 135, 25, 135, 135, 135,
	/* 1280 */ 25, 4, 5, 6, 7, 135, 135, 135, 135, 135,
	/* 1290 */ 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
	/* 1300 */ 135, 135, 25, 135, 135, 135, 135, 135, 135, 135,
	/* 1310 */ 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
	/* 1320 */ 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
	/* 1330 */ 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
	/* 1340 */ 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
	/* 1350 */ 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
	/* 1360 */ 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
	/* 1370 */ 135, 135, 135, 135, 135, 135, 135, 135, 135, 135,
	/* 1380 */ 135, 99, 99, 99, 99, 99, 99, 99, 99, 99,
	/* 1390 */ 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
	/* 1400 */ 99, 99,
}

const YY_SHIFT_COUNT = 163
const YY_SHIFT_MIN = 0
const YY_SHIFT_MAX = 1277

var yy_shift_ofst = []uint16{
	/* 0 */ 143, 127, 221, 244, 244, 244, 244, 244, 244, 244,
	/* 10 */ 244, 244, 244, 244, 244, 244, 244, 244, 244, 244,
	/* 20 */ 244, 244, 244, 244, 244, 244, 244, 276, 510, 557,
	/* 30 */ 276, 143, 347, 347, 0, 64, 143, 573, 557, 573,
	/* 40 */ 400, 400, 400, 442, 539, 557, 557, 557, 557, 557,
	/* 50 */ 557, 604, 557, 557, 667, 557, 557, 557, 557, 557,
	/* 60 */ 557, 557, 557, 557, 557, 218, 60, 60, 60, 60,
	/* 70 */ 60, 145, 315, 393, 471, 292, 292, 170, 71, 1303,
	/* 80 */ 1303, 1303, 1303, 114, 114, 338, 402, 129, 444, 367,
	/* 90 */ 683, 589, 1251, 669, 1255, 1048, 1277, 1077, 1106, 25,
	/* 100 */ 25, 25, 184, 25, 25, 25, 168, 25, 429, 83,
	/* 110 */ 92, 105, 70, 133, 138, 182, 182, 234, 257, 137,
	/* 120 */ 149, 289, 141, 155, 151, 146, 156, 147, 174, 176,
	/* 130 */ 196, 203, 204, 179, 237, 249, 213, 261, 211, 214,
	/* 140 */ 215, 222, 290, 300, 307, 278, 323, 330, 336, 246,
	/* 150 */ 274, 329, 246, 343, 345, 346, 348, 351, 352, 353,
	/* 160 */ 372, 297, 384, 377,
}

const YY_REDUCE_COUNT = 82
const YY_REDUCE_MIN = -129
const YY_REDUCE_MAX = 1139

var yy_reduce_ofst = []int16{
	/* 0 */ 363, -96, -32, 93, 152, 394, 512, 599, 616, 631,
	/* 10 */ 664, 680, 696, 710, 722, 735, 749, 761, 775, 791,
	/* 20 */ 807, 821, 833, 846, 860, 872, 886, 889, 668, 905,
	/* 30 */ 913, 464, 603, 779, -61, -61, 535, 650, 932, 945,
	/* 40 */ 794, 929, 957, 961, 964, 987, 990, 993, 1006, 1019,
	/* 50 */ 1025, 1032, 1038, 1044, 1061, 1067, 1074, 1079, 1091, 1097,
	/* 60 */ 1103, 1120, 1132, 1136, 1139, -81, -111, -101, -47, -37,
	/* 70 */ -23, -22, -129, -129, -129, -97, -86, -58, -100, -15,
	/* 80 */ 30, 34, 24,
}
var yy_default = []YYACTIONTYPE{
	/* 0 */ 449, 443, 443, 443, 443, 443, 443, 443, 443, 443,
	/* 10 */ 443, 443, 443, 443, 443, 443, 443, 443, 443, 443,
	/* 20 */ 443, 443, 443, 443, 443, 443, 443, 443, 473, 576,
	/* 30 */ 443, 449, 580, 485, 581, 581, 449, 443, 443, 443,
	/* 40 */ 443, 443, 443, 443, 443, 443, 443, 443, 477, 443,
	/* 50 */ 443, 443, 443, 443, 443, 443, 443, 443, 443, 443,
	/* 60 */ 443, 443, 443, 443, 443, 443, 443, 443, 443, 443,
	/* 70 */ 443, 443, 443, 443, 443, 443, 443, 443, 455, 470,
	/* 80 */ 508, 508, 576, 468, 493, 443, 443, 443, 471, 443,
	/* 90 */ 443, 443, 443, 443, 443, 443, 443, 443, 443, 488,
	/* 100 */ 486, 476, 459, 512, 511, 510, 443, 566, 443, 443,
	/* 110 */ 443, 443, 443, 588, 443, 545, 544, 540, 443, 532,
	/* 120 */ 529, 443, 443, 443, 443, 443, 443, 491, 443, 443,
	/* 130 */ 443, 443, 443, 443, 443, 443, 443, 443, 443, 443,
	/* 140 */ 443, 443, 443, 443, 443, 443, 443, 443, 443, 592,
	/* 150 */ 443, 443, 443, 443, 443, 443, 443, 443, 443, 443,
	/* 160 */ 443, 601, 443, 443,
}

/********** End of lemon-generated parsing tables *****************************/

/* The next table maps tokens (terminal symbols) into fallback tokens.
** If a construct like the following:
**
**      %fallback ID X Y Z.
**
** appears in the grammar, then ID becomes a fallback token for X, Y,
** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
** but it does not parse, the type of the token is changed to ID and
** the parse is retried before an error is thrown.
**
** This feature can be used, for example, to cause some keywords in a language
** to revert to identifiers if they keyword does not apply in the context where
** it appears.
 */
var yyFallback = []YYCODETYPE{
	//
	0, /*          $ => nothing */
	0, /*         ID => nothing */
	1, /*     EDGEPT => ID */
	0, /*         OF => nothing */
	0, /*       PLUS => nothing */
	0, /*      MINUS => nothing */
	0, /*       STAR => nothing */
	0, /*      SLASH => nothing */
	0, /*    PERCENT => nothing */
	0, /*     UMINUS => nothing */
	0, /*        EOL => nothing */
	0, /*     ASSIGN => nothing */
	0, /*  PLACENAME => nothing */
	0, /*      COLON => nothing */
	0, /*     ASSERT => nothing */
	0, /*         LP => nothing */
	0, /*         EQ => nothing */
	0, /*         RP => nothing */
	0, /*     DEFINE => nothing */
	0, /*  CODEBLOCK => nothing */
	0, /*       FILL => nothing */
	0, /*      COLOR => nothing */
	0, /*  THICKNESS => nothing */
	0, /*      PRINT => nothing */
	0, /*     STRING => nothing */
	0, /*      COMMA => nothing */
	0, /*  CLASSNAME => nothing */
	0, /*         LB => nothing */
	0, /*         RB => nothing */
	0, /*         UP => nothing */
	0, /*       DOWN => nothing */
	0, /*       LEFT => nothing */
	0, /*      RIGHT => nothing */
	0, /*      CLOSE => nothing */
	0, /*       CHOP => nothing */
	0, /*       FROM => nothing */
	0, /*         TO => nothing */
	0, /*       THEN => nothing */
	0, /*    HEADING => nothing */
	0, /*         GO => nothing */
	0, /*         AT => nothing */
	0, /*       WITH => nothing */
	0, /*       SAME => nothing */
	0, /*         AS => nothing */
	0, /*        FIT => nothing */
	0, /*     BEHIND => nothing */
	0, /*      UNTIL => nothing */
	0, /*       EVEN => nothing */
	0, /*      DOT_E => nothing */
	0, /*     HEIGHT => nothing */
	0, /*      WIDTH => nothing */
	0, /*     RADIUS => nothing */
	0, /*   DIAMETER => nothing */
	0, /*     DOTTED => nothing */
	0, /*     DASHED => nothing */
	0, /*         CW => nothing */
	0, /*        CCW => nothing */
	0, /*     LARROW => nothing */
	0, /*     RARROW => nothing */
	0, /*    LRARROW => nothing */
	0, /*      INVIS => nothing */
	0, /*      THICK => nothing */
	0, /*       THIN => nothing */
	0, /*      SOLID => nothing */
	0, /*     CENTER => nothing */
	0, /*      LJUST => nothing */
	0, /*      RJUST => nothing */
	0, /*      ABOVE => nothing */
	0, /*      BELOW => nothing */
	0, /*     ITALIC => nothing */
	0, /*       BOLD => nothing */
	0, /*    ALIGNED => nothing */
	0, /*        BIG => nothing */
	0, /*      SMALL => nothing */
	0, /*        AND => nothing */
	0, /*         LT => nothing */
	0, /*         GT => nothing */
	0, /*         ON => nothing */
	0, /*        WAY => nothing */
	0, /*    BETWEEN => nothing */
	0, /*        THE => nothing */
	0, /*        NTH => nothing */
	0, /*     VERTEX => nothing */
	0, /*        TOP => nothing */
	0, /*     BOTTOM => nothing */
	0, /*      START => nothing */
	0, /*        END => nothing */
	0, /*         IN => nothing */
	0, /*       THIS => nothing */
	0, /*      DOT_U => nothing */
	0, /*       LAST => nothing */
	0, /*     NUMBER => nothing */
	0, /*      FUNC1 => nothing */
	0, /*      FUNC2 => nothing */
	0, /*       DIST => nothing */
	0, /*     DOT_XY => nothing */
	0, /*          X => nothing */
	0, /*          Y => nothing */
	0, /*      DOT_L => nothing */
}

/* The following structure represents a single element of the
** parser's stack.  Information stored includes:
**
**   +  The state number for the parser at this level of the stack.
**
**   +  The value of the token stored at this level of the stack.
**      (In other words, the "major" token.)
**
**   +  The semantic value stored at this level of the stack.  This is
**      the information used by the action routines in the grammar.
**      It is sometimes called the "minor" token.
**
** After the "shift" half of a SHIFTREDUCE action, the stateno field
** actually contains the reduce action for the second half of the
** SHIFTREDUCE.
 */
type yyStackEntry struct {
	stateno YYACTIONTYPE /* The state-number, or reduce action in SHIFTREDUCE */
	major   YYCODETYPE   /* The major token value.  This is the code
	 ** number for the token at this stack level */
	minor YYMINORTYPE /* The user-supplied minor token value.  This
	 ** is the value of the token  */
}

/* The state of the parser is completely contained in an instance of
** the following structure */
type yyParser struct {
	yytos int /* Index of top element on the stack */
	// #ifdef YYTRACKMAXSTACKDEPTH
	yyhwm int /* High-water mark of the stack */
	// #endif
	// #ifndef YYNOERRORRECOVERY
	yyerrcnt int /* Shifts left before out of the error */
	// #endif
	/* A place to hold %extra_argument */
	p       *Pik /* A place to hold %extra_context */
	yystack []yyStackEntry
}

var yyTraceFILE *os.File
var yyTracePrompt string

/*
** Turn parser tracing on by giving a stream to which to write the trace
** and a prompt to preface each trace message.  Tracing is turned off
** by making either argument NULL
**
** Inputs:
** <ul>
** <li> A FILE* to which trace output should be written.
**      If NULL, then tracing is turned off.
** <li> A prefix string written at the beginning of every
**      line of trace output.  If NULL, then tracing is
**      turned off.
** </ul>
**
** Outputs:
** None.
 */
func pik_parserTrace(TraceFILE *os.File, zTracePrompt string) {
	yyTraceFILE = TraceFILE
	yyTracePrompt = zTracePrompt
	if yyTraceFILE == nil {
		yyTracePrompt = ""
	} else if yyTracePrompt == "" {
		yyTraceFILE = nil
	}
}

/* For tracing shifts, the names of all terminals and nonterminals
** are required.  The following table supplies these names */
var yyTokenName = []string{
	/*    0 */ "$",
	/*    1 */ "ID",
	/*    2 */ "EDGEPT",
	/*    3 */ "OF",
	/*    4 */ "PLUS",
	/*    5 */ "MINUS",
	/*    6 */ "STAR",
	/*    7 */ "SLASH",
	/*    8 */ "PERCENT",
	/*    9 */ "UMINUS",
	/*   10 */ "EOL",
	/*   11 */ "ASSIGN",
	/*   12 */ "PLACENAME",
	/*   13 */ "COLON",
	/*   14 */ "ASSERT",
	/*   15 */ "LP",
	/*   16 */ "EQ",
	/*   17 */ "RP",
	/*   18 */ "DEFINE",
	/*   19 */ "CODEBLOCK",
	/*   20 */ "FILL",
	/*   21 */ "COLOR",
	/*   22 */ "THICKNESS",
	/*   23 */ "PRINT",
	/*   24 */ "STRING",
	/*   25 */ "COMMA",
	/*   26 */ "CLASSNAME",
	/*   27 */ "LB",
	/*   28 */ "RB",
	/*   29 */ "UP",
	/*   30 */ "DOWN",
	/*   31 */ "LEFT",
	/*   32 */ "RIGHT",
	/*   33 */ "CLOSE",
	/*   34 */ "CHOP",
	/*   35 */ "FROM",
	/*   36 */ "TO",
	/*   37 */ "THEN",
	/*   38 */ "HEADING",
	/*   39 */ "GO",
	/*   40 */ "AT",
	/*   41 */ "WITH",
	/*   42 */ "SAME",
	/*   43 */ "AS",
	/*   44 */ "FIT",
	/*   45 */ "BEHIND",
	/*   46 */ "UNTIL",
	/*   47 */ "EVEN",
	/*   48 */ "DOT_E",
	/*   49 */ "HEIGHT",
	/*   50 */ "WIDTH",
	/*   51 */ "RADIUS",
	/*   52 */ "DIAMETER",
	/*   53 */ "DOTTED",
	/*   54 */ "DASHED",
	/*   55 */ "CW",
	/*   56 */ "CCW",
	/*   57 */ "LARROW",
	/*   58 */ "RARROW",
	/*   59 */ "LRARROW",
	/*   60 */ "INVIS",
	/*   61 */ "THICK",
	/*   62 */ "THIN",
	/*   63 */ "SOLID",
	/*   64 */ "CENTER",
	/*   65 */ "LJUST",
	/*   66 */ "RJUST",
	/*   67 */ "ABOVE",
	/*   68 */ "BELOW",
	/*   69 */ "ITALIC",
	/*   70 */ "BOLD",
	/*   71 */ "ALIGNED",
	/*   72 */ "BIG",
	/*   73 */ "SMALL",
	/*   74 */ "AND",
	/*   75 */ "LT",
	/*   76 */ "GT",
	/*   77 */ "ON",
	/*   78 */ "WAY",
	/*   79 */ "BETWEEN",
	/*   80 */ "THE",
	/*   81 */ "NTH",
	/*   82 */ "VERTEX",
	/*   83 */ "TOP",
	/*   84 */ "BOTTOM",
	/*   85 */ "START",
	/*   86 */ "END",
	/*   87 */ "IN",
	/*   88 */ "THIS",
	/*   89 */ "DOT_U",
	/*   90 */ "LAST",
	/*   91 */ "NUMBER",
	/*   92 */ "FUNC1",
	/*   93 */ "FUNC2",
	/*   94 */ "DIST",
	/*   95 */ "DOT_XY",
	/*   96 */ "X",
	/*   97 */ "Y",
	/*   98 */ "DOT_L",
	/*   99 */ "statement_list",
	/*  100 */ "statement",
	/*  101 */ "unnamed_statement",
	/*  102 */ "basetype",
	/*  103 */ "expr",
	/*  104 */ "numproperty",
	/*  105 */ "edge",
	/*  106 */ "direction",
	/*  107 */ "dashproperty",
	/*  108 */ "colorproperty",
	/*  109 */ "locproperty",
	/*  110 */ "position",
	/*  111 */ "place",
	/*  112 */ "object",
	/*  113 */ "objectname",
	/*  114 */ "nth",
	/*  115 */ "textposition",
	/*  116 */ "rvalue",
	/*  117 */ "lvalue",
	/*  118 */ "even",
	/*  119 */ "relexpr",
	/*  120 */ "optrelexpr",
	/*  121 */ "document",
	/*  122 */ "print",
	/*  123 */ "prlist",
	/*  124 */ "pritem",
	/*  125 */ "prsep",
	/*  126 */ "attribute_list",
	/*  127 */ "savelist",
	/*  128 */ "alist",
	/*  129 */ "attribute",
	/*  130 */ "go",
	/*  131 */ "boolproperty",
	/*  132 */ "withclause",
	/*  133 */ "between",
	/*  134 */ "place2",
}

/* For tracing reduce actions, the names of all rules are required.
 */
var yyRuleName = []string{
	/*   0 */ "document ::= statement_list",
	/*   1 */ "statement_list ::= statement",
	/*   2 */ "statement_list ::= statement_list EOL statement",
	/*   3 */ "statement ::=",
	/*   4 */ "statement ::= direction",
	/*   5 */ "statement ::= lvalue ASSIGN rvalue",
	/*   6 */ "statement ::= PLACENAME COLON unnamed_statement",
	/*   7 */ "statement ::= PLACENAME COLON position",
	/*   8 */ "statement ::= unnamed_statement",
	/*   9 */ "statement ::= print prlist",
	/*  10 */ "statement ::= ASSERT LP expr EQ expr RP",
	/*  11 */ "statement ::= ASSERT LP position EQ position RP",
	/*  12 */ "statement ::= DEFINE ID CODEBLOCK",
	/*  13 */ "rvalue ::= PLACENAME",
	/*  14 */ "pritem ::= FILL",
	/*  15 */ "pritem ::= COLOR",
	/*  16 */ "pritem ::= THICKNESS",
	/*  17 */ "pritem ::= rvalue",
	/*  18 */ "pritem ::= STRING",
	/*  19 */ "prsep ::= COMMA",
	/*  20 */ "unnamed_statement ::= basetype attribute_list",
	/*  21 */ "basetype ::= CLASSNAME",
	/*  22 */ "basetype ::= STRING textposition",
	/*  23 */ "basetype ::= LB savelist statement_list RB",
	/*  24 */ "savelist ::=",
	/*  25 */ "relexpr ::= expr",
	/*  26 */ "relexpr ::= expr PERCENT",
	/*  27 */ "optrelexpr ::=",
	/*  28 */ "attribute_list ::= relexpr alist",
	/*  29 */ "attribute ::= numproperty relexpr",
	/*  30 */ "attribute ::= dashproperty expr",
	/*  31 */ "attribute ::= dashproperty",
	/*  32 */ "attribute ::= colorproperty rvalue",
	/*  33 */ "attribute ::= go direction optrelexpr",
	/*  34 */ "attribute ::= go direction even position",
	/*  35 */ "attribute ::= CLOSE",
	/*  36 */ "attribute ::= CHOP",
	/*  37 */ "attribute ::= FROM position",
	/*  38 */ "attribute ::= TO position",
	/*  39 */ "attribute ::= THEN",
	/*  40 */ "attribute ::= THEN optrelexpr HEADING expr",
	/*  41 */ "attribute ::= THEN optrelexpr EDGEPT",
	/*  42 */ "attribute ::= GO optrelexpr HEADING expr",
	/*  43 */ "attribute ::= GO optrelexpr EDGEPT",
	/*  44 */ "attribute ::= AT position",
	/*  45 */ "attribute ::= SAME",
	/*  46 */ "attribute ::= SAME AS object",
	/*  47 */ "attribute ::= STRING textposition",
	/*  48 */ "attribute ::= FIT",
	/*  49 */ "attribute ::= BEHIND object",
	/*  50 */ "withclause ::= DOT_E edge AT position",
	/*  51 */ "withclause ::= edge AT position",
	/*  52 */ "numproperty ::= HEIGHT|WIDTH|RADIUS|DIAMETER|THICKNESS",
	/*  53 */ "boolproperty ::= CW",
	/*  54 */ "boolproperty ::= CCW",
	/*  55 */ "boolproperty ::= LARROW",
	/*  56 */ "boolproperty ::= RARROW",
	/*  57 */ "boolproperty ::= LRARROW",
	/*  58 */ "boolproperty ::= INVIS",
	/*  59 */ "boolproperty ::= THICK",
	/*  60 */ "boolproperty ::= THIN",
	/*  61 */ "boolproperty ::= SOLID",
	/*  62 */ "textposition ::=",
	/*  63 */ "textposition ::= textposition CENTER|LJUST|RJUST|ABOVE|BELOW|ITALIC|BOLD|ALIGNED|BIG|SMALL",
	/*  64 */ "position ::= expr COMMA expr",
	/*  65 */ "position ::= place PLUS expr COMMA expr",
	/*  66 */ "position ::= place MINUS expr COMMA expr",
	/*  67 */ "position ::= place PLUS LP expr COMMA expr RP",
	/*  68 */ "position ::= place MINUS LP expr COMMA expr RP",
	/*  69 */ "position ::= LP position COMMA position RP",
	/*  70 */ "position ::= LP position RP",
	/*  71 */ "position ::= expr between position AND position",
	/*  72 */ "position ::= expr LT position COMMA position GT",
	/*  73 */ "position ::= expr ABOVE position",
	/*  74 */ "position ::= expr BELOW position",
	/*  75 */ "position ::= expr LEFT OF position",
	/*  76 */ "position ::= expr RIGHT OF position",
	/*  77 */ "position ::= expr ON HEADING EDGEPT OF position",
	/*  78 */ "position ::= expr HEADING EDGEPT OF position",
	/*  79 */ "position ::= expr EDGEPT OF position",
	/*  80 */ "position ::= expr ON HEADING expr FROM position",
	/*  81 */ "position ::= expr HEADING expr FROM position",
	/*  82 */ "place ::= edge OF object",
	/*  83 */ "place2 ::= object",
	/*  84 */ "place2 ::= object DOT_E edge",
	/*  85 */ "place2 ::= NTH VERTEX OF object",
	/*  86 */ "object ::= nth",
	/*  87 */ "object ::= nth OF|IN object",
	/*  88 */ "objectname ::= THIS",
	/*  89 */ "objectname ::= PLACENAME",
	/*  90 */ "objectname ::= objectname DOT_U PLACENAME",
	/*  91 */ "nth ::= NTH CLASSNAME",
	/*  92 */ "nth ::= NTH LAST CLASSNAME",
	/*  93 */ "nth ::= LAST CLASSNAME",
	/*  94 */ "nth ::= LAST",
	/*  95 */ "nth ::= NTH LB RB",
	/*  96 */ "nth ::= NTH LAST LB RB",
	/*  97 */ "nth ::= LAST LB RB",
	/*  98 */ "expr ::= expr PLUS expr",
	/*  99 */ "expr ::= expr MINUS expr",
	/* 100 */ "expr ::= expr STAR expr",
	/* 101 */ "expr ::= expr SLASH expr",
	/* 102 */ "expr ::= MINUS expr",
	/* 103 */ "expr ::= PLUS expr",
	/* 104 */ "expr ::= LP expr RP",
	/* 105 */ "expr ::= LP FILL|COLOR|THICKNESS RP",
	/* 106 */ "expr ::= NUMBER",
	/* 107 */ "expr ::= ID",
	/* 108 */ "expr ::= FUNC1 LP expr RP",
	/* 109 */ "expr ::= FUNC2 LP expr COMMA expr RP",
	/* 110 */ "expr ::= DIST LP position COMMA position RP",
	/* 111 */ "expr ::= place2 DOT_XY X",
	/* 112 */ "expr ::= place2 DOT_XY Y",
	/* 113 */ "expr ::= object DOT_L numproperty",
	/* 114 */ "expr ::= object DOT_L dashproperty",
	/* 115 */ "expr ::= object DOT_L colorproperty",
	/* 116 */ "lvalue ::= ID",
	/* 117 */ "lvalue ::= FILL",
	/* 118 */ "lvalue ::= COLOR",
	/* 119 */ "lvalue ::= THICKNESS",
	/* 120 */ "rvalue ::= expr",
	/* 121 */ "print ::= PRINT",
	/* 122 */ "prlist ::= pritem",
	/* 123 */ "prlist ::= prlist prsep pritem",
	/* 124 */ "direction ::= UP",
	/* 125 */ "direction ::= DOWN",
	/* 126 */ "direction ::= LEFT",
	/* 127 */ "direction ::= RIGHT",
	/* 128 */ "optrelexpr ::= relexpr",
	/* 129 */ "attribute_list ::= alist",
	/* 130 */ "alist ::=",
	/* 131 */ "alist ::= alist attribute",
	/* 132 */ "attribute ::= boolproperty",
	/* 133 */ "attribute ::= WITH withclause",
	/* 134 */ "go ::= GO",
	/* 135 */ "go ::=",
	/* 136 */ "even ::= UNTIL EVEN WITH",
	/* 137 */ "even ::= EVEN WITH",
	/* 138 */ "dashproperty ::= DOTTED",
	/* 139 */ "dashproperty ::= DASHED",
	/* 140 */ "colorproperty ::= FILL",
	/* 141 */ "colorproperty ::= COLOR",
	/* 142 */ "position ::= place",
	/* 143 */ "between ::= WAY BETWEEN",
	/* 144 */ "between ::= BETWEEN",
	/* 145 */ "between ::= OF THE WAY BETWEEN",
	/* 146 */ "place ::= place2",
	/* 147 */ "edge ::= CENTER",
	/* 148 */ "edge ::= EDGEPT",
	/* 149 */ "edge ::= TOP",
	/* 150 */ "edge ::= BOTTOM",
	/* 151 */ "edge ::= START",
	/* 152 */ "edge ::= END",
	/* 153 */ "edge ::= RIGHT",
	/* 154 */ "edge ::= LEFT",
	/* 155 */ "object ::= objectname",
}

/*
** Try to increase the size of the parser stack.  Return the number
** of errors.  Return 0 on success.
 */
func (p *yyParser) yyGrowStack() {
	oldSize := len(p.yystack)
	newSize := oldSize*2 + 100
	pNew := make([]yyStackEntry, newSize)
	copy(pNew, p.yystack)
	p.yystack = pNew

	if !NDEBUG { // #ifndef NDEBUG
		if yyTraceFILE != nil {
			fmt.Fprintf(yyTraceFILE, "%sStack grows from %d to %d entries.\n",
				yyTracePrompt, oldSize, newSize)
		}
	} // #endif
}

/* Datatype of the argument to the memory allocated passed as the
** second argument to pik_parserAlloc() below.  This can be changed by
** putting an appropriate #define in the %include section of the input
** grammar.
 */
// #ifndef YYMALLOCARGTYPE
// # define YYMALLOCARGTYPE size_t
// #endif

/* Initialize a new parser that has already been allocated.
 */
func (yypParser *yyParser) pik_parserInit(p *Pik) {
	yypParser.p = p

	if !YYNOERRORRECOVERY {
		yypParser.yyerrcnt = -1
	}
	if YYSTACKDEPTH > 0 {
		yypParser.yystack = make([]yyStackEntry, YYSTACKDEPTH)
	} else {
		yypParser.yystack = []yyStackEntry{{}}
	}
	yypParser.yytos = 0
}

/*
** This function allocates a new parser.
** The only argument is a pointer to a function which works like
** malloc.
**
** Inputs:
** A pointer to the function used to allocate memory.
**
** Outputs:
** A pointer to a parser.  This pointer is used in subsequent calls
** to pik_parser and pik_parserFree.
 */
func pik_parserAlloc(p *Pik) *yyParser {
	yypParser := &yyParser{}
	yypParser.p = p

	yypParser.pik_parserInit(p)
	return yypParser
}

/* The following function deletes the "minor type" or semantic value
** associated with a symbol.  The symbol can be either a terminal
** or nonterminal. "yymajor" is the symbol code, and "yypminor" is
** a pointer to the value to be deleted.  The code used to do the
** deletions is derived from the %destructor and/or %token_destructor
** directives of the input grammar.
 */
func (yypParser *yyParser) yy_destructor(
	yymajor YYCODETYPE, /* Type code for object to destroy */
	yypminor *YYMINORTYPE, /* The object to be destroyed */
) {

	p := yypParser.p
	_ = p

	switch yymajor {
	/* Here is inserted the actions which take place when a
	 ** terminal or non-terminal is destroyed.  This can happen
	 ** when the symbol is popped from the stack during a
	 ** reduce or during error processing or when a parser is
	 ** being destroyed before it is finished parsing.
	 **
	 ** Note: during a reduce, the only symbols destroyed are those
	 ** which appear on the RHS of the rule, but which are *not* used
	 ** inside the C code.
	 */
	/********* Begin destructor definitions ***************************************/
	case 99: /* statement_list */
		{
//line 453 "pikchr.y"
			p.pik_elist_free(&(yypminor.yy186))
//line 1649 "pikchr.go"
		}
		break
	case 100: /* statement */
	case 101: /* unnamed_statement */
	case 102: /* basetype */
		{
//line 455 "pikchr.y"
			p.pik_elem_free((yypminor.yy104))
//line 1658 "pikchr.go"
		}
		break
	/********* End destructor definitions *****************************************/
	default:
		break /* If no destructor action specified: do nothing */
	}
}

/*
** Pop the parser's stack once.
**
** If there is a destructor routine associated with the token which
** is popped from the stack, then call it.
 */
func (pParser *yyParser) yy_pop_parser_stack() {
	assert(pParser.yytos > 0, "pParser.yytos>0")
	yytos := pParser.yystack[pParser.yytos]
	pParser.yytos--
	if !NDEBUG {
		if yyTraceFILE != nil {
			fmt.Fprintf(yyTraceFILE, "%sPopping %s\n",
				yyTracePrompt,
				yyTokenName[yytos.major])
		}
	}
	pParser.yy_destructor(yytos.major, &yytos.minor)
}

/*
** Clear all secondary memory allocations from the parser
 */
func (pParser *yyParser) pik_parserFinalize() {
	for pParser.yytos > 0 {
		pParser.yy_pop_parser_stack()
	}
}

/*
** Deallocate and destroy a parser.  Destructors are called for
** all stack elements before shutting the parser down.
**
** If the YYPARSEFREENEVERNULL macro exists (for example because it
** is defined in a %include section of the input grammar) then it is
** assumed that the input pointer is never NULL.
 */
func (pParser *yyParser) pik_parserFree() {
	pParser.pik_parserFinalize()
}

/*
** Return the peak depth of the stack for a parser.
 */
func (pParser *yyParser) pik_parserStackPeak() int {
	return pParser.yyhwm
}

/* This array of booleans keeps track of the parser statement
** coverage.  The element yycoverage[X][Y] is set when the parser
** is in state X and has a lookahead token Y.  In a well-tested
** systems, every element of this matrix should end up being set.
 */
var yycoverage = [YYNSTATE][YYNTOKEN]bool{}

/*
** Write into out a description of every state/lookahead combination that
**
**   (1)  has not been used by the parser, and
**   (2)  is not a syntax error.
**
** Return the number of missed state/lookahead combinations.
 */
func pik_parserCoverage(out io.Writer) int {
	nMissed := 0
	for stateno := 0; stateno < YYNSTATE; stateno++ {
		i := yy_shift_ofst[stateno]
		for iLookAhead := 0; iLookAhead < YYNTOKEN; iLookAhead++ {
			if yy_lookahead[int(i)+iLookAhead] != YYCODETYPE(iLookAhead) {
				continue
			}
			if !yycoverage[stateno][iLookAhead] {
				nMissed++
			}
			if out != nil {
				ok := "missed"
				if yycoverage[stateno][iLookAhead] {
					ok = "ok"
				}
				fmt.Fprintf(out, "State %d lookahead %s %s\n", stateno,
					yyTokenName[iLookAhead],
					ok)
			}
		}
	}
	return nMissed
}

/*
** Find the appropriate action for a parser given the terminal
** look-ahead token iLookAhead.
 */
func yy_find_shift_action(
	lookAhead YYCODETYPE, /* The look-ahead token */
	stateno YYACTIONTYPE, /* Current state number */
) YYACTIONTYPE {
	iLookAhead := int(lookAhead)

	if stateno > YY_MAX_SHIFT {
		return stateno
	}
	assert(stateno <= YY_SHIFT_COUNT, "stateno <= YY_SHIFT_COUNT")
	if YYCOVERAGE {
		yycoverage[stateno][iLookAhead] = true
	}
	for {
		i := int(yy_shift_ofst[stateno])
		assert(i >= 0, "i>=0")
		assert(i <= YY_ACTTAB_COUNT, "i<=YY_ACTTAB_COUNT")
		assert(i+YYNTOKEN <= len(yy_lookahead), "i+YYNTOKEN<=len(yy_lookahead)")
		assert(iLookAhead != YYNOCODE, "iLookAhead!=YYNOCODE")
		assert(iLookAhead < YYNTOKEN, "iLookAhead < YYNTOKEN")
		i += iLookAhead
		assert(i < len(yy_lookahead), "i<len(yy_lookahead)")
		if int(yy_lookahead[i]) != iLookAhead {
			if YYFALLBACK {
				assert(iLookAhead < len(yyFallback), "iLookAhead<len(yyfallback)")
				iFallback := int(yyFallback[iLookAhead])
				if iFallback != 0 {
					if !NDEBUG {
						if yyTraceFILE != nil {
							fmt.Fprintf(yyTraceFILE, "%sFALLBACK %s => %s\n",
								yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback])
						}
					}
					assert(yyFallback[iFallback] == 0, "yyFallback[iFallback]==0") /* Fallback loop must terminate */
					iLookAhead = iFallback
					continue
				}
			}
			if YYWILDCARD > 0 {
				{
					j := i - iLookAhead + YYWILDCARD
					assert(j < len(yy_lookahead), "j < len(yy_lookahead)")
					if int(yy_lookahead[j]) == YYWILDCARD && iLookAhead > 0 {
						if !NDEBUG {
							if yyTraceFILE != nil {
								fmt.Fprintf(yyTraceFILE, "%sWILDCARD %s => %s\n",
									yyTracePrompt, yyTokenName[iLookAhead],
									yyTokenName[YYWILDCARD])
							}
						} /* NDEBUG */
						return yy_action[j]
					}
				}
			} /* YYWILDCARD */
			return yy_default[stateno]
		} else {
			assert(i >= 0 && i < len(yy_action), "i >= 0 && i < len(yy_action)")
			return yy_action[i]
		}
	}
}

/*
** Find the appropriate action for a parser given the non-terminal
** look-ahead token iLookAhead.
 */
func yy_find_reduce_action(
	stateno YYACTIONTYPE, /* Current state number */
	lookAhead YYCODETYPE, /* The look-ahead token */
) YYACTIONTYPE {
	iLookAhead := int(lookAhead)
	if YYERRORSYMBOL > 0 {
		if stateno > YY_REDUCE_COUNT {
			return yy_default[stateno]
		}
	} else {
		assert(stateno <= YY_REDUCE_COUNT, "stateno <= YY_REDUCE_COUNT")
	}
	i := int(yy_reduce_ofst[stateno])
	assert(iLookAhead != YYNOCODE, "iLookAhead != YYNOCODE")
	i += iLookAhead
	if YYERRORSYMBOL > 0 {
		if i < 0 || i >= YY_ACTTAB_COUNT || int(yy_lookahead[i]) != iLookAhead {
			return yy_default[stateno]
		}
	} else {
		assert(i >= 0 && i < YY_ACTTAB_COUNT, "i >= 0 && i < YY_ACTTAB_COUNT")
		assert(int(yy_lookahead[i]) == iLookAhead, "int(yy_lookahead[i]) == iLookAhead")
	}
	return yy_action[i]
}

/*
** The following routine is called if the stack overflows.
 */
func (yypParser *yyParser) yyStackOverflow() {

	p := yypParser.p
	_ = p

	if !NDEBUG {
		if yyTraceFILE != nil {
			fmt.Fprintf(yyTraceFILE, "%sStack Overflow!\n", yyTracePrompt)
		}
	}
	for yypParser.yytos > 0 {
		yypParser.yy_pop_parser_stack()
	}
	/* Here code is inserted which will execute if the parser
	 ** stack every overflows */
	/******** Begin %stack_overflow code ******************************************/
//line 486 "pikchr.y"

	p.pik_error(nil, "parser stack overflow")
//line 1872 "pikchr.go"
	/******** End %stack_overflow code ********************************************/
	/* Suppress warning about unused %extra_argument var */
	yypParser.p = p

}

/*
** Print tracing information for a SHIFT action
 */
func (yypParser *yyParser) yyTraceShift(yyNewState int, zTag string) {
	if !NDEBUG {
		if yyTraceFILE != nil {
			if yyNewState < YYNSTATE {
				fmt.Fprintf(yyTraceFILE, "%s%s '%s', go to state %d\n",
					yyTracePrompt, zTag, yyTokenName[yypParser.yystack[yypParser.yytos].major],
					yyNewState)
			} else {
				fmt.Fprintf(yyTraceFILE, "%s%s '%s', pending reduce %d\n",
					yyTracePrompt, zTag, yyTokenName[yypParser.yystack[yypParser.yytos].major],
					yyNewState-YY_MIN_REDUCE)
			}
		}
	}
}

/*
** Perform a shift action.
 */
func (yypParser *yyParser) yy_shift(
	yyNewState YYACTIONTYPE, /* The new state to shift in */
	yyMajor YYCODETYPE, /* The major token to shift in */
	yyMinor pik_parserTOKENTYPE, /* The minor token to shift in */
) {
	yypParser.yytos++

	if YYTRACKMAXSTACKDEPTH {
		if yypParser.yytos > yypParser.yyhwm {
			yypParser.yyhwm++
			assert(yypParser.yyhwm == yypParser.yytos, "yypParser.yyhwm == yypParser.yytos")
		}
	}
	if YYSTACKDEPTH > 0 {
		if yypParser.yytos >= YYSTACKDEPTH {
			yypParser.yyStackOverflow()
			return
		}
	} else {
		if yypParser.yytos+1 >= len(yypParser.yystack) {
			yypParser.yyGrowStack()
		}
	}

	if yyNewState > YY_MAX_SHIFT {
		yyNewState += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE
	}

	yytos := &yypParser.yystack[yypParser.yytos]
	yytos.stateno = yyNewState
	yytos.major = yyMajor
	yytos.minor.yy0 = yyMinor

	yypParser.yyTraceShift(int(yyNewState), "Shift")
}

/* For rule J, yyRuleInfoLhs[J] contains the symbol on the left-hand side
** of that rule */
var yyRuleInfoLhs = []YYCODETYPE{
	121, /* (0) document ::= statement_list */
	99,  /* (1) statement_list ::= statement */
	99,  /* (2) statement_list ::= statement_list EOL statement */
	100, /* (3) statement ::= */
	100, /* (4) statement ::= direction */
	100, /* (5) statement ::= lvalue ASSIGN rvalue */
	100, /* (6) statement ::= PLACENAME COLON unnamed_statement */
	100, /* (7) statement ::= PLACENAME COLON position */
	100, /* (8) statement ::= unnamed_statement */
	100, /* (9) statement ::= print prlist */
	100, /* (10) statement ::= ASSERT LP expr EQ expr RP */
	100, /* (11) statement ::= ASSERT LP position EQ position RP */
	100, /* (12) statement ::= DEFINE ID CODEBLOCK */
	116, /* (13) rvalue ::= PLACENAME */
	124, /* (14) pritem ::= FILL */
	124, /* (15) pritem ::= COLOR */
	124, /* (16) pritem ::= THICKNESS */
	124, /* (17) pritem ::= rvalue */
	124, /* (18) pritem ::= STRING */
	125, /* (19) prsep ::= COMMA */
	101, /* (20) unnamed_statement ::= basetype attribute_list */
	102, /* (21) basetype ::= CLASSNAME */
	102, /* (22) basetype ::= STRING textposition */
	102, /* (23) basetype ::= LB savelist statement_list RB */
	127, /* (24) savelist ::= */
	119, /* (25) relexpr ::= expr */
	119, /* (26) relexpr ::= expr PERCENT */
	120, /* (27) optrelexpr ::= */
	126, /* (28) attribute_list ::= relexpr alist */
	129, /* (29) attribute ::= numproperty relexpr */
	129, /* (30) attribute ::= dashproperty expr */
	129, /* (31) attribute ::= dashproperty */
	129, /* (32) attribute ::= colorproperty rvalue */
	129, /* (33) attribute ::= go direction optrelexpr */
	129, /* (34) attribute ::= go direction even position */
	129, /* (35) attribute ::= CLOSE */
	129, /* (36) attribute ::= CHOP */
	129, /* (37) attribute ::= FROM position */
	129, /* (38) attribute ::= TO position */
	129, /* (39) attribute ::= THEN */
	129, /* (40) attribute ::= THEN optrelexpr HEADING expr */
	129, /* (41) attribute ::= THEN optrelexpr EDGEPT */
	129, /* (42) attribute ::= GO optrelexpr HEADING expr */
	129, /* (43) attribute ::= GO optrelexpr EDGEPT */
	129, /* (44) attribute ::= AT position */
	129, /* (45) attribute ::= SAME */
	129, /* (46) attribute ::= SAME AS object */
	129, /* (47) attribute ::= STRING textposition */
	129, /* (48) attribute ::= FIT */
	129, /* (49) attribute ::= BEHIND object */
	132, /* (50) withclause ::= DOT_E edge AT position */
	132, /* (51) withclause ::= edge AT position */
	104, /* (52) numproperty ::= HEIGHT|WIDTH|RADIUS|DIAMETER|THICKNESS */
	131, /* (53) boolproperty ::= CW */
	131, /* (54) boolproperty ::= CCW */
	131, /* (55) boolproperty ::= LARROW */
	131, /* (56) boolproperty ::= RARROW */
	131, /* (57) boolproperty ::= LRARROW */
	131, /* (58) boolproperty ::= INVIS */
	131, /* (59) boolproperty ::= THICK */
	131, /* (60) boolproperty ::= THIN */
	131, /* (61) boolproperty ::= SOLID */
	115, /* (62) textposition ::= */
	115, /* (63) textposition ::= textposition CENTER|LJUST|RJUST|ABOVE|BELOW|ITALIC|BOLD|ALIGNED|BIG|SMALL */
	110, /* (64) position ::= expr COMMA expr */
	110, /* (65) position ::= place PLUS expr COMMA expr */
	110, /* (66) position ::= place MINUS expr COMMA expr */
	110, /* (67) position ::= place PLUS LP expr COMMA expr RP */
	110, /* (68) position ::= place MINUS LP expr COMMA expr RP */
	110, /* (69) position ::= LP position COMMA position RP */
	110, /* (70) position ::= LP position RP */
	110, /* (71) position ::= expr between position AND position */
	110, /* (72) position ::= expr LT position COMMA position GT */
	110, /* (73) position ::= expr ABOVE position */
	110, /* (74) position ::= expr BELOW position */
	110, /* (75) position ::= expr LEFT OF position */
	110, /* (76) position ::= expr RIGHT OF position */
	110, /* (77) position ::= expr ON HEADING EDGEPT OF position */
	110, /* (78) position ::= expr HEADING EDGEPT OF position */
	110, /* (79) position ::= expr EDGEPT OF position */
	110, /* (80) position ::= expr ON HEADING expr FROM position */
	110, /* (81) position ::= expr HEADING expr FROM position */
	111, /* (82) place ::= edge OF object */
	134, /* (83) place2 ::= object */
	134, /* (84) place2 ::= object DOT_E edge */
	134, /* (85) place2 ::= NTH VERTEX OF object */
	112, /* (86) object ::= nth */
	112, /* (87) object ::= nth OF|IN object */
	113, /* (88) objectname ::= THIS */
	113, /* (89) objectname ::= PLACENAME */
	113, /* (90) objectname ::= objectname DOT_U PLACENAME */
	114, /* (91) nth ::= NTH CLASSNAME */
	114, /* (92) nth ::= NTH LAST CLASSNAME */
	114, /* (93) nth ::= LAST CLASSNAME */
	114, /* (94) nth ::= LAST */
	114, /* (95) nth ::= NTH LB RB */
	114, /* (96) nth ::= NTH LAST LB RB */
	114, /* (97) nth ::= LAST LB RB */
	103, /* (98) expr ::= expr PLUS expr */
	103, /* (99) expr ::= expr MINUS expr */
	103, /* (100) expr ::= expr STAR expr */
	103, /* (101) expr ::= expr SLASH expr */
	103, /* (102) expr ::= MINUS expr */
	103, /* (103) expr ::= PLUS expr */
	103, /* (104) expr ::= LP expr RP */
	103, /* (105) expr ::= LP FILL|COLOR|THICKNESS RP */
	103, /* (106) expr ::= NUMBER */
	103, /* (107) expr ::= ID */
	103, /* (108) expr ::= FUNC1 LP expr RP */
	103, /* (109) expr ::= FUNC2 LP expr COMMA expr RP */
	103, /* (110) expr ::= DIST LP position COMMA position RP */
	103, /* (111) expr ::= place2 DOT_XY X */
	103, /* (112) expr ::= place2 DOT_XY Y */
	103, /* (113) expr ::= object DOT_L numproperty */
	103, /* (114) expr ::= object DOT_L dashproperty */
	103, /* (115) expr ::= object DOT_L colorproperty */
	117, /* (116) lvalue ::= ID */
	117, /* (117) lvalue ::= FILL */
	117, /* (118) lvalue ::= COLOR */
	117, /* (119) lvalue ::= THICKNESS */
	116, /* (120) rvalue ::= expr */
	122, /* (121) print ::= PRINT */
	123, /* (122) prlist ::= pritem */
	123, /* (123) prlist ::= prlist prsep pritem */
	106, /* (124) direction ::= UP */
	106, /* (125) direction ::= DOWN */
	106, /* (126) direction ::= LEFT */
	106, /* (127) direction ::= RIGHT */
	120, /* (128) optrelexpr ::= relexpr */
	126, /* (129) attribute_list ::= alist */
	128, /* (130) alist ::= */
	128, /* (131) alist ::= alist attribute */
	129, /* (132) attribute ::= boolproperty */
	129, /* (133) attribute ::= WITH withclause */
	130, /* (134) go ::= GO */
	130, /* (135) go ::= */
	118, /* (136) even ::= UNTIL EVEN WITH */
	118, /* (137) even ::= EVEN WITH */
	107, /* (138) dashproperty ::= DOTTED */
	107, /* (139) dashproperty ::= DASHED */
	108, /* (140) colorproperty ::= FILL */
	108, /* (141) colorproperty ::= COLOR */
	110, /* (142) position ::= place */
	133, /* (143) between ::= WAY BETWEEN */
	133, /* (144) between ::= BETWEEN */
	133, /* (145) between ::= OF THE WAY BETWEEN */
	111, /* (146) place ::= place2 */
	105, /* (147) edge ::= CENTER */
	105, /* (148) edge ::= EDGEPT */
	105, /* (149) edge ::= TOP */
	105, /* (150) edge ::= BOTTOM */
	105, /* (151) edge ::= START */
	105, /* (152) edge ::= END */
	105, /* (153) edge ::= RIGHT */
	105, /* (154) edge ::= LEFT */
	112, /* (155) object ::= objectname */
}

/* For rule J, yyRuleInfoNRhs[J] contains the negative of the number
** of symbols on the right-hand side of that rule. */
var yyRuleInfoNRhs = []int8{
	-1, /* (0) document ::= statement_list */
	-1, /* (1) statement_list ::= statement */
	-3, /* (2) statement_list ::= statement_list EOL statement */
	0,  /* (3) statement ::= */
	-1, /* (4) statement ::= direction */
	-3, /* (5) statement ::= lvalue ASSIGN rvalue */
	-3, /* (6) statement ::= PLACENAME COLON unnamed_statement */
	-3, /* (7) statement ::= PLACENAME COLON position */
	-1, /* (8) statement ::= unnamed_statement */
	-2, /* (9) statement ::= print prlist */
	-6, /* (10) statement ::= ASSERT LP expr EQ expr RP */
	-6, /* (11) statement ::= ASSERT LP position EQ position RP */
	-3, /* (12) statement ::= DEFINE ID CODEBLOCK */
	-1, /* (13) rvalue ::= PLACENAME */
	-1, /* (14) pritem ::= FILL */
	-1, /* (15) pritem ::= COLOR */
	-1, /* (16) pritem ::= THICKNESS */
	-1, /* (17) pritem ::= rvalue */
	-1, /* (18) pritem ::= STRING */
	-1, /* (19) prsep ::= COMMA */
	-2, /* (20) unnamed_statement ::= basetype attribute_list */
	-1, /* (21) basetype ::= CLASSNAME */
	-2, /* (22) basetype ::= STRING textposition */
	-4, /* (23) basetype ::= LB savelist statement_list RB */
	0,  /* (24) savelist ::= */
	-1, /* (25) relexpr ::= expr */
	-2, /* (26) relexpr ::= expr PERCENT */
	0,  /* (27) optrelexpr ::= */
	-2, /* (28) attribute_list ::= relexpr alist */
	-2, /* (29) attribute ::= numproperty relexpr */
	-2, /* (30) attribute ::= dashproperty expr */
	-1, /* (31) attribute ::= dashproperty */
	-2, /* (32) attribute ::= colorproperty rvalue */
	-3, /* (33) attribute ::= go direction optrelexpr */
	-4, /* (34) attribute ::= go direction even position */
	-1, /* (35) attribute ::= CLOSE */
	-1, /* (36) attribute ::= CHOP */
	-2, /* (37) attribute ::= FROM position */
	-2, /* (38) attribute ::= TO position */
	-1, /* (39) attribute ::= THEN */
	-4, /* (40) attribute ::= THEN optrelexpr HEADING expr */
	-3, /* (41) attribute ::= THEN optrelexpr EDGEPT */
	-4, /* (42) attribute ::= GO optrelexpr HEADING expr */
	-3, /* (43) attribute ::= GO optrelexpr EDGEPT */
	-2, /* (44) attribute ::= AT position */
	-1, /* (45) attribute ::= SAME */
	-3, /* (46) attribute ::= SAME AS object */
	-2, /* (47) attribute ::= STRING textposition */
	-1, /* (48) attribute ::= FIT */
	-2, /* (49) attribute ::= BEHIND object */
	-4, /* (50) withclause ::= DOT_E edge AT position */
	-3, /* (51) withclause ::= edge AT position */
	-1, /* (52) numproperty ::= HEIGHT|WIDTH|RADIUS|DIAMETER|THICKNESS */
	-1, /* (53) boolproperty ::= CW */
	-1, /* (54) boolproperty ::= CCW */
	-1, /* (55) boolproperty ::= LARROW */
	-1, /* (56) boolproperty ::= RARROW */
	-1, /* (57) boolproperty ::= LRARROW */
	-1, /* (58) boolproperty ::= INVIS */
	-1, /* (59) boolproperty ::= THICK */
	-1, /* (60) boolproperty ::= THIN */
	-1, /* (61) boolproperty ::= SOLID */
	0,  /* (62) textposition ::= */
	-2, /* (63) textposition ::= textposition CENTER|LJUST|RJUST|ABOVE|BELOW|ITALIC|BOLD|ALIGNED|BIG|SMALL */
	-3, /* (64) position ::= expr COMMA expr */
	-5, /* (65) position ::= place PLUS expr COMMA expr */
	-5, /* (66) position ::= place MINUS expr COMMA expr */
	-7, /* (67) position ::= place PLUS LP expr COMMA expr RP */
	-7, /* (68) position ::= place MINUS LP expr COMMA expr RP */
	-5, /* (69) position ::= LP position COMMA position RP */
	-3, /* (70) position ::= LP position RP */
	-5, /* (71) position ::= expr between position AND position */
	-6, /* (72) position ::= expr LT position COMMA position GT */
	-3, /* (73) position ::= expr ABOVE position */
	-3, /* (74) position ::= expr BELOW position */
	-4, /* (75) position ::= expr LEFT OF position */
	-4, /* (76) position ::= expr RIGHT OF position */
	-6, /* (77) position ::= expr ON HEADING EDGEPT OF position */
	-5, /* (78) position ::= expr HEADING EDGEPT OF position */
	-4, /* (79) position ::= expr EDGEPT OF position */
	-6, /* (80) position ::= expr ON HEADING expr FROM position */
	-5, /* (81) position ::= expr HEADING expr FROM position */
	-3, /* (82) place ::= edge OF object */
	-1, /* (83) place2 ::= object */
	-3, /* (84) place2 ::= object DOT_E edge */
	-4, /* (85) place2 ::= NTH VERTEX OF object */
	-1, /* (86) object ::= nth */
	-3, /* (87) object ::= nth OF|IN object */
	-1, /* (88) objectname ::= THIS */
	-1, /* (89) objectname ::= PLACENAME */
	-3, /* (90) objectname ::= objectname DOT_U PLACENAME */
	-2, /* (91) nth ::= NTH CLASSNAME */
	-3, /* (92) nth ::= NTH LAST CLASSNAME */
	-2, /* (93) nth ::= LAST CLASSNAME */
	-1, /* (94) nth ::= LAST */
	-3, /* (95) nth ::= NTH LB RB */
	-4, /* (96) nth ::= NTH LAST LB RB */
	-3, /* (97) nth ::= LAST LB RB */
	-3, /* (98) expr ::= expr PLUS expr */
	-3, /* (99) expr ::= expr MINUS expr */
	-3, /* (100) expr ::= expr STAR expr */
	-3, /* (101) expr ::= expr SLASH expr */
	-2, /* (102) expr ::= MINUS expr */
	-2, /* (103) expr ::= PLUS expr */
	-3, /* (104) expr ::= LP expr RP */
	-3, /* (105) expr ::= LP FILL|COLOR|THICKNESS RP */
	-1, /* (106) expr ::= NUMBER */
	-1, /* (107) expr ::= ID */
	-4, /* (108) expr ::= FUNC1 LP expr RP */
	-6, /* (109) expr ::= FUNC2 LP expr COMMA expr RP */
	-6, /* (110) expr ::= DIST LP position COMMA position RP */
	-3, /* (111) expr ::= place2 DOT_XY X */
	-3, /* (112) expr ::= place2 DOT_XY Y */
	-3, /* (113) expr ::= object DOT_L numproperty */
	-3, /* (114) expr ::= object DOT_L dashproperty */
	-3, /* (115) expr ::= object DOT_L colorproperty */
	-1, /* (116) lvalue ::= ID */
	-1, /* (117) lvalue ::= FILL */
	-1, /* (118) lvalue ::= COLOR */
	-1, /* (119) lvalue ::= THICKNESS */
	-1, /* (120) rvalue ::= expr */
	-1, /* (121) print ::= PRINT */
	-1, /* (122) prlist ::= pritem */
	-3, /* (123) prlist ::= prlist prsep pritem */
	-1, /* (124) direction ::= UP */
	-1, /* (125) direction ::= DOWN */
	-1, /* (126) direction ::= LEFT */
	-1, /* (127) direction ::= RIGHT */
	-1, /* (128) optrelexpr ::= relexpr */
	-1, /* (129) attribute_list ::= alist */
	0,  /* (130) alist ::= */
	-2, /* (131) alist ::= alist attribute */
	-1, /* (132) attribute ::= boolproperty */
	-2, /* (133) attribute ::= WITH withclause */
	-1, /* (134) go ::= GO */
	0,  /* (135) go ::= */
	-3, /* (136) even ::= UNTIL EVEN WITH */
	-2, /* (137) even ::= EVEN WITH */
	-1, /* (138) dashproperty ::= DOTTED */
	-1, /* (139) dashproperty ::= DASHED */
	-1, /* (140) colorproperty ::= FILL */
	-1, /* (141) colorproperty ::= COLOR */
	-1, /* (142) position ::= place */
	-2, /* (143) between ::= WAY BETWEEN */
	-1, /* (144) between ::= BETWEEN */
	-4, /* (145) between ::= OF THE WAY BETWEEN */
	-1, /* (146) place ::= place2 */
	-1, /* (147) edge ::= CENTER */
	-1, /* (148) edge ::= EDGEPT */
	-1, /* (149) edge ::= TOP */
	-1, /* (150) edge ::= BOTTOM */
	-1, /* (151) edge ::= START */
	-1, /* (152) edge ::= END */
	-1, /* (153) edge ::= RIGHT */
	-1, /* (154) edge ::= LEFT */
	-1, /* (155) object ::= objectname */
}

/*
** Perform a reduce action and the shift that must immediately
** follow the reduce.
**
** The yyLookahead and yyLookaheadToken parameters provide reduce actions
** access to the lookahead token (if any).  The yyLookahead will be YYNOCODE
** if the lookahead token has already been consumed.  As this procedure is
** only called from one place, optimizing compilers will in-line it, which
** means that the extra parameters have no performance impact.
 */
func (yypParser *yyParser) yy_reduce(
	yyruleno YYACTIONTYPE, /* Number of the rule by which to reduce */
	yyLookahead YYCODETYPE, /* Lookahead token, or YYNOCODE if none */
	yyLookaheadToken pik_parserTOKENTYPE, /* Value of the lookahead token */
	p *Pik /* %extra_context */) YYACTIONTYPE {
	var (
		yygoto     YYCODETYPE   /* The next state */
		yyact      YYACTIONTYPE /* The next action */
		yymsp      int          /* The top of the parser's stack */
		yysize     int          /* Amount to pop the stack */
		yylhsminor YYMINORTYPE
	)
	yymsp = yypParser.yytos
	_ = yylhsminor

	switch yyruleno {
	/* Beginning here are the reduction cases.  A typical example
	 ** follows:
	 **   case 0:
	 **  #line <lineno> <grammarfile>
	 **     { ... }           // User supplied code
	 **  #line <lineno> <thisfile>
	 **     break;
	 */
	/********** Begin reduce actions **********************************************/
	case 0: /* document ::= statement_list */
//line 490 "pikchr.y"
		{
			p.pik_render(yypParser.yystack[yypParser.yytos+0].minor.yy186)
		}
//line 2299 "pikchr.go"
		break
	case 1: /* statement_list ::= statement */
//line 493 "pikchr.y"
		{
			yylhsminor.yy186 = p.pik_elist_append(nil, yypParser.yystack[yypParser.yytos+0].minor.yy104)
		}
//line 2304 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy186 = yylhsminor.yy186
		break
	case 2: /* statement_list ::= statement_list EOL statement */
//line 495 "pikchr.y"
		{
			yylhsminor.yy186 = p.pik_elist_append(yypParser.yystack[yypParser.yytos+-2].minor.yy186, yypParser.yystack[yypParser.yytos+0].minor.yy104)
		}
//line 2310 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy186 = yylhsminor.yy186
		break
	case 3: /* statement ::= */
//line 498 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+1].minor.yy104 = nil
		}
//line 2316 "pikchr.go"
		break
	case 4: /* statement ::= direction */
//line 499 "pikchr.y"
		{
			p.pik_set_direction(uint8(yypParser.yystack[yypParser.yytos+0].minor.yy0.eCode))
			yylhsminor.yy104 = nil
		}
//line 2321 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy104 = yylhsminor.yy104
		break
	case 5: /* statement ::= lvalue ASSIGN rvalue */
//line 500 "pikchr.y"
		{
			p.pik_set_var(&yypParser.yystack[yypParser.yytos+-2].minor.yy0, yypParser.yystack[yypParser.yytos+0].minor.yy153, &yypParser.yystack[yypParser.yytos+-1].minor.yy0)
			yylhsminor.yy104 = nil
		}
//line 2327 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy104 = yylhsminor.yy104
		break
	case 6: /* statement ::= PLACENAME COLON unnamed_statement */
//line 502 "pikchr.y"
		{
			yylhsminor.yy104 = yypParser.yystack[yypParser.yytos+0].minor.yy104
			p.pik_elem_setname(yypParser.yystack[yypParser.yytos+0].minor.yy104, &yypParser.yystack[yypParser.yytos+-2].minor.yy0)
		}
//line 2333 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy104 = yylhsminor.yy104
		break
	case 7: /* statement ::= PLACENAME COLON position */
//line 504 "pikchr.y"
		{
			yylhsminor.yy104 = p.pik_elem_new(nil, nil, nil)
			if yylhsminor.yy104 != nil {
				yylhsminor.yy104.ptAt = yypParser.yystack[yypParser.yytos+0].minor.yy79
				p.pik_elem_setname(yylhsminor.yy104, &yypParser.yystack[yypParser.yytos+-2].minor.yy0)
			}
		}
//line 2340 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy104 = yylhsminor.yy104
		break
	case 8: /* statement ::= unnamed_statement */
//line 506 "pikchr.y"
		{
			yylhsminor.yy104 = yypParser.yystack[yypParser.yytos+0].minor.yy104
		}
//line 2346 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy104 = yylhsminor.yy104
		break
	case 9: /* statement ::= print prlist */
//line 507 "pikchr.y"
		{
			p.pik_append("<br>\n")
			yypParser.yystack[yypParser.yytos+-1].minor.yy104 = nil
		}
//line 2352 "pikchr.go"
		break
	case 10: /* statement ::= ASSERT LP expr EQ expr RP */
//line 512 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-5].minor.yy104 = p.pik_assert(yypParser.yystack[yypParser.yytos+-3].minor.yy153, &yypParser.yystack[yypParser.yytos+-2].minor.yy0, yypParser.yystack[yypParser.yytos+-1].minor.yy153)
		}
//line 2357 "pikchr.go"
		break
	case 11: /* statement ::= ASSERT LP position EQ position RP */
//line 514 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-5].minor.yy104 = p.pik_position_assert(&yypParser.yystack[yypParser.yytos+-3].minor.yy79, &yypParser.yystack[yypParser.yytos+-2].minor.yy0, &yypParser.yystack[yypParser.yytos+-1].minor.yy79)
		}
//line 2362 "pikchr.go"
		break
	case 12: /* statement ::= DEFINE ID CODEBLOCK */
//line 515 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-2].minor.yy104 = nil
			p.pik_add_macro(&yypParser.yystack[yypParser.yytos+-1].minor.yy0, &yypParser.yystack[yypParser.yytos+0].minor.yy0)
		}
//line 2367 "pikchr.go"
		break
	case 13: /* rvalue ::= PLACENAME */
//line 526 "pikchr.y"
		{
			yylhsminor.yy153 = p.pik_lookup_color(&yypParser.yystack[yypParser.yytos+0].minor.yy0)
		}
//line 2372 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy153 = yylhsminor.yy153
		break
	case 14: /* pritem ::= FILL */
		fallthrough
	case 15: /* pritem ::= COLOR */
		yytestcase(yyruleno == 15)
		fallthrough
	case 16: /* pritem ::= THICKNESS */
		yytestcase(yyruleno == 16)
//line 531 "pikchr.y"
		{
			p.pik_append_num("", p.pik_value(yypParser.yystack[yypParser.yytos+0].minor.yy0.String(), nil))
		}
//line 2382 "pikchr.go"
		break
	case 17: /* pritem ::= rvalue */
//line 534 "pikchr.y"
		{
			p.pik_append_num("", yypParser.yystack[yypParser.yytos+0].minor.yy153)
		}
//line 2387 "pikchr.go"
		break
	case 18: /* pritem ::= STRING */
//line 535 "pikchr.y"
		{
			p.pik_append_text(string(yypParser.yystack[yypParser.yytos+0].minor.yy0.z[1:yypParser.yystack[yypParser.yytos+0].minor.yy0.n-1]), 0)
		}
//line 2392 "pikchr.go"
		break
	case 19: /* prsep ::= COMMA */
//line 536 "pikchr.y"
		{
			p.pik_append(" ")
		}
//line 2397 "pikchr.go"
		break
	case 20: /* unnamed_statement ::= basetype attribute_list */
//line 539 "pikchr.y"
		{
			yylhsminor.yy104 = yypParser.yystack[yypParser.yytos+-1].minor.yy104
			p.pik_after_adding_attributes(yylhsminor.yy104)
		}
//line 2402 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-1].minor.yy104 = yylhsminor.yy104
		break
	case 21: /* basetype ::= CLASSNAME */
//line 541 "pikchr.y"
		{
			yylhsminor.yy104 = p.pik_elem_new(&yypParser.yystack[yypParser.yytos+0].minor.yy0, nil, nil)
		}
//line 2408 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy104 = yylhsminor.yy104
		break
	case 22: /* basetype ::= STRING textposition */
//line 543 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-1].minor.yy0.eCode = int16(yypParser.yystack[yypParser.yytos+0].minor.yy112)
			yylhsminor.yy104 = p.pik_elem_new(nil, &yypParser.yystack[yypParser.yytos+-1].minor.yy0, nil)
		}
//line 2414 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-1].minor.yy104 = yylhsminor.yy104
		break
	case 23: /* basetype ::= LB savelist statement_list RB */
//line 545 "pikchr.y"
		{
			p.list = yypParser.yystack[yypParser.yytos+-2].minor.yy186
			yypParser.yystack[yypParser.yytos+-3].minor.yy104 = p.pik_elem_new(nil, nil, yypParser.yystack[yypParser.yytos+-1].minor.yy186)
			if yypParser.yystack[yypParser.yytos+-3].minor.yy104 != nil {
				yypParser.yystack[yypParser.yytos+-3].minor.yy104.errTok = yypParser.yystack[yypParser.yytos+0].minor.yy0
			}
		}
//line 2420 "pikchr.go"
		break
	case 24: /* savelist ::= */
//line 550 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+1].minor.yy186 = p.list
			p.list = nil
		}
//line 2425 "pikchr.go"
		break
	case 25: /* relexpr ::= expr */
//line 557 "pikchr.y"
		{
			yylhsminor.yy10.rAbs = yypParser.yystack[yypParser.yytos+0].minor.yy153
			yylhsminor.yy10.rRel = 0
		}
//line 2430 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy10 = yylhsminor.yy10
		break
	case 26: /* relexpr ::= expr PERCENT */
//line 558 "pikchr.y"
		{
			yylhsminor.yy10.rAbs = 0
			yylhsminor.yy10.rRel = yypParser.yystack[yypParser.yytos+-1].minor.yy153 / 100
		}
//line 2436 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-1].minor.yy10 = yylhsminor.yy10
		break
	case 27: /* optrelexpr ::= */
//line 560 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+1].minor.yy10.rAbs = 0
			yypParser.yystack[yypParser.yytos+1].minor.yy10.rRel = 1.0
		}
//line 2442 "pikchr.go"
		break
	case 28: /* attribute_list ::= relexpr alist */
//line 562 "pikchr.y"
		{
			p.pik_add_direction(nil, &yypParser.yystack[yypParser.yytos+-1].minor.yy10)
		}
//line 2447 "pikchr.go"
		break
	case 29: /* attribute ::= numproperty relexpr */
//line 566 "pikchr.y"
		{
			p.pik_set_numprop(&yypParser.yystack[yypParser.yytos+-1].minor.yy0, &yypParser.yystack[yypParser.yytos+0].minor.yy10)
		}
//line 2452 "pikchr.go"
		break
	case 30: /* attribute ::= dashproperty expr */
//line 567 "pikchr.y"
		{
			p.pik_set_dashed(&yypParser.yystack[yypParser.yytos+-1].minor.yy0, &yypParser.yystack[yypParser.yytos+0].minor.yy153)
		}
//line 2457 "pikchr.go"
		break
	case 31: /* attribute ::= dashproperty */
//line 568 "pikchr.y"
		{
			p.pik_set_dashed(&yypParser.yystack[yypParser.yytos+0].minor.yy0, nil)
		}
//line 2462 "pikchr.go"
		break
	case 32: /* attribute ::= colorproperty rvalue */
//line 569 "pikchr.y"
		{
			p.pik_set_clrprop(&yypParser.yystack[yypParser.yytos+-1].minor.yy0, yypParser.yystack[yypParser.yytos+0].minor.yy153)
		}
//line 2467 "pikchr.go"
		break
	case 33: /* attribute ::= go direction optrelexpr */
//line 570 "pikchr.y"
		{
			p.pik_add_direction(&yypParser.yystack[yypParser.yytos+-1].minor.yy0, &yypParser.yystack[yypParser.yytos+0].minor.yy10)
		}
//line 2472 "pikchr.go"
		break
	case 34: /* attribute ::= go direction even position */
//line 571 "pikchr.y"
		{
			p.pik_evenwith(&yypParser.yystack[yypParser.yytos+-2].minor.yy0, &yypParser.yystack[yypParser.yytos+0].minor.yy79)
		}
//line 2477 "pikchr.go"
		break
	case 35: /* attribute ::= CLOSE */
//line 572 "pikchr.y"
		{
			p.pik_close_path(&yypParser.yystack[yypParser.yytos+0].minor.yy0)
		}
//line 2482 "pikchr.go"
		break
	case 36: /* attribute ::= CHOP */
//line 573 "pikchr.y"
		{
			p.cur.bChop = true
		}
//line 2487 "pikchr.go"
		break
	case 37: /* attribute ::= FROM position */
//line 574 "pikchr.y"
		{
			p.pik_set_from(p.cur, &yypParser.yystack[yypParser.yytos+-1].minor.yy0, &yypParser.yystack[yypParser.yytos+0].minor.yy79)
		}
//line 2492 "pikchr.go"
		break
	case 38: /* attribute ::= TO position */
//line 575 "pikchr.y"
		{
			p.pik_add_to(p.cur, &yypParser.yystack[yypParser.yytos+-1].minor.yy0, &yypParser.yystack[yypParser.yytos+0].minor.yy79)
		}
//line 2497 "pikchr.go"
		break
	case 39: /* attribute ::= THEN */
//line 576 "pikchr.y"
		{
			p.pik_then(&yypParser.yystack[yypParser.yytos+0].minor.yy0, p.cur)
		}
//line 2502 "pikchr.go"
		break
	case 40: /* attribute ::= THEN optrelexpr HEADING expr */
		fallthrough
	case 42: /* attribute ::= GO optrelexpr HEADING expr */
		yytestcase(yyruleno == 42)
//line 578 "pikchr.y"
		{
			p.pik_move_hdg(&yypParser.yystack[yypParser.yytos+-2].minor.yy10, &yypParser.yystack[yypParser.yytos+-1].minor.yy0, yypParser.yystack[yypParser.yytos+0].minor.yy153, nil, &yypParser.yystack[yypParser.yytos+-3].minor.yy0)
		}
//line 2509 "pikchr.go"
		break
	case 41: /* attribute ::= THEN optrelexpr EDGEPT */
		fallthrough
	case 43: /* attribute ::= GO optrelexpr EDGEPT */
		yytestcase(yyruleno == 43)
//line 579 "pikchr.y"
		{
			p.pik_move_hdg(&yypParser.yystack[yypParser.yytos+-1].minor.yy10, nil, 0, &yypParser.yystack[yypParser.yytos+0].minor.yy0, &yypParser.yystack[yypParser.yytos+-2].minor.yy0)
		}
//line 2516 "pikchr.go"
		break
	case 44: /* attribute ::= AT position */
//line 584 "pikchr.y"
		{
			p.pik_set_at(nil, &yypParser.yystack[yypParser.yytos+0].minor.yy79, &yypParser.yystack[yypParser.yytos+-1].minor.yy0)
		}
//line 2521 "pikchr.go"
		break
	case 45: /* attribute ::= SAME */
//line 586 "pikchr.y"
		{
			p.pik_same(nil, &yypParser.yystack[yypParser.yytos+0].minor.yy0)
		}
//line 2526 "pikchr.go"
		break
	case 46: /* attribute ::= SAME AS object */
//line 587 "pikchr.y"
		{
			p.pik_same(yypParser.yystack[yypParser.yytos+0].minor.yy104, &yypParser.yystack[yypParser.yytos+-2].minor.yy0)
		}
//line 2531 "pikchr.go"
		break
	case 47: /* attribute ::= STRING textposition */
//line 588 "pikchr.y"
		{
			p.pik_add_txt(&yypParser.yystack[yypParser.yytos+-1].minor.yy0, int16(yypParser.yystack[yypParser.yytos+0].minor.yy112))
		}
//line 2536 "pikchr.go"
		break
	case 48: /* attribute ::= FIT */
//line 589 "pikchr.y"
		{
			p.pik_size_to_fit(&yypParser.yystack[yypParser.yytos+0].minor.yy0, 3)
		}
//line 2541 "pikchr.go"
		break
	case 49: /* attribute ::= BEHIND object */
//line 590 "pikchr.y"
		{
			p.pik_behind(yypParser.yystack[yypParser.yytos+0].minor.yy104)
		}
//line 2546 "pikchr.go"
		break
	case 50: /* withclause ::= DOT_E edge AT position */
		fallthrough
	case 51: /* withclause ::= edge AT position */
		yytestcase(yyruleno == 51)
//line 598 "pikchr.y"
		{
			p.pik_set_at(&yypParser.yystack[yypParser.yytos+-2].minor.yy0, &yypParser.yystack[yypParser.yytos+0].minor.yy79, &yypParser.yystack[yypParser.yytos+-1].minor.yy0)
		}
//line 2553 "pikchr.go"
		break
	case 52: /* numproperty ::= HEIGHT|WIDTH|RADIUS|DIAMETER|THICKNESS */
//line 602 "pikchr.y"
		{
			yylhsminor.yy0 = yypParser.yystack[yypParser.yytos+0].minor.yy0
		}
//line 2558 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy0 = yylhsminor.yy0
		break
	case 53: /* boolproperty ::= CW */
//line 613 "pikchr.y"
		{
			p.cur.cw = true
		}
//line 2564 "pikchr.go"
		break
	case 54: /* boolproperty ::= CCW */
//line 614 "pikchr.y"
		{
			p.cur.cw = false
		}
//line 2569 "pikchr.go"
		break
	case 55: /* boolproperty ::= LARROW */
//line 615 "pikchr.y"
		{
			p.cur.larrow = true
			p.cur.rarrow = false
		}
//line 2574 "pikchr.go"
		break
	case 56: /* boolproperty ::= RARROW */
//line 616 "pikchr.y"
		{
			p.cur.larrow = false
			p.cur.rarrow = true
		}
//line 2579 "pikchr.go"
		break
	case 57: /* boolproperty ::= LRARROW */
//line 617 "pikchr.y"
		{
			p.cur.larrow = true
			p.cur.rarrow = true
		}
//line 2584 "pikchr.go"
		break
	case 58: /* boolproperty ::= INVIS */
//line 618 "pikchr.y"
		{
			p.cur.sw = 0.0
		}
//line 2589 "pikchr.go"
		break
	case 59: /* boolproperty ::= THICK */
//line 619 "pikchr.y"
		{
			p.cur.sw *= 1.5
		}
//line 2594 "pikchr.go"
		break
	case 60: /* boolproperty ::= THIN */
//line 620 "pikchr.y"
		{
			p.cur.sw *= 0.67
		}
//line 2599 "pikchr.go"
		break
	case 61: /* boolproperty ::= SOLID */
//line 621 "pikchr.y"
		{
			p.cur.sw = p.pik_value("thickness", nil)
			p.cur.dotted = 0.0
			p.cur.dashed = 0.0
		}
//line 2605 "pikchr.go"
		break
	case 62: /* textposition ::= */
//line 624 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+1].minor.yy112 = 0
		}
//line 2610 "pikchr.go"
		break
	case 63: /* textposition ::= textposition CENTER|LJUST|RJUST|ABOVE|BELOW|ITALIC|BOLD|ALIGNED|BIG|SMALL */
//line 627 "pikchr.y"
		{
			yylhsminor.yy112 = pik_text_position(yypParser.yystack[yypParser.yytos+-1].minor.yy112, &yypParser.yystack[yypParser.yytos+0].minor.yy0)
		}
//line 2615 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-1].minor.yy112 = yylhsminor.yy112
		break
	case 64: /* position ::= expr COMMA expr */
//line 630 "pikchr.y"
		{
			yylhsminor.yy79.x = yypParser.yystack[yypParser.yytos+-2].minor.yy153
			yylhsminor.yy79.y = yypParser.yystack[yypParser.yytos+0].minor.yy153
		}
//line 2621 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy79 = yylhsminor.yy79
		break
	case 65: /* position ::= place PLUS expr COMMA expr */
//line 632 "pikchr.y"
		{
			yylhsminor.yy79.x = yypParser.yystack[yypParser.yytos+-4].minor.yy79.x + yypParser.yystack[yypParser.yytos+-2].minor.yy153
			yylhsminor.yy79.y = yypParser.yystack[yypParser.yytos+-4].minor.yy79.y + yypParser.yystack[yypParser.yytos+0].minor.yy153
		}
//line 2627 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-4].minor.yy79 = yylhsminor.yy79
		break
	case 66: /* position ::= place MINUS expr COMMA expr */
//line 633 "pikchr.y"
		{
			yylhsminor.yy79.x = yypParser.yystack[yypParser.yytos+-4].minor.yy79.x - yypParser.yystack[yypParser.yytos+-2].minor.yy153
			yylhsminor.yy79.y = yypParser.yystack[yypParser.yytos+-4].minor.yy79.y - yypParser.yystack[yypParser.yytos+0].minor.yy153
		}
//line 2633 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-4].minor.yy79 = yylhsminor.yy79
		break
	case 67: /* position ::= place PLUS LP expr COMMA expr RP */
//line 635 "pikchr.y"
		{
			yylhsminor.yy79.x = yypParser.yystack[yypParser.yytos+-6].minor.yy79.x + yypParser.yystack[yypParser.yytos+-3].minor.yy153
			yylhsminor.yy79.y = yypParser.yystack[yypParser.yytos+-6].minor.yy79.y + yypParser.yystack[yypParser.yytos+-1].minor.yy153
		}
//line 2639 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-6].minor.yy79 = yylhsminor.yy79
		break
	case 68: /* position ::= place MINUS LP expr COMMA expr RP */
//line 637 "pikchr.y"
		{
			yylhsminor.yy79.x = yypParser.yystack[yypParser.yytos+-6].minor.yy79.x - yypParser.yystack[yypParser.yytos+-3].minor.yy153
			yylhsminor.yy79.y = yypParser.yystack[yypParser.yytos+-6].minor.yy79.y - yypParser.yystack[yypParser.yytos+-1].minor.yy153
		}
//line 2645 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-6].minor.yy79 = yylhsminor.yy79
		break
	case 69: /* position ::= LP position COMMA position RP */
//line 638 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-4].minor.yy79.x = yypParser.yystack[yypParser.yytos+-3].minor.yy79.x
			yypParser.yystack[yypParser.yytos+-4].minor.yy79.y = yypParser.yystack[yypParser.yytos+-1].minor.yy79.y
		}
//line 2651 "pikchr.go"
		break
	case 70: /* position ::= LP position RP */
//line 639 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-2].minor.yy79 = yypParser.yystack[yypParser.yytos+-1].minor.yy79
		}
//line 2656 "pikchr.go"
		break
	case 71: /* position ::= expr between position AND position */
//line 641 "pikchr.y"
		{
			yylhsminor.yy79 = pik_position_between(yypParser.yystack[yypParser.yytos+-4].minor.yy153, yypParser.yystack[yypParser.yytos+-2].minor.yy79, yypParser.yystack[yypParser.yytos+0].minor.yy79)
		}
//line 2661 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-4].minor.yy79 = yylhsminor.yy79
		break
	case 72: /* position ::= expr LT position COMMA position GT */
//line 643 "pikchr.y"
		{
			yylhsminor.yy79 = pik_position_between(yypParser.yystack[yypParser.yytos+-5].minor.yy153, yypParser.yystack[yypParser.yytos+-3].minor.yy79, yypParser.yystack[yypParser.yytos+-1].minor.yy79)
		}
//line 2667 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-5].minor.yy79 = yylhsminor.yy79
		break
	case 73: /* position ::= expr ABOVE position */
//line 644 "pikchr.y"
		{
			yylhsminor.yy79 = yypParser.yystack[yypParser.yytos+0].minor.yy79
			yylhsminor.yy79.y += yypParser.yystack[yypParser.yytos+-2].minor.yy153
		}
//line 2673 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy79 = yylhsminor.yy79
		break
	case 74: /* position ::= expr BELOW position */
//line 645 "pikchr.y"
		{
			yylhsminor.yy79 = yypParser.yystack[yypParser.yytos+0].minor.yy79
			yylhsminor.yy79.y -= yypParser.yystack[yypParser.yytos+-2].minor.yy153
		}
//line 2679 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy79 = yylhsminor.yy79
		break
	case 75: /* position ::= expr LEFT OF position */
//line 646 "pikchr.y"
		{
			yylhsminor.yy79 = yypParser.yystack[yypParser.yytos+0].minor.yy79
			yylhsminor.yy79.x -= yypParser.yystack[yypParser.yytos+-3].minor.yy153
		}
//line 2685 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-3].minor.yy79 = yylhsminor.yy79
		break
	case 76: /* position ::= expr RIGHT OF position */
//line 647 "pikchr.y"
		{
			yylhsminor.yy79 = yypParser.yystack[yypParser.yytos+0].minor.yy79
			yylhsminor.yy79.x += yypParser.yystack[yypParser.yytos+-3].minor.yy153
		}
//line 2691 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-3].minor.yy79 = yylhsminor.yy79
		break
	case 77: /* position ::= expr ON HEADING EDGEPT OF position */
//line 649 "pikchr.y"
		{
			yylhsminor.yy79 = pik_position_at_hdg(yypParser.yystack[yypParser.yytos+-5].minor.yy153, &yypParser.yystack[yypParser.yytos+-2].minor.yy0, yypParser.yystack[yypParser.yytos+0].minor.yy79)
		}
//line 2697 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-5].minor.yy79 = yylhsminor.yy79
		break
	case 78: /* position ::= expr HEADING EDGEPT OF position */
//line 651 "pikchr.y"
		{
			yylhsminor.yy79 = pik_position_at_hdg(yypParser.yystack[yypParser.yytos+-4].minor.yy153, &yypParser.yystack[yypParser.yytos+-2].minor.yy0, yypParser.yystack[yypParser.yytos+0].minor.yy79)
		}
//line 2703 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-4].minor.yy79 = yylhsminor.yy79
		break
	case 79: /* position ::= expr EDGEPT OF position */
//line 653 "pikchr.y"
		{
			yylhsminor.yy79 = pik_position_at_hdg(yypParser.yystack[yypParser.yytos+-3].minor.yy153, &yypParser.yystack[yypParser.yytos+-2].minor.yy0, yypParser.yystack[yypParser.yytos+0].minor.yy79)
		}
//line 2709 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-3].minor.yy79 = yylhsminor.yy79
		break
	case 80: /* position ::= expr ON HEADING expr FROM position */
//line 655 "pikchr.y"
		{
			yylhsminor.yy79 = pik_position_at_angle(yypParser.yystack[yypParser.yytos+-5].minor.yy153, yypParser.yystack[yypParser.yytos+-2].minor.yy153, yypParser.yystack[yypParser.yytos+0].minor.yy79)
		}
//line 2715 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-5].minor.yy79 = yylhsminor.yy79
		break
	case 81: /* position ::= expr HEADING expr FROM position */
//line 657 "pikchr.y"
		{
			yylhsminor.yy79 = pik_position_at_angle(yypParser.yystack[yypParser.yytos+-4].minor.yy153, yypParser.yystack[yypParser.yytos+-2].minor.yy153, yypParser.yystack[yypParser.yytos+0].minor.yy79)
		}
//line 2721 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-4].minor.yy79 = yylhsminor.yy79
		break
	case 82: /* place ::= edge OF object */
//line 669 "pikchr.y"
		{
			yylhsminor.yy79 = p.pik_place_of_elem(yypParser.yystack[yypParser.yytos+0].minor.yy104, &yypParser.yystack[yypParser.yytos+-2].minor.yy0)
		}
//line 2727 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy79 = yylhsminor.yy79
		break
	case 83: /* place2 ::= object */
//line 670 "pikchr.y"
		{
			yylhsminor.yy79 = p.pik_place_of_elem(yypParser.yystack[yypParser.yytos+0].minor.yy104, nil)
		}
//line 2733 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy79 = yylhsminor.yy79
		break
	case 84: /* place2 ::= object DOT_E edge */
//line 671 "pikchr.y"
		{
			yylhsminor.yy79 = p.pik_place_of_elem(yypParser.yystack[yypParser.yytos+-2].minor.yy104, &yypParser.yystack[yypParser.yytos+0].minor.yy0)
		}
//line 2739 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy79 = yylhsminor.yy79
		break
	case 85: /* place2 ::= NTH VERTEX OF object */
//line 672 "pikchr.y"
		{
			yylhsminor.yy79 = p.pik_nth_vertex(&yypParser.yystack[yypParser.yytos+-3].minor.yy0, &yypParser.yystack[yypParser.yytos+-2].minor.yy0, yypParser.yystack[yypParser.yytos+0].minor.yy104)
		}
//line 2745 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-3].minor.yy79 = yylhsminor.yy79
		break
	case 86: /* object ::= nth */
//line 684 "pikchr.y"
		{
			yylhsminor.yy104 = p.pik_find_nth(nil, &yypParser.yystack[yypParser.yytos+0].minor.yy0)
		}
//line 2751 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy104 = yylhsminor.yy104
		break
	case 87: /* object ::= nth OF|IN object */
//line 685 "pikchr.y"
		{
			yylhsminor.yy104 = p.pik_find_nth(yypParser.yystack[yypParser.yytos+0].minor.yy104, &yypParser.yystack[yypParser.yytos+-2].minor.yy0)
		}
//line 2757 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy104 = yylhsminor.yy104
		break
	case 88: /* objectname ::= THIS */
//line 687 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+0].minor.yy104 = p.cur
		}
//line 2763 "pikchr.go"
		break
	case 89: /* objectname ::= PLACENAME */
//line 688 "pikchr.y"
		{
			yylhsminor.yy104 = p.pik_find_byname(nil, &yypParser.yystack[yypParser.yytos+0].minor.yy0)
		}
//line 2768 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy104 = yylhsminor.yy104
		break
	case 90: /* objectname ::= objectname DOT_U PLACENAME */
//line 690 "pikchr.y"
		{
			yylhsminor.yy104 = p.pik_find_byname(yypParser.yystack[yypParser.yytos+-2].minor.yy104, &yypParser.yystack[yypParser.yytos+0].minor.yy0)
		}
//line 2774 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy104 = yylhsminor.yy104
		break
	case 91: /* nth ::= NTH CLASSNAME */
//line 692 "pikchr.y"
		{
			yylhsminor.yy0 = yypParser.yystack[yypParser.yytos+0].minor.yy0
			yylhsminor.yy0.eCode = p.pik_nth_value(&yypParser.yystack[yypParser.yytos+-1].minor.yy0)
		}
//line 2780 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-1].minor.yy0 = yylhsminor.yy0
		break
	case 92: /* nth ::= NTH LAST CLASSNAME */
//line 693 "pikchr.y"
		{
			yylhsminor.yy0 = yypParser.yystack[yypParser.yytos+0].minor.yy0
			yylhsminor.yy0.eCode = -p.pik_nth_value(&yypParser.yystack[yypParser.yytos+-2].minor.yy0)
		}
//line 2786 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy0 = yylhsminor.yy0
		break
	case 93: /* nth ::= LAST CLASSNAME */
//line 694 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-1].minor.yy0 = yypParser.yystack[yypParser.yytos+0].minor.yy0
			yypParser.yystack[yypParser.yytos+-1].minor.yy0.eCode = -1
		}
//line 2792 "pikchr.go"
		break
	case 94: /* nth ::= LAST */
//line 695 "pikchr.y"
		{
			yylhsminor.yy0 = yypParser.yystack[yypParser.yytos+0].minor.yy0
			yylhsminor.yy0.eCode = -1
		}
//line 2797 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy0 = yylhsminor.yy0
		break
	case 95: /* nth ::= NTH LB RB */
//line 696 "pikchr.y"
		{
			yylhsminor.yy0 = yypParser.yystack[yypParser.yytos+-1].minor.yy0
			yylhsminor.yy0.eCode = p.pik_nth_value(&yypParser.yystack[yypParser.yytos+-2].minor.yy0)
		}
//line 2803 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy0 = yylhsminor.yy0
		break
	case 96: /* nth ::= NTH LAST LB RB */
//line 697 "pikchr.y"
		{
			yylhsminor.yy0 = yypParser.yystack[yypParser.yytos+-1].minor.yy0
			yylhsminor.yy0.eCode = -p.pik_nth_value(&yypParser.yystack[yypParser.yytos+-3].minor.yy0)
		}
//line 2809 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-3].minor.yy0 = yylhsminor.yy0
		break
	case 97: /* nth ::= LAST LB RB */
//line 698 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-2].minor.yy0 = yypParser.yystack[yypParser.yytos+-1].minor.yy0
			yypParser.yystack[yypParser.yytos+-2].minor.yy0.eCode = -1
		}
//line 2815 "pikchr.go"
		break
	case 98: /* expr ::= expr PLUS expr */
//line 700 "pikchr.y"
		{
			yylhsminor.yy153 = yypParser.yystack[yypParser.yytos+-2].minor.yy153 + yypParser.yystack[yypParser.yytos+0].minor.yy153
		}
//line 2820 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy153 = yylhsminor.yy153
		break
	case 99: /* expr ::= expr MINUS expr */
//line 701 "pikchr.y"
		{
			yylhsminor.yy153 = yypParser.yystack[yypParser.yytos+-2].minor.yy153 - yypParser.yystack[yypParser.yytos+0].minor.yy153
		}
//line 2826 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy153 = yylhsminor.yy153
		break
	case 100: /* expr ::= expr STAR expr */
//line 702 "pikchr.y"
		{
			yylhsminor.yy153 = yypParser.yystack[yypParser.yytos+-2].minor.yy153 * yypParser.yystack[yypParser.yytos+0].minor.yy153
		}
//line 2832 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy153 = yylhsminor.yy153
		break
	case 101: /* expr ::= expr SLASH expr */
//line 703 "pikchr.y"
		{
			if yypParser.yystack[yypParser.yytos+0].minor.yy153 == 0.0 {
				p.pik_error(&yypParser.yystack[yypParser.yytos+-1].minor.yy0, "division by zero")
				yylhsminor.yy153 = 0.0
			} else {
				yylhsminor.yy153 = yypParser.yystack[yypParser.yytos+-2].minor.yy153 / yypParser.yystack[yypParser.yytos+0].minor.yy153
			}
		}
//line 2840 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy153 = yylhsminor.yy153
		break
	case 102: /* expr ::= MINUS expr */
//line 706 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-1].minor.yy153 = -yypParser.yystack[yypParser.yytos+0].minor.yy153
		}
//line 2846 "pikchr.go"
		break
	case 103: /* expr ::= PLUS expr */
//line 707 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-1].minor.yy153 = yypParser.yystack[yypParser.yytos+0].minor.yy153
		}
//line 2851 "pikchr.go"
		break
	case 104: /* expr ::= LP expr RP */
//line 708 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-2].minor.yy153 = yypParser.yystack[yypParser.yytos+-1].minor.yy153
		}
//line 2856 "pikchr.go"
		break
	case 105: /* expr ::= LP FILL|COLOR|THICKNESS RP */
//line 709 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-2].minor.yy153 = p.pik_get_var(&yypParser.yystack[yypParser.yytos+-1].minor.yy0)
		}
//line 2861 "pikchr.go"
		break
	case 106: /* expr ::= NUMBER */
//line 710 "pikchr.y"
		{
			yylhsminor.yy153 = pik_atof(&yypParser.yystack[yypParser.yytos+0].minor.yy0)
		}
//line 2866 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy153 = yylhsminor.yy153
		break
	case 107: /* expr ::= ID */
//line 711 "pikchr.y"
		{
			yylhsminor.yy153 = p.pik_get_var(&yypParser.yystack[yypParser.yytos+0].minor.yy0)
		}
//line 2872 "pikchr.go"
		yypParser.yystack[yypParser.yytos+0].minor.yy153 = yylhsminor.yy153
		break
	case 108: /* expr ::= FUNC1 LP expr RP */
//line 712 "pikchr.y"
		{
			yylhsminor.yy153 = p.pik_func(&yypParser.yystack[yypParser.yytos+-3].minor.yy0, yypParser.yystack[yypParser.yytos+-1].minor.yy153, 0.0)
		}
//line 2878 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-3].minor.yy153 = yylhsminor.yy153
		break
	case 109: /* expr ::= FUNC2 LP expr COMMA expr RP */
//line 713 "pikchr.y"
		{
			yylhsminor.yy153 = p.pik_func(&yypParser.yystack[yypParser.yytos+-5].minor.yy0, yypParser.yystack[yypParser.yytos+-3].minor.yy153, yypParser.yystack[yypParser.yytos+-1].minor.yy153)
		}
//line 2884 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-5].minor.yy153 = yylhsminor.yy153
		break
	case 110: /* expr ::= DIST LP position COMMA position RP */
//line 714 "pikchr.y"
		{
			yypParser.yystack[yypParser.yytos+-5].minor.yy153 = pik_dist(&yypParser.yystack[yypParser.yytos+-3].minor.yy79, &yypParser.yystack[yypParser.yytos+-1].minor.yy79)
		}
//line 2890 "pikchr.go"
		break
	case 111: /* expr ::= place2 DOT_XY X */
//line 715 "pikchr.y"
		{
			yylhsminor.yy153 = yypParser.yystack[yypParser.yytos+-2].minor.yy79.x
		}
//line 2895 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy153 = yylhsminor.yy153
		break
	case 112: /* expr ::= place2 DOT_XY Y */
//line 716 "pikchr.y"
		{
			yylhsminor.yy153 = yypParser.yystack[yypParser.yytos+-2].minor.yy79.y
		}
//line 2901 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy153 = yylhsminor.yy153
		break
	case 113: /* expr ::= object DOT_L numproperty */
		fallthrough
	case 114: /* expr ::= object DOT_L dashproperty */
		yytestcase(yyruleno == 114)
		fallthrough
	case 115: /* expr ::= object DOT_L colorproperty */
		yytestcase(yyruleno == 115)
//line 717 "pikchr.y"
		{
			yylhsminor.yy153 = pik_property_of(yypParser.yystack[yypParser.yytos+-2].minor.yy104, &yypParser.yystack[yypParser.yytos+0].minor.yy0)
		}
//line 2911 "pikchr.go"
		yypParser.yystack[yypParser.yytos+-2].minor.yy153 = yylhsminor.yy153
		break
	default:
		/* (116) lvalue ::= ID */ yytestcase(yyruleno == 116)
		/* (117) lvalue ::= FILL */ yytestcase(yyruleno == 117)
		/* (118) lvalue ::= COLOR */ yytestcase(yyruleno == 118)
		/* (119) lvalue ::= THICKNESS */ yytestcase(yyruleno == 119)
		/* (120) rvalue ::= expr */ yytestcase(yyruleno == 120)
		/* (121) print ::= PRINT */ yytestcase(yyruleno == 121)
		/* (122) prlist ::= pritem (OPTIMIZED OUT) */ assert(yyruleno != 122, "yyruleno!=122")
		/* (123) prlist ::= prlist prsep pritem */ yytestcase(yyruleno == 123)
		/* (124) direction ::= UP */ yytestcase(yyruleno == 124)
		/* (125) direction ::= DOWN */ yytestcase(yyruleno == 125)
		/* (126) direction ::= LEFT */ yytestcase(yyruleno == 126)
		/* (127) direction ::= RIGHT */ yytestcase(yyruleno == 127)
		/* (128) optrelexpr ::= relexpr (OPTIMIZED OUT) */ assert(yyruleno != 128, "yyruleno!=128")
		/* (129) attribute_list ::= alist */ yytestcase(yyruleno == 129)
		/* (130) alist ::= */ yytestcase(yyruleno == 130)
		/* (131) alist ::= alist attribute */ yytestcase(yyruleno == 131)
		/* (132) attribute ::= boolproperty (OPTIMIZED OUT) */ assert(yyruleno != 132, "yyruleno!=132")
		/* (133) attribute ::= WITH withclause */ yytestcase(yyruleno == 133)
		/* (134) go ::= GO */ yytestcase(yyruleno == 134)
		/* (135) go ::= */ yytestcase(yyruleno == 135)
		/* (136) even ::= UNTIL EVEN WITH */ yytestcase(yyruleno == 136)
		/* (137) even ::= EVEN WITH */ yytestcase(yyruleno == 137)
		/* (138) dashproperty ::= DOTTED */ yytestcase(yyruleno == 138)
		/* (139) dashproperty ::= DASHED */ yytestcase(yyruleno == 139)
		/* (140) colorproperty ::= FILL */ yytestcase(yyruleno == 140)
		/* (141) colorproperty ::= COLOR */ yytestcase(yyruleno == 141)
		/* (142) position ::= place */ yytestcase(yyruleno == 142)
		/* (143) between ::= WAY BETWEEN */ yytestcase(yyruleno == 143)
		/* (144) between ::= BETWEEN */ yytestcase(yyruleno == 144)
		/* (145) between ::= OF THE WAY BETWEEN */ yytestcase(yyruleno == 145)
		/* (146) place ::= place2 */ yytestcase(yyruleno == 146)
		/* (147) edge ::= CENTER */ yytestcase(yyruleno == 147)
		/* (148) edge ::= EDGEPT */ yytestcase(yyruleno == 148)
		/* (149) edge ::= TOP */ yytestcase(yyruleno == 149)
		/* (150) edge ::= BOTTOM */ yytestcase(yyruleno == 150)
		/* (151) edge ::= START */ yytestcase(yyruleno == 151)
		/* (152) edge ::= END */ yytestcase(yyruleno == 152)
		/* (153) edge ::= RIGHT */ yytestcase(yyruleno == 153)
		/* (154) edge ::= LEFT */ yytestcase(yyruleno == 154)
		/* (155) object ::= objectname */ yytestcase(yyruleno == 155)
		break
		/********** End reduce actions ************************************************/
	}
	assert(int(yyruleno) < len(yyRuleInfoLhs), "yyruleno < len(yyRuleInfoLhs)")
	yygoto = yyRuleInfoLhs[yyruleno]
	yysize = int(yyRuleInfoNRhs[yyruleno])
	yyact = yy_find_reduce_action(yypParser.yystack[yymsp+yysize].stateno, yygoto)

	/* There are no SHIFTREDUCE actions on nonterminals because the table
	 ** generator has simplified them to pure REDUCE actions. */
	assert(!(yyact > YY_MAX_SHIFT && yyact <= YY_MAX_SHIFTREDUCE),
		"!(yyact > YY_MAX_SHIFT && yyact <= YY_MAX_SHIFTREDUCE)")

	/* It is not possible for a REDUCE to be followed by an error */
	assert(yyact != YY_ERROR_ACTION, "yyact != YY_ERROR_ACTION")

	yymsp += yysize + 1
	yypParser.yytos = yymsp
	yypParser.yystack[yymsp].stateno = yyact
	yypParser.yystack[yymsp].major = yygoto
	yypParser.yyTraceShift(int(yyact), "... then shift")
	return yyact
}

/*
** The following code executes when the parse fails
 */
func (yypParser *yyParser) yy_parse_failed() {

	p := yypParser.p
	_ = p

	if !NDEBUG {
		if yyTraceFILE != nil {
			fmt.Fprintf(yyTraceFILE, "%sFail!\n", yyTracePrompt)
		}
	}
	for yypParser.yytos > 0 {
		yypParser.yy_pop_parser_stack()
	}
	/* Here code is inserted which will be executed whenever the
	 ** parser fails */
	/************ Begin %parse_failure code ***************************************/

	/************ End %parse_failure code *****************************************/
	/* Suppress warning about unused %extra_argument variable */
	yypParser.p = p

}

/*
** The following code executes when a syntax error first occurs.
 */
func (yypParser *yyParser) yy_syntax_error(
	yymajor YYCODETYPE, /* The major type of the error token */
	yyminor pik_parserTOKENTYPE, /* The minor type of the error token */
) {

	p := yypParser.p
	_ = p

	TOKEN := yyminor
	_ = TOKEN
	/************ Begin %syntax_error code ****************************************/
//line 479 "pikchr.y"

	if TOKEN.z != nil && TOKEN.z[0] != 0 {
		p.pik_error(&TOKEN, "syntax error")
	} else {
		p.pik_error(nil, "syntax error")
	}
//line 3024 "pikchr.go"

	/************ End %syntax_error code ******************************************/
	/* Suppress warning about unused %extra_argument variable */
	yypParser.p = p

}

/*
** The following is executed when the parser accepts
 */
func (yypParser *yyParser) yy_accept() {

	p := yypParser.p
	_ = p

	if !NDEBUG {
		if yyTraceFILE != nil {
			fmt.Fprintf(yyTraceFILE, "%sAccept!\n", yyTracePrompt)
		}
	}
	if !YYNOERRORRECOVERY {
		yypParser.yyerrcnt = -1
	}
	assert(yypParser.yytos == 0, fmt.Sprintf("want yypParser.yytos == 0; got %d", yypParser.yytos))
	/* Here code is inserted which will be executed whenever the
	 ** parser accepts */
	/*********** Begin %parse_accept code *****************************************/

	/*********** End %parse_accept code *******************************************/
	/* Suppress warning about unused %extra_argument variable */
	yypParser.p = p

}

/* The main parser program.
** The first argument is a pointer to a structure obtained from
** "pik_parserAlloc" which describes the current state of the parser.
** The second argument is the major token number.  The third is
** the minor token.  The fourth optional argument is whatever the
** user wants (and specified in the grammar) and is available for
** use by the action routines.
**
** Inputs:
** <ul>
** <li> A pointer to the parser (an opaque structure.)
** <li> The major token number.
** <li> The minor token number.
** <li> An option argument of a grammar-specified type.
** </ul>
**
** Outputs:
** None.
 */
func (yypParser *yyParser) pik_parser(
	yymajor YYCODETYPE, /* The major token code number */
	yyminor pik_parserTOKENTYPE, /* The value for the token */
	/* Optional %extra_argument parameter */
) {
	var (
		yyminorunion YYMINORTYPE
		yyact        YYACTIONTYPE /* The parser action. */
		yyendofinput bool         /* True if we are at the end of input */
		yyerrorhit   bool         /* True if yymajor has invoked an error */
	)

	p := yypParser.p
	_ = p

	assert(yypParser.yystack != nil, "yypParser.yystack != nil")
	if YYERRORSYMBOL == 0 && !YYNOERRORRECOVERY {
		yyendofinput = (yymajor == 0)
	}

	yyact = yypParser.yystack[yypParser.yytos].stateno
	if !NDEBUG {
		if yyTraceFILE != nil {
			if yyact < YY_MIN_REDUCE {
				fmt.Fprintf(yyTraceFILE, "%sInput '%s' in state %d\n",
					yyTracePrompt, yyTokenName[yymajor], yyact)
			} else {
				fmt.Fprintf(yyTraceFILE, "%sInput '%s' with pending reduce %d\n",
					yyTracePrompt, yyTokenName[yymajor], yyact-YY_MIN_REDUCE)
			}
		}
	}

	for { /* Exit by "break" */
		assert(yypParser.yytos >= 0, "yypParser.yytos >= 0")
		assert(yyact == yypParser.yystack[yypParser.yytos].stateno, "yyact == yypParser.yystack[yypParser.yytos].stateno")
		yyact = yy_find_shift_action(yymajor, yyact)
		if yyact >= YY_MIN_REDUCE {
			yyruleno := yyact - YY_MIN_REDUCE /* Reduce by this rule */
			if !NDEBUG {
				assert(int(yyruleno) < len(yyRuleName), "int(yyruleno) < len(yyRuleName)")
				if yyTraceFILE != nil {
					yysize := yyRuleInfoNRhs[yyruleno]
					wea := " without external action"
					if yyruleno < YYNRULE_WITH_ACTION {
						wea = ""
					}
					if yysize != 0 {
						fmt.Fprintf(yyTraceFILE, "%sReduce %d [%s]%s, pop back to state %d.\n",
							yyTracePrompt,
							yyruleno, yyRuleName[yyruleno],
							wea,
							yypParser.yystack[yypParser.yytos+int(yysize)].stateno)
					} else {
						fmt.Fprintf(yyTraceFILE, "%sReduce %d [%s]%s.\n",
							yyTracePrompt, yyruleno, yyRuleName[yyruleno],
							wea)
					}
				}
			} /* NDEBUG */

			/* Check that the stack is large enough to grow by a single entry
			 ** if the RHS of the rule is empty.  This ensures that there is room
			 ** enough on the stack to push the LHS value */
			if yyRuleInfoNRhs[yyruleno] == 0 {
				if YYTRACKMAXSTACKDEPTH {
					if yypParser.yytos > yypParser.yyhwm {
						yypParser.yyhwm++
						assert(yypParser.yyhwm == yypParser.yytos, "yypParser.yyhwm == yypParser.yytos")
					}
				}
				if YYSTACKDEPTH > 0 {
					if yypParser.yytos >= YYSTACKDEPTH-1 {
						yypParser.yyStackOverflow()
						break
					}
				} else {
					if yypParser.yytos+1 >= len(yypParser.yystack)-1 {
						yypParser.yyGrowStack()
					}
				}
			}
			yyact = yypParser.yy_reduce(yyruleno, yymajor, yyminor,
				p)
		} else if yyact <= YY_MAX_SHIFTREDUCE {
			yypParser.yy_shift(yyact, yymajor, yyminor)
			if !YYNOERRORRECOVERY {
				yypParser.yyerrcnt--
			}
			break
		} else if yyact == YY_ACCEPT_ACTION {
			yypParser.yytos--
			yypParser.yy_accept()
			return
		} else {
			assert(yyact == YY_ERROR_ACTION, "yyact == YY_ERROR_ACTION")
			yyminorunion.yy0 = yyminor

			if !NDEBUG {
				if yyTraceFILE != nil {
					fmt.Fprintf(yyTraceFILE, "%sSyntax Error!\n", yyTracePrompt)
				}
			}
			if YYERRORSYMBOL > 0 {
				/* A syntax error has occurred.
				 ** The response to an error depends upon whether or not the
				 ** grammar defines an error token "ERROR".
				 **
				 ** This is what we do if the grammar does define ERROR:
				 **
				 **  * Call the %syntax_error function.
				 **
				 **  * Begin popping the stack until we enter a state where
				 **    it is legal to shift the error symbol, then shift
				 **    the error symbol.
				 **
				 **  * Set the error count to three.
				 **
				 **  * Begin accepting and shifting new tokens.  No new error
				 **    processing will occur until three tokens have been
				 **    shifted successfully.
				 **
				 */
				if yypParser.yyerrcnt < 0 {
					yypParser.yy_syntax_error(yymajor, yyminor)
				}
				yymx := yypParser.yystack[yypParser.yytos].major
				if int(yymx) == YYERRORSYMBOL || yyerrorhit {
					if !NDEBUG {
						if yyTraceFILE != nil {
							fmt.Fprintf(yyTraceFILE, "%sDiscard input token %s\n",
								yyTracePrompt, yyTokenName[yymajor])
						}
					}
					yypParser.yy_destructor(yymajor, &yyminorunion)
					yymajor = YYNOCODE
				} else {
					for yypParser.yytos > 0 {
						yyact = yy_find_reduce_action(yypParser.yystack[yypParser.yytos].stateno,
							YYERRORSYMBOL)
						if yyact <= YY_MAX_SHIFTREDUCE {
							break
						}
						yypParser.yy_pop_parser_stack()
					}
					if yypParser.yytos <= 0 || yymajor == 0 {
						yypParser.yy_destructor(yymajor, &yyminorunion)
						yypParser.yy_parse_failed()
						if !YYNOERRORRECOVERY {
							yypParser.yyerrcnt = -1
						}
						yymajor = YYNOCODE
					} else if yymx != YYERRORSYMBOL {
						yypParser.yy_shift(yyact, YYERRORSYMBOL, yyminor)
					}
				}
				yypParser.yyerrcnt = 3
				yyerrorhit = true
				if yymajor == YYNOCODE {
					break
				}
				yyact = yypParser.yystack[yypParser.yytos].stateno
			} else if YYNOERRORRECOVERY {
				/* If the YYNOERRORRECOVERY macro is defined, then do not attempt to
				 ** do any kind of error recovery.  Instead, simply invoke the syntax
				 ** error routine and continue going as if nothing had happened.
				 **
				 ** Applications can set this macro (for example inside %include) if
				 ** they intend to abandon the parse upon the first syntax error seen.
				 */
				yypParser.yy_syntax_error(yymajor, yyminor)
				yypParser.yy_destructor(yymajor, &yyminorunion)
				break
			} else { /* YYERRORSYMBOL is not defined */
				/* This is what we do if the grammar does not define ERROR:
				 **
				 **  * Report an error message, and throw away the input token.
				 **
				 **  * If the input token is $, then fail the parse.
				 **
				 ** As before, subsequent error messages are suppressed until
				 ** three input tokens have been successfully shifted.
				 */
				if yypParser.yyerrcnt <= 0 {
					yypParser.yy_syntax_error(yymajor, yyminor)
				}
				yypParser.yyerrcnt = 3
				yypParser.yy_destructor(yymajor, &yyminorunion)
				if yyendofinput {
					yypParser.yy_parse_failed()
					if !YYNOERRORRECOVERY {
						yypParser.yyerrcnt = -1
					}
				}
				break
			}
		}
	}
	if !NDEBUG {
		if yyTraceFILE != nil {
			cDiv := '['
			fmt.Fprintf(yyTraceFILE, "%sReturn. Stack=", yyTracePrompt)
			for _, i := range yypParser.yystack[1 : yypParser.yytos+1] {
				fmt.Fprintf(yyTraceFILE, "%c%s", cDiv, yyTokenName[i.major])
				cDiv = ' '
			}
			fmt.Fprintf(yyTraceFILE, "]\n")
		}
	}
	return
}

/*
** Return the fallback token corresponding to canonical token iToken, or
** 0 if iToken has no fallback.
 */
func pik_parserFallback(iToken int) YYCODETYPE {
	if YYFALLBACK {
		assert(iToken < len(yyFallback), "iToken < len(yyFallback)")
		return yyFallback[iToken]
	} else {
		return 0
	}
}

// assert is used in various places in the generated and template code
// to check invariants.
func assert(condition bool, message string) {
	if !condition {
		panic(message)
	}
}

//line 722 "pikchr.y"

/* Chart of the 148 official CSS color names with their
** corresponding RGB values thru Color Module Level 4:
** https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
**
** Two new names "None" and "Off" are added with a value
** of -1.
 */
var aColor = []struct {
	zName string /* Name of the color */
	val   int    /* RGB value */
}{
	{"AliceBlue", 0xf0f8ff},
	{"AntiqueWhite", 0xfaebd7},
	{"Aqua", 0x00ffff},
	{"Aquamarine", 0x7fffd4},
	{"Azure", 0xf0ffff},
	{"Beige", 0xf5f5dc},
	{"Bisque", 0xffe4c4},
	{"Black", 0x000000},
	{"BlanchedAlmond", 0xffebcd},
	{"Blue", 0x0000ff},
	{"BlueViolet", 0x8a2be2},
	{"Brown", 0xa52a2a},
	{"BurlyWood", 0xdeb887},
	{"CadetBlue", 0x5f9ea0},
	{"Chartreuse", 0x7fff00},
	{"Chocolate", 0xd2691e},
	{"Coral", 0xff7f50},
	{"CornflowerBlue", 0x6495ed},
	{"Cornsilk", 0xfff8dc},
	{"Crimson", 0xdc143c},
	{"Cyan", 0x00ffff},
	{"DarkBlue", 0x00008b},
	{"DarkCyan", 0x008b8b},
	{"DarkGoldenrod", 0xb8860b},
	{"DarkGray", 0xa9a9a9},
	{"DarkGreen", 0x006400},
	{"DarkGrey", 0xa9a9a9},
	{"DarkKhaki", 0xbdb76b},
	{"DarkMagenta", 0x8b008b},
	{"DarkOliveGreen", 0x556b2f},
	{"DarkOrange", 0xff8c00},
	{"DarkOrchid", 0x9932cc},
	{"DarkRed", 0x8b0000},
	{"DarkSalmon", 0xe9967a},
	{"DarkSeaGreen", 0x8fbc8f},
	{"DarkSlateBlue", 0x483d8b},
	{"DarkSlateGray", 0x2f4f4f},
	{"DarkSlateGrey", 0x2f4f4f},
	{"DarkTurquoise", 0x00ced1},
	{"DarkViolet", 0x9400d3},
	{"DeepPink", 0xff1493},
	{"DeepSkyBlue", 0x00bfff},
	{"DimGray", 0x696969},
	{"DimGrey", 0x696969},
	{"DodgerBlue", 0x1e90ff},
	{"Firebrick", 0xb22222},
	{"FloralWhite", 0xfffaf0},
	{"ForestGreen", 0x228b22},
	{"Fuchsia", 0xff00ff},
	{"Gainsboro", 0xdcdcdc},
	{"GhostWhite", 0xf8f8ff},
	{"Gold", 0xffd700},
	{"Goldenrod", 0xdaa520},
	{"Gray", 0x808080},
	{"Green", 0x008000},
	{"GreenYellow", 0xadff2f},
	{"Grey", 0x808080},
	{"Honeydew", 0xf0fff0},
	{"HotPink", 0xff69b4},
	{"IndianRed", 0xcd5c5c},
	{"Indigo", 0x4b0082},
	{"Ivory", 0xfffff0},
	{"Khaki", 0xf0e68c},
	{"Lavender", 0xe6e6fa},
	{"LavenderBlush", 0xfff0f5},
	{"LawnGreen", 0x7cfc00},
	{"LemonChiffon", 0xfffacd},
	{"LightBlue", 0xadd8e6},
	{"LightCoral", 0xf08080},
	{"LightCyan", 0xe0ffff},
	{"LightGoldenrodYellow", 0xfafad2},
	{"LightGray", 0xd3d3d3},
	{"LightGreen", 0x90ee90},
	{"LightGrey", 0xd3d3d3},
	{"LightPink", 0xffb6c1},
	{"LightSalmon", 0xffa07a},
	{"LightSeaGreen", 0x20b2aa},
	{"LightSkyBlue", 0x87cefa},
	{"LightSlateGray", 0x778899},
	{"LightSlateGrey", 0x778899},
	{"LightSteelBlue", 0xb0c4de},
	{"LightYellow", 0xffffe0},
	{"Lime", 0x00ff00},
	{"LimeGreen", 0x32cd32},
	{"Linen", 0xfaf0e6},
	{"Magenta", 0xff00ff},
	{"Maroon", 0x800000},
	{"MediumAquamarine", 0x66cdaa},
	{"MediumBlue", 0x0000cd},
	{"MediumOrchid", 0xba55d3},
	{"MediumPurple", 0x9370db},
	{"MediumSeaGreen", 0x3cb371},
	{"MediumSlateBlue", 0x7b68ee},
	{"MediumSpringGreen", 0x00fa9a},
	{"MediumTurquoise", 0x48d1cc},
	{"MediumVioletRed", 0xc71585},
	{"MidnightBlue", 0x191970},
	{"MintCream", 0xf5fffa},
	{"MistyRose", 0xffe4e1},
	{"Moccasin", 0xffe4b5},
	{"NavajoWhite", 0xffdead},
	{"Navy", 0x000080},
	{"None", -1}, /* Non-standard addition */
	{"Off", -1},  /* Non-standard addition */
	{"OldLace", 0xfdf5e6},
	{"Olive", 0x808000},
	{"OliveDrab", 0x6b8e23},
	{"Orange", 0xffa500},
	{"OrangeRed", 0xff4500},
	{"Orchid", 0xda70d6},
	{"PaleGoldenrod", 0xeee8aa},
	{"PaleGreen", 0x98fb98},
	{"PaleTurquoise", 0xafeeee},
	{"PaleVioletRed", 0xdb7093},
	{"PapayaWhip", 0xffefd5},
	{"PeachPuff", 0xffdab9},
	{"Peru", 0xcd853f},
	{"Pink", 0xffc0cb},
	{"Plum", 0xdda0dd},
	{"PowderBlue", 0xb0e0e6},
	{"Purple", 0x800080},
	{"RebeccaPurple", 0x663399},
	{"Red", 0xff0000},
	{"RosyBrown", 0xbc8f8f},
	{"RoyalBlue", 0x4169e1},
	{"SaddleBrown", 0x8b4513},
	{"Salmon", 0xfa8072},
	{"SandyBrown", 0xf4a460},
	{"SeaGreen", 0x2e8b57},
	{"Seashell", 0xfff5ee},
	{"Sienna", 0xa0522d},
	{"Silver", 0xc0c0c0},
	{"SkyBlue", 0x87ceeb},
	{"SlateBlue", 0x6a5acd},
	{"SlateGray", 0x708090},
	{"SlateGrey", 0x708090},
	{"Snow", 0xfffafa},
	{"SpringGreen", 0x00ff7f},
	{"SteelBlue", 0x4682b4},
	{"Tan", 0xd2b48c},
	{"Teal", 0x008080},
	{"Thistle", 0xd8bfd8},
	{"Tomato", 0xff6347},
	{"Turquoise", 0x40e0d0},
	{"Violet", 0xee82ee},
	{"Wheat", 0xf5deb3},
	{"White", 0xffffff},
	{"WhiteSmoke", 0xf5f5f5},
	{"Yellow", 0xffff00},
	{"YellowGreen", 0x9acd32},
}

/* Built-in variable names.
**
** This array is constant.  When a script changes the value of one of
** these built-ins, a new PVar record is added at the head of
** the Pik.pVar list, which is searched first.  Thus the new PVar entry
** will override this default value.
**
** Units are in inches, except for "color" and "fill" which are
** interpreted as 24-bit RGB values.
**
** Binary search used.  Must be kept in sorted order.
 */

var aBuiltin = []struct {
	zName string
	val   PNum
}{
	{"arcrad", 0.25},
	{"arrowhead", 2.0},
	{"arrowht", 0.08},
	{"arrowwid", 0.06},
	{"boxht", 0.5},
	{"boxrad", 0.0},
	{"boxwid", 0.75},
	{"charht", 0.14},
	{"charwid", 0.08},
	{"circlerad", 0.25},
	{"color", 0.0},
	{"cylht", 0.5},
	{"cylrad", 0.075},
	{"cylwid", 0.75},
	{"dashwid", 0.05},
	{"dotrad", 0.015},
	{"ellipseht", 0.5},
	{"ellipsewid", 0.75},
	{"fileht", 0.75},
	{"filerad", 0.15},
	{"filewid", 0.5},
	{"fill", -1.0},
	{"lineht", 0.5},
	{"linewid", 0.5},
	{"movewid", 0.5},
	{"ovalht", 0.5},
	{"ovalwid", 1.0},
	{"scale", 1.0},
	{"textht", 0.5},
	{"textwid", 0.75},
	{"thickness", 0.015},
}

/* Methods for the "arc" class */
func arcInit(p *Pik, pObj *PObj) {
	pObj.w = p.pik_value("arcrad", nil)
	pObj.h = pObj.w
}

/* Hack: Arcs are here rendered as quadratic Bezier curves rather
** than true arcs.  Multiple reasons: (1) the legacy-PIC parameters
** that control arcs are obscure and I could not figure out what they
** mean based on available documentation.  (2) Arcs are rarely used,
** and so do not seem that important.
 */
func arcControlPoint(cw bool, f PPoint, t PPoint, rScale PNum) PPoint {
	var m PPoint
	var dx, dy PNum
	m.x = 0.5 * (f.x + t.x)
	m.y = 0.5 * (f.y + t.y)
	dx = t.x - f.x
	dy = t.y - f.y
	if cw {
		m.x -= 0.5 * rScale * dy
		m.y += 0.5 * rScale * dx
	} else {
		m.x += 0.5 * rScale * dy
		m.y -= 0.5 * rScale * dx
	}
	return m
}
func arcCheck(p *Pik, pObj *PObj) {
	if p.nTPath > 2 {
		p.pik_error(&pObj.errTok, "arc geometry error")
		return
	}
	m := arcControlPoint(pObj.cw, p.aTPath[0], p.aTPath[1], 0.5)
	pik_bbox_add_xy(&pObj.bbox, m.x, m.y)
}
func arcRender(p *Pik, pObj *PObj) {
	if pObj.nPath < 2 {
		return
	}
	if pObj.sw <= 0.0 {
		return
	}
	f := pObj.aPath[0]
	t := pObj.aPath[1]
	m := arcControlPoint(pObj.cw, f, t, 1.0)
	if pObj.larrow {
		p.pik_draw_arrowhead(&m, &f, pObj)
	}
	if pObj.rarrow {
		p.pik_draw_arrowhead(&m, &t, pObj)
	}
	p.pik_append_xy("<path d=\"M", f.x, f.y)
	p.pik_append_xy("Q", m.x, m.y)
	p.pik_append_xy(" ", t.x, t.y)
	p.pik_append("\" ")
	p.pik_append_style(pObj, 0)
	p.pik_append("\" />\n")

	p.pik_append_txt(pObj, nil)
}

/* Methods for the "arrow" class */
func arrowInit(p *Pik, pObj *PObj) {
	pObj.w = p.pik_value("linewid", nil)
	pObj.h = p.pik_value("lineht", nil)
	pObj.rad = p.pik_value("linerad", nil)
	pObj.rarrow = true
}

/* Methods for the "box" class */
func boxInit(p *Pik, pObj *PObj) {
	pObj.w = p.pik_value("boxwid", nil)
	pObj.h = p.pik_value("boxht", nil)
	pObj.rad = p.pik_value("boxrad", nil)
}

/* Return offset from the center of the box to the compass point
** given by parameter cp */
func boxOffset(p *Pik, pObj *PObj, cp uint8) PPoint {
	pt := PPoint{}
	var w2 PNum = 0.5 * pObj.w
	var h2 PNum = 0.5 * pObj.h
	var rad PNum = pObj.rad
	var rx PNum
	if rad <= 0.0 {
		rx = 0.0
	} else {
		if rad > w2 {
			rad = w2
		}
		if rad > h2 {
			rad = h2
		}
		rx = 0.29289321881345252392 * rad
	}
	switch cp {
	case CP_C:
	case CP_N:
		pt.x = 0.0
		pt.y = h2
	case CP_NE:
		pt.x = w2 - rx
		pt.y = h2 - rx
	case CP_E:
		pt.x = w2
		pt.y = 0.0
	case CP_SE:
		pt.x = w2 - rx
		pt.y = rx - h2
	case CP_S:
		pt.x = 0.0
		pt.y = -h2
	case CP_SW:
		pt.x = rx - w2
		pt.y = rx - h2
	case CP_W:
		pt.x = -w2
		pt.y = 0.0
	case CP_NW:
		pt.x = rx - w2
		pt.y = h2 - rx
	default:
		assert(false, "false")
	}
	return pt
}
func boxChop(p *Pik, pObj *PObj, pPt *PPoint) PPoint {
	var dx, dy PNum
	cp := CP_C
	chop := pObj.ptAt
	if pObj.w <= 0.0 {
		return chop
	}
	if pObj.h <= 0.0 {
		return chop
	}
	dx = (pPt.x - pObj.ptAt.x) * pObj.h / pObj.w
	dy = (pPt.y - pObj.ptAt.y)
	if dx > 0.0 {
		if dy >= 2.414*dx {
			cp = CP_N
		} else if dy >= 0.414*dx {
			cp = CP_NE
		} else if dy >= -0.414*dx {
			cp = CP_E
		} else if dy > -2.414*dx {
			cp = CP_SE
		} else {
			cp = CP_S
		}
	} else {
		if dy >= -2.414*dx {
			cp = CP_N
		} else if dy >= -0.414*dx {
			cp = CP_NW
		} else if dy >= 0.414*dx {
			cp = CP_W
		} else if dy > 2.414*dx {
			cp = CP_SW
		} else {
			cp = CP_S
		}
	}
	chop = pObj.typ.xOffset(p, pObj, cp)
	chop.x += pObj.ptAt.x
	chop.y += pObj.ptAt.y
	return chop
}
func boxFit(p *Pik, pObj *PObj, w PNum, h PNum) {
	if w > 0 {
		pObj.w = w
	}
	if h > 0 {
		pObj.h = h
	}
}
func boxRender(p *Pik, pObj *PObj) {
	var w2 PNum = 0.5 * pObj.w
	var h2 PNum = 0.5 * pObj.h
	rad := pObj.rad
	pt := pObj.ptAt
	if pObj.sw > 0.0 {
		if rad <= 0.0 {
			p.pik_append_xy("<path d=\"M", pt.x-w2, pt.y-h2)
			p.pik_append_xy("L", pt.x+w2, pt.y-h2)
			p.pik_append_xy("L", pt.x+w2, pt.y+h2)
			p.pik_append_xy("L", pt.x-w2, pt.y+h2)
			p.pik_append("Z\" ")
		} else {
			/*
			 **         ----       - y3
			 **        /    \
			 **       /      \     _ y2
			 **      |        |
			 **      |        |    _ y1
			 **       \      /
			 **        \    /
			 **         ----       _ y0
			 **
			 **      '  '  '  '
			 **     x0 x1 x2 x3
			 */
			if rad > w2 {
				rad = w2
			}
			if rad > h2 {
				rad = h2
			}
			var x0 PNum = pt.x - w2
			var x1 PNum = x0 + rad
			var x3 PNum = pt.x + w2
			var x2 PNum = x3 - rad
			var y0 PNum = pt.y - h2
			var y1 PNum = y0 + rad
			var y3 PNum = pt.y + h2
			var y2 PNum = y3 - rad
			p.pik_append_xy("<path d=\"M", x1, y0)
			if x2 > x1 {
				p.pik_append_xy("L", x2, y0)
			}
			p.pik_append_arc(rad, rad, x3, y1)
			if y2 > y1 {
				p.pik_append_xy("L", x3, y2)
			}
			p.pik_append_arc(rad, rad, x2, y3)
			if x2 > x1 {
				p.pik_append_xy("L", x1, y3)
			}
			p.pik_append_arc(rad, rad, x0, y2)
			if y2 > y1 {
				p.pik_append_xy("L", x0, y1)
			}
			p.pik_append_arc(rad, rad, x1, y0)
			p.pik_append("Z\" ")
		}
		p.pik_append_style(pObj, 3)
		p.pik_append("\" />\n")
	}
	p.pik_append_txt(pObj, nil)
}

/* Methods for the "circle" class */
func circleInit(p *Pik, pObj *PObj) {
	pObj.w = p.pik_value("circlerad", nil) * 2
	pObj.h = pObj.w
	pObj.rad = 0.5 * pObj.w
}
func circleNumProp(p *Pik, pObj *PObj, pId *PToken) {
	/* For a circle, the width must equal the height and both must
	 ** be twice the radius.  Enforce those constraints. */
	switch pId.eType {
	case T_DIAMETER, T_RADIUS:
		pObj.w = 2.0 * pObj.rad
		pObj.h = 2.0 * pObj.rad
	case T_WIDTH:
		pObj.h = pObj.w
		pObj.rad = 0.5 * pObj.w
	case T_HEIGHT:
		pObj.w = pObj.h
		pObj.rad = 0.5 * pObj.w
	}
}
func circleChop(p *Pik, pObj *PObj, pPt *PPoint) PPoint {
	var chop PPoint
	var dx PNum = pPt.x - pObj.ptAt.x
	var dy PNum = pPt.y - pObj.ptAt.y
	var dist PNum = math.Hypot(dx, dy)
	if dist < pObj.rad || dist <= 0 {
		return pObj.ptAt
	}
	chop.x = pObj.ptAt.x + dx*pObj.rad/dist
	chop.y = pObj.ptAt.y + dy*pObj.rad/dist
	return chop
}
func circleFit(p *Pik, pObj *PObj, w PNum, h PNum) {
	var mx PNum = 0.0
	if w > 0 {
		mx = w
	}
	if h > mx {
		mx = h
	}
	if w*h > 0 && (w*w+h*h) > mx*mx {
		mx = math.Hypot(w, h)
	}
	if mx > 0.0 {
		pObj.rad = 0.5 * mx
		pObj.w = mx
		pObj.h = mx
	}
}

func circleRender(p *Pik, pObj *PObj) {
	r := pObj.rad
	pt := pObj.ptAt
	if pObj.sw > 0.0 {
		p.pik_append_x("<circle cx=\"", pt.x, "\"")
		p.pik_append_y(" cy=\"", pt.y, "\"")
		p.pik_append_dis(" r=\"", r, "\" ")
		p.pik_append_style(pObj, 3)
		p.pik_append("\" />\n")
	}
	p.pik_append_txt(pObj, nil)
}

/* Methods for the "cylinder" class */
func cylinderInit(p *Pik, pObj *PObj) {
	pObj.w = p.pik_value("cylwid", nil)
	pObj.h = p.pik_value("cylht", nil)
	pObj.rad = p.pik_value("cylrad", nil) /* Minor radius of ellipses */
}
func cylinderFit(p *Pik, pObj *PObj, w PNum, h PNum) {
	if w > 0 {
		pObj.w = w
	}
	if h > 0 {
		pObj.h = h + 0.25*pObj.rad + pObj.sw
	}
}
func cylinderRender(p *Pik, pObj *PObj) {
	var w2 PNum = 0.5 * pObj.w
	var h2 PNum = 0.5 * pObj.h
	rad := pObj.rad
	pt := pObj.ptAt
	if pObj.sw > 0.0 {
		if rad > h2 {
			rad = h2
		} else if rad < 0 {
			rad = 0
		}
		p.pik_append_xy("<path d=\"M", pt.x-w2, pt.y+h2-rad)
		p.pik_append_xy("L", pt.x-w2, pt.y-h2+rad)
		p.pik_append_arc(w2, rad, pt.x+w2, pt.y-h2+rad)
		p.pik_append_xy("L", pt.x+w2, pt.y+h2-rad)
		p.pik_append_arc(w2, rad, pt.x-w2, pt.y+h2-rad)
		p.pik_append_arc(w2, rad, pt.x+w2, pt.y+h2-rad)
		p.pik_append("\" ")
		p.pik_append_style(pObj, 3)
		p.pik_append("\" />\n")
	}
	p.pik_append_txt(pObj, nil)
}
func cylinderOffset(p *Pik, pObj *PObj, cp uint8) PPoint {
	pt := PPoint{}
	var w2 PNum = pObj.w * 0.5
	var h1 PNum = pObj.h * 0.5
	var h2 PNum = h1 - pObj.rad
	switch cp {
	case CP_C:
	case CP_N:
		pt.x = 0.0
		pt.y = h1
	case CP_NE:
		pt.x = w2
		pt.y = h2
	case CP_E:
		pt.x = w2
		pt.y = 0.0
	case CP_SE:
		pt.x = w2
		pt.y = -h2
	case CP_S:
		pt.x = 0.0
		pt.y = -h1
	case CP_SW:
		pt.x = -w2
		pt.y = -h2
	case CP_W:
		pt.x = -w2
		pt.y = 0.0
	case CP_NW:
		pt.x = -w2
		pt.y = h2
	default:
		assert(false, "false")
	}
	return pt
}

/* Methods for the "dot" class */
func dotInit(p *Pik, pObj *PObj) {
	pObj.rad = p.pik_value("dotrad", nil)
	pObj.h = pObj.rad * 6
	pObj.w = pObj.rad * 6
	pObj.fill = pObj.color
}
func dotNumProp(p *Pik, pObj *PObj, pId *PToken) {
	switch pId.eType {
	case T_COLOR:
		pObj.fill = pObj.color
	case T_FILL:
		pObj.color = pObj.fill
	}
}
func dotCheck(p *Pik, pObj *PObj) {
	pObj.w = 0
	pObj.h = 0
	pik_bbox_addellipse(&pObj.bbox, pObj.ptAt.x, pObj.ptAt.y,
		pObj.rad, pObj.rad)
}
func dotOffset(p *Pik, pObj *PObj, cp uint8) PPoint {
	return PPoint{}
}
func dotRender(p *Pik, pObj *PObj) {
	r := pObj.rad
	pt := pObj.ptAt
	if pObj.sw > 0.0 {
		p.pik_append_x("<circle cx=\"", pt.x, "\"")
		p.pik_append_y(" cy=\"", pt.y, "\"")
		p.pik_append_dis(" r=\"", r, "\"")
		p.pik_append_style(pObj, 2)
		p.pik_append("\" />\n")
	}
	p.pik_append_txt(pObj, nil)
}

/* Methods for the "ellipse" class */
func ellipseInit(p *Pik, pObj *PObj) {
	pObj.w = p.pik_value("ellipsewid", nil)
	pObj.h = p.pik_value("ellipseht", nil)
}
func ellipseChop(p *Pik, pObj *PObj, pPt *PPoint) PPoint {
	var chop PPoint
	var s, dq, dist PNum
	var dx PNum = pPt.x - pObj.ptAt.x
	var dy PNum = pPt.y - pObj.ptAt.y
	if pObj.w <= 0.0 {
		return pObj.ptAt
	}
	if pObj.h <= 0.0 {
		return pObj.ptAt
	}
	s = pObj.h / pObj.w
	dq = dx * s
	dist = math.Hypot(dq, dy)
	if dist < pObj.h {
		return pObj.ptAt
	}
	chop.x = pObj.ptAt.x + 0.5*dq*pObj.h/(dist*s)
	chop.y = pObj.ptAt.y + 0.5*dy*pObj.h/dist
	return chop
}
func ellipseOffset(p *Pik, pObj *PObj, cp uint8) PPoint {
	pt := PPoint{}
	var w PNum = pObj.w * 0.5
	var w2 PNum = w * 0.70710678118654747608
	var h PNum = pObj.h * 0.5
	var h2 PNum = h * 0.70710678118654747608
	switch cp {
	case CP_C:
	case CP_N:
		pt.x = 0.0
		pt.y = h
	case CP_NE:
		pt.x = w2
		pt.y = h2
	case CP_E:
		pt.x = w
		pt.y = 0.0
	case CP_SE:
		pt.x = w2
		pt.y = -h2
	case CP_S:
		pt.x = 0.0
		pt.y = -h
	case CP_SW:
		pt.x = -w2
		pt.y = -h2
	case CP_W:
		pt.x = -w
		pt.y = 0.0
	case CP_NW:
		pt.x = -w2
		pt.y = h2
	default:
		assert(false, "false")
	}
	return pt
}
func ellipseRender(p *Pik, pObj *PObj) {
	w := pObj.w
	h := pObj.h
	pt := pObj.ptAt
	if pObj.sw > 0.0 {
		p.pik_append_x("<ellipse cx=\"", pt.x, "\"")
		p.pik_append_y(" cy=\"", pt.y, "\"")
		p.pik_append_dis(" rx=\"", w/2.0, "\"")
		p.pik_append_dis(" ry=\"", h/2.0, "\" ")
		p.pik_append_style(pObj, 3)
		p.pik_append("\" />\n")
	}
	p.pik_append_txt(pObj, nil)
}

/* Methods for the "file" object */
func fileInit(p *Pik, pObj *PObj) {
	pObj.w = p.pik_value("filewid", nil)
	pObj.h = p.pik_value("fileht", nil)
	pObj.rad = p.pik_value("filerad", nil)
}

/* Return offset from the center of the file to the compass point
** given by parameter cp */
func fileOffset(p *Pik, pObj *PObj, cp uint8) PPoint {
	pt := PPoint{}
	var w2 PNum = 0.5 * pObj.w
	var h2 PNum = 0.5 * pObj.h
	var rx PNum = pObj.rad
	mn := h2
	if w2 < h2 {
		mn = w2
	}
	if rx > mn {
		rx = mn
	}
	if rx < mn*0.25 {
		rx = mn * 0.25
	}
	pt.x = 0.0
	pt.y = 0.0
	rx *= 0.5
	switch cp {
	case CP_C:
	case CP_N:
		pt.x = 0.0
		pt.y = h2
	case CP_NE:
		pt.x = w2 - rx
		pt.y = h2 - rx
	case CP_E:
		pt.x = w2
		pt.y = 0.0
	case CP_SE:
		pt.x = w2
		pt.y = -h2
	case CP_S:
		pt.x = 0.0
		pt.y = -h2
	case CP_SW:
		pt.x = -w2
		pt.y = -h2
	case CP_W:
		pt.x = -w2
		pt.y = 0.0
	case CP_NW:
		pt.x = -w2
		pt.y = h2
	default:
		assert(false, "false")
	}
	return pt
}
func fileFit(p *Pik, pObj *PObj, w PNum, h PNum) {
	if w > 0 {
		pObj.w = w
	}
	if h > 0 {
		pObj.h = h + 2*pObj.rad
	}
}
func fileRender(p *Pik, pObj *PObj) {
	var w2 PNum = 0.5 * pObj.w
	var h2 PNum = 0.5 * pObj.h
	rad := pObj.rad
	pt := pObj.ptAt
	mn := h2
	if w2 < h2 {
		mn = w2
	}
	if rad > mn {
		rad = mn
	}
	if rad < mn*0.25 {
		rad = mn * 0.25
	}
	if pObj.sw > 0.0 {
		p.pik_append_xy("<path d=\"M", pt.x-w2, pt.y-h2)
		p.pik_append_xy("L", pt.x+w2, pt.y-h2)
		p.pik_append_xy("L", pt.x+w2, pt.y+(h2-rad))
		p.pik_append_xy("L", pt.x+(w2-rad), pt.y+h2)
		p.pik_append_xy("L", pt.x-w2, pt.y+h2)
		p.pik_append("Z\" ")
		p.pik_append_style(pObj, 1)
		p.pik_append("\" />\n")
		p.pik_append_xy("<path d=\"M", pt.x+(w2-rad), pt.y+h2)
		p.pik_append_xy("L", pt.x+(w2-rad), pt.y+(h2-rad))
		p.pik_append_xy("L", pt.x+w2, pt.y+(h2-rad))
		p.pik_append("\" ")
		p.pik_append_style(pObj, 0)
		p.pik_append("\" />\n")
	}
	p.pik_append_txt(pObj, nil)
}

/* Methods for the "line" class */
func lineInit(p *Pik, pObj *PObj) {
	pObj.w = p.pik_value("linewid", nil)
	pObj.h = p.pik_value("lineht", nil)
	pObj.rad = p.pik_value("linerad", nil)
}
func lineOffset(p *Pik, pObj *PObj, cp uint8) PPoint {
	if false { // #if 0
		/* In legacy PIC, the .center of an unclosed line is half way between
		 ** its .start and .end. */
		if cp == CP_C && !pObj.bClose {
			var out PPoint
			out.x = 0.5*(pObj.ptEnter.x+pObj.ptExit.x) - pObj.ptAt.x
			out.y = 0.5*(pObj.ptEnter.x+pObj.ptExit.y) - pObj.ptAt.y
			return out
		}
	} // #endif
	return boxOffset(p, pObj, cp)
}
func lineRender(p *Pik, pObj *PObj) {
	if pObj.sw > 0.0 {
		z := "<path d=\"M"
		n := pObj.nPath
		if pObj.larrow {
			p.pik_draw_arrowhead(&pObj.aPath[1], &pObj.aPath[0], pObj)
		}
		if pObj.rarrow {
			p.pik_draw_arrowhead(&pObj.aPath[n-2], &pObj.aPath[n-1], pObj)
		}
		for i := 0; i < pObj.nPath; i++ {
			p.pik_append_xy(z, pObj.aPath[i].x, pObj.aPath[i].y)
			z = "L"
		}
		if pObj.bClose {
			p.pik_append("Z")
		} else {
			pObj.fill = -1.0
		}
		p.pik_append("\" ")
		if pObj.bClose {
			p.pik_append_style(pObj, 3)
		} else {
			p.pik_append_style(pObj, 0)
		}
		p.pik_append("\" />\n")
	}
	p.pik_append_txt(pObj, nil)
}

/* Methods for the "move" class */
func moveInit(p *Pik, pObj *PObj) {
	pObj.w = p.pik_value("movewid", nil)
	pObj.h = pObj.w
	pObj.fill = -1.0
	pObj.color = -1.0
	pObj.sw = -1.0
}
func moveRender(p *Pik, pObj *PObj) {
	/* No-op */
}

/* Methods for the "oval" class */
func ovalInit(p *Pik, pObj *PObj) {
	pObj.h = p.pik_value("ovalht", nil)
	pObj.w = p.pik_value("ovalwid", nil)
	if pObj.h < pObj.w {
		pObj.rad = 0.5 * pObj.h
	} else {
		pObj.rad = 0.5 * pObj.w
	}
}
func ovalNumProp(p *Pik, pObj *PObj, pId *PToken) {
	/* Always adjust the radius to be half of the smaller of
	 ** the width and height. */
	if pObj.h < pObj.w {
		pObj.rad = 0.5 * pObj.h
	} else {
		pObj.rad = 0.5 * pObj.w
	}
}
func ovalFit(p *Pik, pObj *PObj, w PNum, h PNum) {
	if w > 0 {
		pObj.w = w
	}
	if h > 0 {
		pObj.h = h
	}
	if pObj.w < pObj.h {
		pObj.w = pObj.h
	}
	if pObj.h < pObj.w {
		pObj.rad = 0.5 * pObj.h
	} else {
		pObj.rad = 0.5 * pObj.w
	}
}

/* Methods for the "spline" class */
func splineInit(p *Pik, pObj *PObj) {
	pObj.w = p.pik_value("linewid", nil)
	pObj.h = p.pik_value("lineht", nil)
	pObj.rad = 1000
}

/* Return a point along the path from "f" to "t" that is r units
** prior to reaching "t", except if the path is less than 2*r total,
** return the midpoint.
 */
func radiusMidpoint(f PPoint, t PPoint, r PNum, pbMid *bool) PPoint {
	var dx PNum = t.x - f.x
	var dy PNum = t.y - f.y
	var dist PNum = math.Hypot(dx, dy)
	if dist <= 0.0 {
		return t
	}
	dx /= dist
	dy /= dist
	if r > 0.5*dist {
		r = 0.5 * dist
		*pbMid = true
	} else {
		*pbMid = false
	}
	return PPoint{
		x: t.x - r*dx,
		y: t.y - r*dy,
	}
}
func (p *Pik) radiusPath(pObj *PObj, r PNum) {
	n := pObj.nPath
	a := pObj.aPath
	an := a[n-1]
	isMid := false
	iLast := n - 1
	if pObj.bClose {
		iLast = n
	}

	p.pik_append_xy("<path d=\"M", a[0].x, a[0].y)
	m := radiusMidpoint(a[0], a[1], r, &isMid)
	p.pik_append_xy(" L ", m.x, m.y)
	for i := 1; i < iLast; i++ {
		an = a[0]
		if i < n-1 {
			an = a[i+1]
		}
		m = radiusMidpoint(an, a[i], r, &isMid)
		p.pik_append_xy(" Q ", a[i].x, a[i].y)
		p.pik_append_xy(" ", m.x, m.y)
		if !isMid {
			m = radiusMidpoint(a[i], an, r, &isMid)
			p.pik_append_xy(" L ", m.x, m.y)
		}
	}
	p.pik_append_xy(" L ", an.x, an.y)
	if pObj.bClose {
		p.pik_append("Z")
	} else {
		pObj.fill = -1.0
	}
	p.pik_append("\" ")
	if pObj.bClose {
		p.pik_append_style(pObj, 3)
	} else {
		p.pik_append_style(pObj, 0)
	}
	p.pik_append("\" />\n")
}
func splineRender(p *Pik, pObj *PObj) {
	if pObj.sw > 0.0 {
		n := pObj.nPath
		r := pObj.rad
		if n < 3 || r <= 0.0 {
			lineRender(p, pObj)
			return
		}
		if pObj.larrow {
			p.pik_draw_arrowhead(&pObj.aPath[1], &pObj.aPath[0], pObj)
		}
		if pObj.rarrow {
			p.pik_draw_arrowhead(&pObj.aPath[n-2], &pObj.aPath[n-1], pObj)
		}
		p.radiusPath(pObj, pObj.rad)
	}
	p.pik_append_txt(pObj, nil)
}

/* Methods for the "text" class */
func textInit(p *Pik, pObj *PObj) {
	p.pik_value("textwid", nil)
	p.pik_value("textht", nil)
	pObj.sw = 0.0
}
func textOffset(p *Pik, pObj *PObj, cp uint8) PPoint {
	/* Automatically slim-down the width and height of text
	 ** statements so that the bounding box tightly encloses the text,
	 ** then get boxOffset() to do the offset computation.
	 */
	p.pik_size_to_fit(&pObj.errTok, 3)
	return boxOffset(p, pObj, cp)
}

/* Methods for the "sublist" class */
func sublistInit(p *Pik, pObj *PObj) {
	pList := pObj.pSublist
	pik_bbox_init(&pObj.bbox)
	for i := 0; i < len(pList); i++ {
		pik_bbox_addbox(&pObj.bbox, &pList[i].bbox)
	}
	pObj.w = pObj.bbox.ne.x - pObj.bbox.sw.x
	pObj.h = pObj.bbox.ne.y - pObj.bbox.sw.y
	pObj.ptAt.x = 0.5 * (pObj.bbox.ne.x + pObj.bbox.sw.x)
	pObj.ptAt.y = 0.5 * (pObj.bbox.ne.y + pObj.bbox.sw.y)
	pObj.mCalc |= A_WIDTH | A_HEIGHT | A_RADIUS
}

/*
** The following array holds all the different kinds of objects.
** The special [] object is separate.
 */
var aClass = []PClass{
	{
		zName:    "arc",
		isLine:   true,
		eJust:    0,
		xInit:    arcInit,
		xNumProp: nil,
		xCheck:   arcCheck,
		xChop:    nil,
		xOffset:  boxOffset,
		xFit:     nil,
		xRender:  arcRender,
	},
	{
		zName:    "arrow",
		isLine:   true,
		eJust:    0,
		xInit:    arrowInit,
		xNumProp: nil,
		xCheck:   nil,
		xChop:    nil,
		xOffset:  lineOffset,
		xFit:     nil,
		xRender:  splineRender,
	},
	{
		zName:    "box",
		isLine:   false,
		eJust:    1,
		xInit:    boxInit,
		xNumProp: nil,
		xCheck:   nil,
		xChop:    boxChop,
		xOffset:  boxOffset,
		xFit:     boxFit,
		xRender:  boxRender,
	},
	{
		zName:    "circle",
		isLine:   false,
		eJust:    0,
		xInit:    circleInit,
		xNumProp: circleNumProp,
		xCheck:   nil,
		xChop:    circleChop,
		xOffset:  ellipseOffset,
		xFit:     circleFit,
		xRender:  circleRender,
	},
	{
		zName:    "cylinder",
		isLine:   false,
		eJust:    1,
		xInit:    cylinderInit,
		xNumProp: nil,
		xCheck:   nil,
		xChop:    boxChop,
		xOffset:  cylinderOffset,
		xFit:     cylinderFit,
		xRender:  cylinderRender,
	},
	{
		zName:    "dot",
		isLine:   false,
		eJust:    0,
		xInit:    dotInit,
		xNumProp: dotNumProp,
		xCheck:   dotCheck,
		xChop:    circleChop,
		xOffset:  dotOffset,
		xFit:     nil,
		xRender:  dotRender,
	},
	{
		zName:    "ellipse",
		isLine:   false,
		eJust:    0,
		xInit:    ellipseInit,
		xNumProp: nil,
		xCheck:   nil,
		xChop:    ellipseChop,
		xOffset:  ellipseOffset,
		xFit:     boxFit,
		xRender:  ellipseRender,
	},
	{
		zName:    "file",
		isLine:   false,
		eJust:    1,
		xInit:    fileInit,
		xNumProp: nil,
		xCheck:   nil,
		xChop:    boxChop,
		xOffset:  fileOffset,
		xFit:     fileFit,
		xRender:  fileRender,
	},
	{
		zName:    "line",
		isLine:   true,
		eJust:    0,
		xInit:    lineInit,
		xNumProp: nil,
		xCheck:   nil,
		xChop:    nil,
		xOffset:  lineOffset,
		xFit:     nil,
		xRender:  splineRender,
	},
	{
		zName:    "move",
		isLine:   true,
		eJust:    0,
		xInit:    moveInit,
		xNumProp: nil,
		xCheck:   nil,
		xChop:    nil,
		xOffset:  boxOffset,
		xFit:     nil,
		xRender:  moveRender,
	},
	{
		zName:    "oval",
		isLine:   false,
		eJust:    1,
		xInit:    ovalInit,
		xNumProp: ovalNumProp,
		xCheck:   nil,
		xChop:    boxChop,
		xOffset:  boxOffset,
		xFit:     ovalFit,
		xRender:  boxRender,
	},
	{
		zName:    "spline",
		isLine:   true,
		eJust:    0,
		xInit:    splineInit,
		xNumProp: nil,
		xCheck:   nil,
		xChop:    nil,
		xOffset:  lineOffset,
		xFit:     nil,
		xRender:  splineRender,
	},
	{
		zName:    "text",
		isLine:   false,
		eJust:    0,
		xInit:    textInit,
		xNumProp: nil,
		xCheck:   nil,
		xChop:    boxChop,
		xOffset:  textOffset,
		xFit:     boxFit,
		xRender:  boxRender,
	},
}
var sublistClass = PClass{
	zName:    "[]",
	isLine:   false,
	eJust:    0,
	xInit:    sublistInit,
	xNumProp: nil,
	xCheck:   nil,
	xChop:    nil,
	xOffset:  boxOffset,
	xFit:     nil,
	xRender:  nil,
}
var noopClass = PClass{
	zName:    "noop",
	isLine:   false,
	eJust:    0,
	xInit:    nil,
	xNumProp: nil,
	xCheck:   nil,
	xChop:    nil,
	xOffset:  boxOffset,
	xFit:     nil,
	xRender:  nil,
}

/*
** Reduce the length of the line segment by amt (if possible) by
** modifying the location of *t.
 */
func pik_chop(f *PPoint, t *PPoint, amt PNum) {
	var dx PNum = t.x - f.x
	var dy PNum = t.y - f.y
	var dist PNum = math.Hypot(dx, dy)
	if dist <= amt {
		*t = *f
		return
	}
	var r PNum = 1.0 - amt/dist
	t.x = f.x + r*dx
	t.y = f.y + r*dy
}

/*
** Draw an arrowhead on the end of the line segment from pFrom to pTo.
** Also, shorten the line segment (by changing the value of pTo) so that
** the shaft of the arrow does not extend into the arrowhead.
 */
func (p *Pik) pik_draw_arrowhead(f *PPoint, t *PPoint, pObj *PObj) {
	var dx PNum = t.x - f.x
	var dy PNum = t.y - f.y
	var dist PNum = math.Hypot(dx, dy)
	var h PNum = p.hArrow * pObj.sw
	var w PNum = p.wArrow * pObj.sw
	if pObj.color < 0.0 {
		return
	}
	if pObj.sw <= 0.0 {
		return
	}
	if dist <= 0.0 {
		return
	} /* Unable */
	dx /= dist
	dy /= dist
	var e1 PNum = dist - h
	if e1 < 0.0 {
		e1 = 0.0
		h = dist
	}
	var ddx PNum = -w * dy
	var ddy PNum = w * dx
	var bx PNum = f.x + e1*dx
	var by PNum = f.y + e1*dy
	p.pik_append_xy("<polygon points=\"", t.x, t.y)
	p.pik_append_xy(" ", bx-ddx, by-ddy)
	p.pik_append_xy(" ", bx+ddx, by+ddy)
	p.pik_append_clr("\" style=\"fill:", pObj.color, "\"/>\n", false)
	pik_chop(f, t, h/2)
}

/*
** Compute the relative offset to an edge location from the reference for a
** an statement.
 */
func (p *Pik) pik_elem_offset(pObj *PObj, cp uint8) PPoint {
	return pObj.typ.xOffset(p, pObj, cp)
}

/*
** Append raw text to zOut
 */
func (p *Pik) pik_append(zText string) {
	p.zOut.WriteString(zText)
}

var ampersand_entity_re = regexp.MustCompile(`^&(?:#[0-9]{2,}|[a-zA-Z]{2,});`)

/*
** Given a string, returns true if the string begins
** with a construct which syntactically matches an HTML entity escape
** sequence (without checking for whether it's a known entity). Always
** returns false if zText[0] is false or n<4. Entities match the
** equivalent of the regexes `&#[0-9]+;` and `&[a-zA-Z]+;`.
 */
func pik_isentity(zText string) bool {
	return ampersand_entity_re.MatchString(zText)
}

var html_re_with_space = regexp.MustCompile(`[<> ]`)

/*
** Append text to zOut with HTML characters escaped.
**
**   *  The space character is changed into non-breaking space (U+00a0)
**      if mFlags has the 0x01 bit set. This is needed when outputting
**      text to preserve leading and trailing whitespace.  Turns out we
**      cannot use &nbsp; as that is an HTML-ism and is not valid in XML.
**
**   *  The "&" character is changed into "&amp;" if mFlags has the
**      0x02 bit set.  This is needed when generating error message text.
**
**   *  Except for the above, only "<" and ">" are escaped.
 */
func (p *Pik) pik_append_text(zText string, mFlags int) {
	bQSpace := mFlags&1 > 0
	bQAmp := mFlags&2 > 0

	text := html_re_with_space.ReplaceAllStringFunc(zText, func(s string) string {
		switch {
		case s == "<":
			return "&lt;"
		case s == ">":
			return "&gt;"
		case s == " " && bQSpace:
			return "\302\240"
		default:
			return s
		}
	})
	if !bQAmp {
		p.pik_append(text)
	} else {
		pieces := strings.Split(text, "&")
		p.pik_append(pieces[0])
		for _, piece := range pieces[1:] {
			if pik_isentity("&" + piece) {
				p.pik_append("&")
			} else {
				p.pik_append("&amp;")
			}
			p.pik_append(piece)
		}
	}
}

/*
** Append error message text.  This is either a raw append, or an append
** with HTML escapes, depending on whether the PIKCHR_PLAINTEXT_ERRORS flag
** is set.
 */
func (p *Pik) pik_append_errtxt(zText string) {
	if p.mFlags&PIKCHR_PLAINTEXT_ERRORS != 0 {
		p.pik_append(zText)
	} else {
		p.pik_append_text(zText, 0)
	}
}

/* Append a PNum value
 */
func (p *Pik) pik_append_num(z string, v PNum) {
	p.pik_append(z)
	p.pik_append(fmt.Sprintf("%.10g", v))
}

/* Append a PPoint value  (Used for debugging only)
 */
func (p *Pik) pik_append_point(z string, pPt *PPoint) {
	buf := fmt.Sprintf("%.10g,%.10g", pPt.x, pPt.y)
	p.pik_append(z)
	p.pik_append(buf)
}

/*
** Invert the RGB color so that it is appropriate for dark mode.
** Variable x hold the initial color.  The color is intended for use
** as a background color if isBg is true, and as a foreground color
** if isBg is false.
 */
func pik_color_to_dark_mode(x int, isBg bool) int {
	x = 0xffffff - x
	r := (x >> 16) & 0xff
	g := (x >> 8) & 0xff
	b := x & 0xff
	mx := r
	if g > mx {
		mx = g
	}
	if b > mx {
		mx = b
	}
	mn := r
	if g < mn {
		mn = g
	}
	if b < mn {
		mn = b
	}
	r = mn + (mx - r)
	g = mn + (mx - g)
	b = mn + (mx - b)
	if isBg {
		if mx > 127 {
			r = (127 * r) / mx
			g = (127 * g) / mx
			b = (127 * b) / mx
		}
	} else {
		if mn < 128 && mx > mn {
			r = 127 + ((r-mn)*128)/(mx-mn)
			g = 127 + ((g-mn)*128)/(mx-mn)
			b = 127 + ((b-mn)*128)/(mx-mn)
		}
	}
	return r*0x10000 + g*0x100 + b
}

/* Append a PNum value surrounded by text.  Do coordinate transformations
** on the value.
 */
func (p *Pik) pik_append_x(z1 string, v PNum, z2 string) {
	v -= p.bbox.sw.x
	p.pik_append(fmt.Sprintf("%s%d%s", z1, pik_round(p.rScale*v), z2))
}
func (p *Pik) pik_append_y(z1 string, v PNum, z2 string) {
	v = p.bbox.ne.y - v
	p.pik_append(fmt.Sprintf("%s%d%s", z1, pik_round(p.rScale*v), z2))
}
func (p *Pik) pik_append_xy(z1 string, x PNum, y PNum) {
	x = x - p.bbox.sw.x
	y = p.bbox.ne.y - y
	p.pik_append(fmt.Sprintf("%s%d,%d", z1, pik_round(p.rScale*x), pik_round(p.rScale*y)))
}
func (p *Pik) pik_append_dis(z1 string, v PNum, z2 string) {
	p.pik_append(fmt.Sprintf("%s%.6g%s", z1, p.rScale*v, z2))
}

/* Append a color specification to the output.
**
** In PIKCHR_DARK_MODE, the color is inverted.  The "bg" flags indicates that
** the color is intended for use as a background color if true, or as a
** foreground color if false.  The distinction only matters for color
** inversions in PIKCHR_DARK_MODE.
 */
func (p *Pik) pik_append_clr(z1 string, v PNum, z2 string, bg bool) {
	x := pik_round(v)
	if x == 0 && p.fgcolor > 0 && !bg {
		x = p.fgcolor
	} else if bg && x >= 0xffffff && p.bgcolor > 0 {
		x = p.bgcolor
	} else if p.mFlags&PIKCHR_DARK_MODE != 0 {
		x = pik_color_to_dark_mode(x, bg)
	}
	r := (x >> 16) & 0xff
	g := (x >> 8) & 0xff
	b := x & 0xff
	buf := fmt.Sprintf("%srgb(%d,%d,%d)%s", z1, r, g, b, z2)
	p.pik_append(buf)
}

/* Append an SVG path A record:
**
**    A r1 r2 0 0 0 x y
 */
func (p *Pik) pik_append_arc(r1 PNum, r2 PNum, x PNum, y PNum) {
	x = x - p.bbox.sw.x
	y = p.bbox.ne.y - y
	buf := fmt.Sprintf("A%d %d 0 0 0 %d %d",
		pik_round(p.rScale*r1), pik_round(p.rScale*r2),
		pik_round(p.rScale*x), pik_round(p.rScale*y))
	p.pik_append(buf)
}

/* Append a style="..." text.  But, leave the quote unterminated, in case
** the caller wants to add some more.
**
** eFill is non-zero to fill in the background, or 0 if no fill should
** occur.  Non-zero values of eFill determine the "bg" flag to pik_append_clr()
** for cases when pObj.fill==pObj.color
**
**     1        fill is background, and color is foreground.
**     2        fill and color are both foreground.  (Used by "dot" objects)
**     3        fill and color are both background.  (Used by most other objs)
 */
func (p *Pik) pik_append_style(pObj *PObj, eFill int) {
	clrIsBg := false
	p.pik_append(" style=\"")
	if pObj.fill >= 0 && eFill != 0 {
		fillIsBg := true
		if pObj.fill == pObj.color {
			if eFill == 2 {
				fillIsBg = false
			}
			if eFill == 3 {
				clrIsBg = true
			}
		}
		p.pik_append_clr("fill:", pObj.fill, ";", fillIsBg)
	} else {
		p.pik_append("fill:none;")
	}
	if pObj.sw > 0.0 && pObj.color >= 0.0 {
		sw := pObj.sw
		p.pik_append_dis("stroke-width:", sw, ";")
		if pObj.nPath > 2 && pObj.rad <= pObj.sw {
			p.pik_append("stroke-linejoin:round;")
		}
		p.pik_append_clr("stroke:", pObj.color, ";", clrIsBg)
		if pObj.dotted > 0.0 {
			v := pObj.dotted
			if sw < 2.1/p.rScale {
				sw = 2.1 / p.rScale
			}
			p.pik_append_dis("stroke-dasharray:", sw, "")
			p.pik_append_dis(",", v, ";")
		} else if pObj.dashed > 0.0 {
			v := pObj.dashed
			p.pik_append_dis("stroke-dasharray:", v, "")
			p.pik_append_dis(",", v, ";")
		}
	}
}

/*
** Compute the vertical locations for all text items in the
** object pObj.  In other words, set every pObj.aTxt[*].eCode
** value to contain exactly one of: TP_ABOVE2, TP_ABOVE, TP_CENTER,
** TP_BELOW, or TP_BELOW2 is set.
 */
func pik_txt_vertical_layout(pObj *PObj) {
	n := int(pObj.nTxt)
	if n == 0 {
		return
	}
	aTxt := pObj.aTxt[:]
	if n == 1 {
		if (aTxt[0].eCode & TP_VMASK) == 0 {
			aTxt[0].eCode |= TP_CENTER
		}
	} else {
		allSlots := int16(0)
		var aFree [5]int16
		var iSlot int
		/* If there is more than one TP_ABOVE, change the first to TP_ABOVE2. */
		for j, mJust, i := 0, int16(0), n-1; i >= 0; i-- {
			if aTxt[i].eCode&TP_ABOVE != 0 {
				if j == 0 {
					j++
					mJust = aTxt[i].eCode & TP_JMASK
				} else if j == 1 && mJust != 0 && (aTxt[i].eCode&mJust) == 0 {
					j++
				} else {
					aTxt[i].eCode = (aTxt[i].eCode &^ TP_VMASK) | TP_ABOVE2
					break
				}
			}
		}
		/* If there is more than one TP_BELOW, change the last to TP_BELOW2 */
		for j, mJust, i := 0, int16(0), 0; i < n; i++ {
			if aTxt[i].eCode&TP_BELOW != 0 {
				if j == 0 {
					j++
					mJust = aTxt[i].eCode & TP_JMASK
				} else if j == 1 && mJust != 0 && (aTxt[i].eCode&mJust) == 0 {
					j++
				} else {
					aTxt[i].eCode = (aTxt[i].eCode &^ TP_VMASK) | TP_BELOW2
					break
				}
			}
		}
		/* Compute a mask of all slots used */
		for i := 0; i < n; i++ {
			allSlots |= aTxt[i].eCode & TP_VMASK
		}
		/* Set of an array of available slots */
		if n == 2 && ((aTxt[0].eCode|aTxt[1].eCode)&TP_JMASK) == (TP_LJUST|TP_RJUST) {
			/* Special case of two texts that have opposite justification:
			 ** Allow them both to float to center. */
			iSlot = 2
			aFree[0] = TP_CENTER
			aFree[1] = TP_CENTER
		} else {
			/* Set up the arrow so that available slots are filled from top to
			 ** bottom */
			iSlot = 0
			if n >= 4 && (allSlots&TP_ABOVE2) == 0 {
				aFree[iSlot] = TP_ABOVE2
				iSlot++
			}
			if (allSlots & TP_ABOVE) == 0 {
				aFree[iSlot] = TP_ABOVE
				iSlot++
			}
			if (n & 1) != 0 {
				aFree[iSlot] = TP_CENTER
				iSlot++
			}
			if (allSlots & TP_BELOW) == 0 {
				aFree[iSlot] = TP_BELOW
				iSlot++
			}
			if n >= 4 && (allSlots&TP_BELOW2) == 0 {
				aFree[iSlot] = TP_BELOW2
				iSlot++
			}
		}
		/* Set the VMASK for all unassigned texts */
		for i, iSlot := 0, 0; i < n; i++ {
			if (aTxt[i].eCode & TP_VMASK) == 0 {
				aTxt[i].eCode |= aFree[iSlot]
				iSlot++
			}
		}
	}
}

/* Return the font scaling factor associated with the input text attribute.
 */
func pik_font_scale(t PToken) PNum {
	var scale PNum = 1.0
	if t.eCode&TP_BIG != 0 {
		scale *= 1.25
	}
	if t.eCode&TP_SMALL != 0 {
		scale *= 0.8
	}
	if t.eCode&TP_XTRA != 0 {
		scale *= scale
	}
	return scale
}

/* Append multiple <text> SVG elements for the text fields of the PObj.
** Parameters:
**
**    p          The Pik object into which we are rendering
**
**    pObj       Object containing the text to be rendered
**
**    pBox       If not NULL, do no rendering at all.  Instead
**               expand the box object so that it will include all
**               of the text.
 */
func (p *Pik) pik_append_txt(pObj *PObj, pBox *PBox) {
	var jw PNum        /* Justification margin relative to center */
	var ha2 PNum = 0.0 /* Height of the top row of text */
	var ha1 PNum = 0.0 /* Height of the second "above" row */
	var hc PNum = 0.0  /* Height of the center row */
	var hb1 PNum = 0.0 /* Height of the first "below" row of text */
	var hb2 PNum = 0.0 /* Height of the second "below" row */
	var yBase PNum = 0.0
	allMask := int16(0)

	if p.nErr != 0 {
		return
	}
	if pObj.nTxt == 0 {
		return
	}
	aTxt := pObj.aTxt[:]
	n := int(pObj.nTxt)
	pik_txt_vertical_layout(pObj)
	x := pObj.ptAt.x
	for i := 0; i < n; i++ {
		allMask |= pObj.aTxt[i].eCode
	}
	if pObj.typ.isLine {
		hc = pObj.sw * 1.5
	} else if pObj.rad > 0.0 && pObj.typ.zName == "cylinder" {
		yBase = -0.75 * pObj.rad
	}
	if allMask&TP_CENTER != 0 {
		for i := 0; i < n; i++ {
			if pObj.aTxt[i].eCode&TP_CENTER != 0 {
				s := pik_font_scale(pObj.aTxt[i])
				if hc < s*p.charHeight {
					hc = s * p.charHeight
				}
			}
		}
	}
	if allMask&TP_ABOVE != 0 {
		for i := 0; i < n; i++ {
			if pObj.aTxt[i].eCode&TP_ABOVE != 0 {
				s := pik_font_scale(pObj.aTxt[i]) * p.charHeight
				if ha1 < s {
					ha1 = s
				}
			}
		}
		if allMask&TP_ABOVE2 != 0 {
			for i := 0; i < n; i++ {
				if pObj.aTxt[i].eCode&TP_ABOVE2 != 0 {
					s := pik_font_scale(pObj.aTxt[i]) * p.charHeight
					if ha2 < s {
						ha2 = s
					}
				}
			}
		}
	}
	if allMask&TP_BELOW != 0 {
		for i := 0; i < n; i++ {
			if pObj.aTxt[i].eCode&TP_BELOW != 0 {
				s := pik_font_scale(pObj.aTxt[i]) * p.charHeight
				if hb1 < s {
					hb1 = s
				}
			}
		}
		if allMask&TP_BELOW2 != 0 {
			for i := 0; i < n; i++ {
				if pObj.aTxt[i].eCode&TP_BELOW2 != 0 {
					s := pik_font_scale(pObj.aTxt[i]) * p.charHeight
					if hb2 < s {
						hb2 = s
					}
				}
			}
		}
	}
	if pObj.typ.eJust == 1 {
		jw = 0.5 * (pObj.w - 0.5*(p.charWidth+pObj.sw))
	} else {
		jw = 0.0
	}
	for i := 0; i < n; i++ {
		t := aTxt[i]
		xtraFontScale := pik_font_scale(t)
		var nx PNum = 0
		orig_y := pObj.ptAt.y
		y := yBase
		if t.eCode&TP_ABOVE2 != 0 {
			y += 0.5*hc + ha1 + 0.5*ha2
		}
		if t.eCode&TP_ABOVE != 0 {
			y += 0.5*hc + 0.5*ha1
		}
		if t.eCode&TP_BELOW != 0 {
			y -= 0.5*hc + 0.5*hb1
		}
		if t.eCode&TP_BELOW2 != 0 {
			y -= 0.5*hc + hb1 + 0.5*hb2
		}
		if t.eCode&TP_LJUST != 0 {
			nx -= jw
		}
		if t.eCode&TP_RJUST != 0 {
			nx += jw
		}

		if pBox != nil {
			/* If pBox is not NULL, do not draw any <text>.  Instead, just expand
			 ** pBox to include the text */
			var cw PNum = PNum(pik_text_length(t)) * p.charWidth * xtraFontScale * 0.01
			var ch PNum = p.charHeight * 0.5 * xtraFontScale
			var x0, y0, x1, y1 PNum /* Boundary of text relative to pObj.ptAt */
			if t.eCode&TP_BOLD != 0 {
				cw *= 1.1
			}
			if t.eCode&TP_RJUST != 0 {
				x0 = nx
				y0 = y - ch
				x1 = nx - cw
				y1 = y + ch
			} else if t.eCode&TP_LJUST != 0 {
				x0 = nx
				y0 = y - ch
				x1 = nx + cw
				y1 = y + ch
			} else {
				x0 = nx + cw/2
				y0 = y + ch
				x1 = nx - cw/2
				y1 = y - ch
			}
			if (t.eCode&TP_ALIGN) != 0 && pObj.nPath >= 2 {
				nn := pObj.nPath
				var dx PNum = pObj.aPath[nn-1].x - pObj.aPath[0].x
				var dy PNum = pObj.aPath[nn-1].y - pObj.aPath[0].y
				if dx != 0 || dy != 0 {
					var dist PNum = math.Hypot(dx, dy)
					var tt PNum
					dx /= dist
					dy /= dist
					tt = dx*x0 - dy*y0
					y0 = dy*x0 - dx*y0
					x0 = tt
					tt = dx*x1 - dy*y1
					y1 = dy*x1 - dx*y1
					x1 = tt
				}
			}
			pik_bbox_add_xy(pBox, x+x0, orig_y+y0)
			pik_bbox_add_xy(pBox, x+x1, orig_y+y1)
			continue
		}
		nx += x
		y += orig_y

		p.pik_append_x("<text x=\"", nx, "\"")
		p.pik_append_y(" y=\"", y, "\"")
		if t.eCode&TP_RJUST != 0 {
			p.pik_append(" text-anchor=\"end\"")
		} else if t.eCode&TP_LJUST != 0 {
			p.pik_append(" text-anchor=\"start\"")
		} else {
			p.pik_append(" text-anchor=\"middle\"")
		}
		if t.eCode&TP_ITALIC != 0 {
			p.pik_append(" font-style=\"italic\"")
		}
		if t.eCode&TP_BOLD != 0 {
			p.pik_append(" font-weight=\"bold\"")
		}
		if pObj.color >= 0.0 {
			p.pik_append_clr(" fill=\"", pObj.color, "\"", false)
		}
		xtraFontScale *= p.fontScale
		if xtraFontScale <= 0.99 || xtraFontScale >= 1.01 {
			p.pik_append_num(" font-size=\"", xtraFontScale*100.0)
			p.pik_append("%\"")
		}
		if (t.eCode&TP_ALIGN) != 0 && pObj.nPath >= 2 {
			nn := pObj.nPath
			var dx PNum = pObj.aPath[nn-1].x - pObj.aPath[0].x
			var dy PNum = pObj.aPath[nn-1].y - pObj.aPath[0].y
			if dx != 0 || dy != 0 {
				var ang PNum = math.Atan2(dy, dx) * -180 / math.Pi
				p.pik_append_num(" transform=\"rotate(", ang)
				p.pik_append_xy(" ", x, orig_y)
				p.pik_append(")\"")
			}
		}
		p.pik_append(" dominant-baseline=\"central\">")
		var z []byte
		var nz int
		if t.n >= 2 && t.z[0] == '"' {
			z = t.z[1:]
			nz = t.n - 2
		} else {
			z = t.z
			nz = t.n
		}
		for nz > 0 {
			var j int
			for j = 0; j < nz && z[j] != '\\'; j++ {
			}
			if j != 0 {
				p.pik_append_text(string(z[:j]), 0x3)
			}
			if j < nz && (j+1 == nz || z[j+1] == '\\') {
				p.pik_append("&#92;")
				j++
			}
			nz -= j + 1
			if nz > 0 {
				z = z[j+1:]
			}
		}
		p.pik_append("</text>\n")
	}
}

/*
** Append text (that will go inside of a <pre>...</pre>) that
** shows the context of an error token.
 */
func (p *Pik) pik_error_context(pErr *PToken, nContext int) {
	var (
		iErrPt       int /* Index of first byte of error from start of input */
		iErrCol      int /* Column of the error token on its line */
		iStart       int /* Start position of the error context */
		iEnd         int /* End position of the error context */
		iLineno      int /* Line number of the error */
		iFirstLineno int /* Line number of start of error context */
		i            int /* Loop counter */
		iBump        = 0 /* Bump the location of the error cursor */
	)

	iErrPt = len(p.sIn.z) - len(pErr.z) // in C, uses pointer math: iErrPt = (int)(pErr->z - p->sIn.z);
	if iErrPt >= p.sIn.n {
		iErrPt = p.sIn.n - 1
		iBump = 1
	} else {
		for iErrPt > 0 && (p.sIn.z[iErrPt] == '\n' || p.sIn.z[iErrPt] == '\r') {
			iErrPt--
			iBump = 1
		}
	}
	iLineno = 1
	for i = 0; i < iErrPt; i++ {
		if p.sIn.z[i] == '\n' {
			iLineno++
		}
	}
	iStart = 0
	iFirstLineno = 1
	for iFirstLineno+nContext < iLineno {
		for p.sIn.z[iStart] != '\n' {
			iStart++
		}
		iStart++
		iFirstLineno++
	}
	for iEnd = iErrPt; p.sIn.z[iEnd] != 0 && p.sIn.z[iEnd] != '\n'; iEnd++ {
	}
	i = iStart
	for iFirstLineno <= iLineno {
		zLineno := fmt.Sprintf("/* %4d */  ", iFirstLineno)
		iFirstLineno++
		p.pik_append(zLineno)
		for i = iStart; p.sIn.z[i] != 0 && p.sIn.z[i] != '\n'; i++ {
		}
		p.pik_append_errtxt(string(p.sIn.z[iStart:i]))
		iStart = i + 1
		p.pik_append("\n")
	}
	for iErrCol, i = 0, iErrPt; i > 0 && p.sIn.z[i] != '\n'; iErrCol, i = iErrCol+1, i-1 {
	}
	for i = 0; i < iErrCol+11+iBump; i++ {
		p.pik_append(" ")
	}
	for i = 0; i < pErr.n; i++ {
		p.pik_append("^")
	}
	p.pik_append("\n")
}

/*
** Generate an error message for the output.  pErr is the token at which
** the error should point.  zMsg is the text of the error message. If
** either pErr or zMsg is NULL, generate an out-of-memory error message.
**
** This routine is a no-op if there has already been an error reported.
 */
func (p *Pik) pik_error(pErr *PToken, zMsg string) {
	if p == nil {
		return
	}
	if p.nErr > 0 {
		return
	}
	p.nErr++
	if zMsg == "" {
		if p.mFlags&PIKCHR_PLAINTEXT_ERRORS != 0 {
			p.pik_append("\nOut of memory\n")
		} else {
			p.pik_append("\n<div><p>Out of memory</p></div>\n")
		}
		return
	}
	if pErr == nil {
		p.pik_append("\n")
		p.pik_append_errtxt(zMsg)
		return
	}
	if (p.mFlags & PIKCHR_PLAINTEXT_ERRORS) == 0 {
		p.pik_append("<div><pre>\n")
	}
	p.pik_error_context(pErr, 5)
	p.pik_append("ERROR: ")
	p.pik_append_errtxt(zMsg)
	p.pik_append("\n")
	for i := p.nCtx - 1; i >= 0; i-- {
		p.pik_append("Called from:\n")
		p.pik_error_context(&p.aCtx[i], 0)
	}
	if (p.mFlags & PIKCHR_PLAINTEXT_ERRORS) == 0 {
		p.pik_append("</pre></div>\n")
	}
}

/*
 ** Process an "assert( e1 == e2 )" statement.  Always return `nil`.
 */
func (p *Pik) pik_assert(e1 PNum, pEq *PToken, e2 PNum) *PObj {
	/* Convert the numbers to strings using %g for comparison.  This
	 ** limits the precision of the comparison to account for rounding error. */
	zE1 := fmt.Sprintf("%g", e1)
	zE2 := fmt.Sprintf("%g", e2)
	if zE1 != zE2 {
		p.pik_error(pEq, fmt.Sprintf("%.50s != %.50s", zE1, zE2))
	}
	return nil
}

/*
** Process an "assert( place1 == place2 )" statement.  Always return `nil`.
 */
func (p *Pik) pik_position_assert(e1 *PPoint, pEq *PToken, e2 *PPoint) *PObj {
	/* Convert the numbers to strings using %g for comparison.  This
	 ** limits the precision of the comparison to account for rounding error. */
	zE1 := fmt.Sprintf("(%g,%g)", e1.x, e1.y)
	zE2 := fmt.Sprintf("(%g,%g)", e2.x, e2.y)
	if zE1 != zE2 {
		p.pik_error(pEq, fmt.Sprintf("%s != %s", zE1, zE2))
	}
	return nil
}

/* Free a complete list of objects */
func (p *Pik) pik_elist_free(pList *PList) {
	if pList == nil || *pList == nil {
		return
	}
	for i := 0; i < len(*pList); i++ {
		p.pik_elem_free((*pList)[i])
	}
}

/* Free a single object, and its substructure */
func (p *Pik) pik_elem_free(pObj *PObj) {
	if pObj == nil {
		return
	}
	p.pik_elist_free(&pObj.pSublist)
}

/* Convert a numeric literal into a number.  Return that number.
** There is no error handling because the tokenizer has already
** assured us that the numeric literal is valid.
**
** Allowed number forms:
**
**   (1)    Floating point literal
**   (2)    Same as (1) but followed by a unit: "cm", "mm", "in",
**          "px", "pt", or "pc".
**   (3)    Hex integers: 0x000000
**
** This routine returns the result in inches.  If a different unit
** is specified, the conversion happens automatically.
 */
func pik_atof(num *PToken) PNum {
	if num.n >= 3 && num.z[0] == '0' && (num.z[1] == 'x' || num.z[1] == 'X') {
		i, err := strconv.ParseInt(string(num.z[2:num.n]), 16, 64)
		if err != nil {
			return 0
		}
		return PNum(i)
	}
	factor := 1.0

	z := num.String()

	if num.n > 2 {
		hasSuffix := true
		switch string(num.z[num.n-2 : num.n]) {
		case "cm":
			factor = 1 / 2.54
		case "mm":
			factor = 1 / 25.4
		case "px":
			factor = 1 / 96.0
		case "pt":
			factor = 1 / 72.0
		case "pc":
			factor = 1 / 6.0
		case "in":
			factor = 1.0
		default:
			hasSuffix = false
		}
		if hasSuffix {
			z = z[:len(z)-2]
		}
	}

	ans, err := strconv.ParseFloat(z, 64)
	ans *= factor
	if err != nil {
		return 0.0
	}
	return PNum(ans)
}

/*
** Compute the distance between two points
 */
func pik_dist(pA *PPoint, pB *PPoint) PNum {
	dx := pB.x - pA.x
	dy := pB.y - pA.y
	return math.Hypot(dx, dy)
}

/* Return true if a bounding box is empty.
 */
func pik_bbox_isempty(p *PBox) bool {
	return p.sw.x > p.ne.x
}

/* Return true if point pPt is contained within the bounding box pBox
 */
func pik_bbox_contains_point(pBox *PBox, pPt *PPoint) bool {
	if pik_bbox_isempty(pBox) {
		return false
	}
	if pPt.x < pBox.sw.x {
		return false
	}
	if pPt.x > pBox.ne.x {
		return false
	}
	if pPt.y < pBox.sw.y {
		return false
	}
	if pPt.y > pBox.ne.y {
		return false
	}
	return true
}

/* Initialize a bounding box to an empty container
 */
func pik_bbox_init(p *PBox) {
	p.sw.x = 1.0
	p.sw.y = 1.0
	p.ne.x = 0.0
	p.ne.y = 0.0
}

/* Enlarge the PBox of the first argument so that it fully
** covers the second PBox
 */
func pik_bbox_addbox(pA *PBox, pB *PBox) {
	if pik_bbox_isempty(pA) {
		*pA = *pB
	}
	if pik_bbox_isempty(pB) {
		return
	}
	if pA.sw.x > pB.sw.x {
		pA.sw.x = pB.sw.x
	}
	if pA.sw.y > pB.sw.y {
		pA.sw.y = pB.sw.y
	}
	if pA.ne.x < pB.ne.x {
		pA.ne.x = pB.ne.x
	}
	if pA.ne.y < pB.ne.y {
		pA.ne.y = pB.ne.y
	}
}

/* Enlarge the PBox of the first argument, if necessary, so that
** it contains the point described by the 2nd and 3rd arguments.
 */
func pik_bbox_add_xy(pA *PBox, x PNum, y PNum) {
	if pik_bbox_isempty(pA) {
		pA.ne.x = x
		pA.ne.y = y
		pA.sw.x = x
		pA.sw.y = y
		return
	}
	if pA.sw.x > x {
		pA.sw.x = x
	}
	if pA.sw.y > y {
		pA.sw.y = y
	}
	if pA.ne.x < x {
		pA.ne.x = x
	}
	if pA.ne.y < y {
		pA.ne.y = y
	}
}

/* Enlarge the PBox so that it is able to contain an ellipse
** centered at x,y and with radiuses rx and ry.
 */
func pik_bbox_addellipse(pA *PBox, x PNum, y PNum, rx PNum, ry PNum) {
	if pik_bbox_isempty(pA) {
		pA.ne.x = x + rx
		pA.ne.y = y + ry
		pA.sw.x = x - rx
		pA.sw.y = y - ry
		return
	}
	if pA.sw.x > x-rx {
		pA.sw.x = x - rx
	}
	if pA.sw.y > y-ry {
		pA.sw.y = y - ry
	}
	if pA.ne.x < x+rx {
		pA.ne.x = x + rx
	}
	if pA.ne.y < y+ry {
		pA.ne.y = y + ry
	}
}

/* Append a new object onto the end of an object list.  The
** object list is created if it does not already exist.  Return
** the new object list.
 */
func (p *Pik) pik_elist_append(pList PList, pObj *PObj) PList {
	if pObj == nil {
		return pList
	}
	pList = append(pList, pObj)
	p.list = pList
	return pList
}

/* Convert an object class name into a PClass pointer
 */
func pik_find_class(pId *PToken) *PClass {
	zString := pId.String()
	first := 0
	last := len(aClass) - 1
	for {
		mid := (first + last) / 2
		c := strings.Compare(aClass[mid].zName, zString)
		if c == 0 {
			return &aClass[mid]
		}
		if c < 0 {
			first = mid + 1
		} else {
			last = mid - 1
		}

		if first > last {
			return nil
		}
	}
}

/* Allocate and return a new PObj object.
**
** If pId!=0 then pId is an identifier that defines the object class.
** If pStr!=0 then it is a STRING literal that defines a text object.
** If pSublist!=0 then this is a [...] object. If all three parameters
** are NULL then this is a no-op object used to define a PLACENAME.
 */
func (p *Pik) pik_elem_new(pId *PToken, pStr *PToken, pSublist PList) *PObj {
	miss := false
	if p.nErr != 0 {
		return nil
	}
	pNew := &PObj{}

	p.cur = pNew
	p.nTPath = 1
	p.thenFlag = false
	if len(p.list) == 0 {
		pNew.ptAt.x = 0.0
		pNew.ptAt.y = 0.0
		pNew.eWith = CP_C
	} else {
		pPrior := p.list[len(p.list)-1]
		pNew.ptAt = pPrior.ptExit
		switch p.eDir {
		default:
			pNew.eWith = CP_W
		case DIR_LEFT:
			pNew.eWith = CP_E
		case DIR_UP:
			pNew.eWith = CP_S
		case DIR_DOWN:
			pNew.eWith = CP_N
		}
	}
	p.aTPath[0] = pNew.ptAt
	pNew.with = pNew.ptAt
	pNew.outDir = p.eDir
	pNew.inDir = p.eDir
	pNew.iLayer = p.pik_value_int("layer", &miss)
	if miss {
		pNew.iLayer = 1000
	}
	if pNew.iLayer < 0 {
		pNew.iLayer = 0
	}
	if pSublist != nil {
		pNew.typ = &sublistClass
		pNew.pSublist = pSublist
		sublistClass.xInit(p, pNew)
		return pNew
	}
	if pStr != nil {
		n := PToken{
			z: []byte("text"),
			n: 4,
		}
		pNew.typ = pik_find_class(&n)
		assert(pNew.typ != nil, "pNew.typ!=nil")
		pNew.errTok = *pStr
		pNew.typ.xInit(p, pNew)
		p.pik_add_txt(pStr, pStr.eCode)
		return pNew
	}
	if pId != nil {
		pNew.errTok = *pId
		pClass := pik_find_class(pId)
		if pClass != nil {
			pNew.typ = pClass
			pNew.sw = p.pik_value("thickness", nil)
			pNew.fill = p.pik_value("fill", nil)
			pNew.color = p.pik_value("color", nil)
			pClass.xInit(p, pNew)
			return pNew
		}
		p.pik_error(pId, "unknown object type")
		p.pik_elem_free(pNew)
		return nil
	}
	pNew.typ = &noopClass
	pNew.ptExit = pNew.ptAt
	pNew.ptEnter = pNew.ptAt
	return pNew
}

/*
** If the ID token in the argument is the name of a macro, return
** the PMacro object for that macro
 */
func (p *Pik) pik_find_macro(pId *PToken) *PMacro {
	for pMac := p.pMacros; pMac != nil; pMac = pMac.pNext {
		if pMac.macroName.n == pId.n && bytesEq(pMac.macroName.z[:pMac.macroName.n], pId.z[:pId.n]) {
			return pMac
		}
	}
	return nil
}

/* Add a new macro
 */
func (p *Pik) pik_add_macro(
	pId *PToken, /* The ID token that defines the macro name */
	pCode *PToken, /* Macro body inside of {...} */
) {
	pNew := p.pik_find_macro(pId)
	if pNew == nil {
		pNew = &PMacro{
			pNext:     p.pMacros,
			macroName: *pId,
		}
		p.pMacros = pNew
	}
	pNew.macroBody.z = pCode.z[1:]
	pNew.macroBody.n = pCode.n - 2
	pNew.inUse = false
}

/*
** Set the output direction and exit point for an object
 */
func pik_elem_set_exit(pObj *PObj, eDir uint8) {
	assert(ValidDir(eDir), "ValidDir(eDir)")
	pObj.outDir = eDir
	if !pObj.typ.isLine || pObj.bClose {
		pObj.ptExit = pObj.ptAt
		switch pObj.outDir {
		default:
			pObj.ptExit.x += pObj.w * 0.5
		case DIR_LEFT:
			pObj.ptExit.x -= pObj.w * 0.5
		case DIR_UP:
			pObj.ptExit.y += pObj.h * 0.5
		case DIR_DOWN:
			pObj.ptExit.y -= pObj.h * 0.5
		}
	}
}

/* Change the layout direction.
 */
func (p *Pik) pik_set_direction(eDir uint8) {
	assert(ValidDir(eDir), "ValidDir(eDir)")
	p.eDir = eDir

	/* It seems to make sense to reach back into the last object and
	 ** change its exit point (its ".end") to correspond to the new
	 ** direction.  Things just seem to work better this way.  However,
	 ** legacy PIC does *not* do this.
	 **
	 ** The difference can be seen in a script like this:
	 **
	 **      arrow; circle; down; arrow
	 **
	 ** You can make pikchr render the above exactly like PIC
	 ** by deleting the following three lines.  But I (drh) think
	 ** it works better with those lines in place.
	 */
	if len(p.list) > 0 {
		pik_elem_set_exit(p.list[len(p.list)-1], eDir)
	}
}

/* Move all coordinates contained within an object (and within its
** substructure) by dx, dy
 */
func pik_elem_move(pObj *PObj, dx PNum, dy PNum) {
	pObj.ptAt.x += dx
	pObj.ptAt.y += dy
	pObj.ptEnter.x += dx
	pObj.ptEnter.y += dy
	pObj.ptExit.x += dx
	pObj.ptExit.y += dy
	pObj.bbox.ne.x += dx
	pObj.bbox.ne.y += dy
	pObj.bbox.sw.x += dx
	pObj.bbox.sw.y += dy
	for i := 0; i < pObj.nPath; i++ {
		pObj.aPath[i].x += dx
		pObj.aPath[i].y += dy
	}
	if pObj.pSublist != nil {
		pik_elist_move(pObj.pSublist, dx, dy)
	}
}
func pik_elist_move(pList PList, dx PNum, dy PNum) {
	for i := 0; i < len(pList); i++ {
		pik_elem_move(pList[i], dx, dy)
	}
}

/*
** Check to see if it is ok to set the value of paraemeter mThis.
** Return 0 if it is ok. If it not ok, generate an appropriate
** error message and return non-zero.
**
** Flags are set in pObj so that the same object or conflicting
** objects may not be set again.
**
** To be ok, bit mThis must be clear and no more than one of
** the bits identified by mBlockers may be set.
 */
func (p *Pik) pik_param_ok(
	pObj *PObj, /* The object under construction */
	pId *PToken, /* Make the error point to this token */
	mThis uint, /* Value we are trying to set */
) bool {
	if pObj.mProp&mThis != 0 {
		p.pik_error(pId, "value is already set")
		return true
	}
	if pObj.mCalc&mThis != 0 {
		p.pik_error(pId, "value already fixed by prior constraints")
		return true
	}
	pObj.mProp |= mThis
	return false
}

/*
** Set a numeric property like "width 7" or "radius 200%".
**
** The rAbs term is an absolute value to add in.  rRel is
** a relative value by which to change the current value.
 */
func (p *Pik) pik_set_numprop(pId *PToken, pVal *PRel) {
	pObj := p.cur
	switch pId.eType {
	case T_HEIGHT:
		if p.pik_param_ok(pObj, pId, A_HEIGHT) {
			return
		}
		pObj.h = pObj.h*pVal.rRel + pVal.rAbs
	case T_WIDTH:
		if p.pik_param_ok(pObj, pId, A_WIDTH) {
			return
		}
		pObj.w = pObj.w*pVal.rRel + pVal.rAbs
	case T_RADIUS:
		if p.pik_param_ok(pObj, pId, A_RADIUS) {
			return
		}
		pObj.rad = pObj.rad*pVal.rRel + pVal.rAbs
	case T_DIAMETER:
		if p.pik_param_ok(pObj, pId, A_RADIUS) {
			return
		}
		pObj.rad = pObj.rad*pVal.rRel + 0.5*pVal.rAbs /* diam it 2x rad */
	case T_THICKNESS:
		if p.pik_param_ok(pObj, pId, A_THICKNESS) {
			return
		}
		pObj.sw = pObj.sw*pVal.rRel + pVal.rAbs
	}
	if pObj.typ.xNumProp != nil {
		pObj.typ.xNumProp(p, pObj, pId)
	}
}

/*
** Set a color property.  The argument is an RGB value.
 */
func (p *Pik) pik_set_clrprop(pId *PToken, rClr PNum) {
	pObj := p.cur
	switch pId.eType {
	case T_FILL:
		if p.pik_param_ok(pObj, pId, A_FILL) {
			return
		}
		pObj.fill = rClr
	case T_COLOR:
		if p.pik_param_ok(pObj, pId, A_COLOR) {
			return
		}
		pObj.color = rClr
		break
	}
	if pObj.typ.xNumProp != nil {
		pObj.typ.xNumProp(p, pObj, pId)
	}
}

/*
** Set a "dashed" property like "dash 0.05"
**
** Use the value supplied by pVal if available.  If pVal==0, use
** a default.
 */
func (p *Pik) pik_set_dashed(pId *PToken, pVal *PNum) {
	pObj := p.cur
	switch pId.eType {
	case T_DOTTED:
		if pVal != nil {
			pObj.dotted = *pVal
		} else {
			pObj.dotted = p.pik_value("dashwid", nil)
		}
		pObj.dashed = 0.0
	case T_DASHED:
		if pVal != nil {
			pObj.dashed = *pVal
		} else {
			pObj.dashed = p.pik_value("dashwid", nil)
		}
		pObj.dotted = 0.0
	}
}

/*
** If the current path information came from a "same" or "same as"
** reset it.
 */
func (p *Pik) pik_reset_samepath() {
	if p.samePath {
		p.samePath = false
		p.nTPath = 1
	}
}

/* Add a new term to the path for a line-oriented object by transferring
** the information in the ptTo field over onto the path and into ptFrom
** resetting the ptTo.
 */
func (p *Pik) pik_then(pToken *PToken, pObj *PObj) {
	if !pObj.typ.isLine {
		p.pik_error(pToken, "use with line-oriented objects only")
		return
	}
	n := p.nTPath - 1
	if n < 1 && (pObj.mProp&A_FROM) == 0 {
		p.pik_error(pToken, "no prior path points")
		return
	}
	p.thenFlag = true
}

/* Advance to the next entry in p.aTPath.  Return its index.
 */
func (p *Pik) pik_next_rpath(pErr *PToken) int {
	n := p.nTPath - 1
	if n+1 >= len(p.aTPath) {
		(*Pik)(nil).pik_error(pErr, "too many path elements")
		return n
	}
	n++
	p.nTPath++
	p.aTPath[n] = p.aTPath[n-1]
	p.mTPath = 0
	return n
}

/* Add a direction term to an object.  "up 0.5", or "left 3", or "down"
** or "down 50%".
 */
func (p *Pik) pik_add_direction(pDir *PToken, pVal *PRel) {
	pObj := p.cur
	if !pObj.typ.isLine {
		if pDir != nil {
			p.pik_error(pDir, "use with line-oriented objects only")
		} else {
			x := pik_next_semantic_token(&pObj.errTok)
			p.pik_error(&x, "syntax error")
		}
		return
	}
	p.pik_reset_samepath()
	n := p.nTPath - 1
	if p.thenFlag || p.mTPath == 3 || n == 0 {
		n = p.pik_next_rpath(pDir)
		p.thenFlag = false
	}
	dir := p.eDir
	if pDir != nil {
		dir = uint8(pDir.eCode)
	}
	switch dir {
	case DIR_UP:
		if p.mTPath&2 > 0 {
			n = p.pik_next_rpath(pDir)
		}
		p.aTPath[n].y += pVal.rAbs + pObj.h*pVal.rRel
		p.mTPath |= 2
	case DIR_DOWN:
		if p.mTPath&2 > 0 {
			n = p.pik_next_rpath(pDir)
		}
		p.aTPath[n].y -= pVal.rAbs + pObj.h*pVal.rRel
		p.mTPath |= 2
	case DIR_RIGHT:
		if p.mTPath&1 > 0 {
			n = p.pik_next_rpath(pDir)
		}
		p.aTPath[n].x += pVal.rAbs + pObj.w*pVal.rRel
		p.mTPath |= 1
	case DIR_LEFT:
		if p.mTPath&1 > 0 {
			n = p.pik_next_rpath(pDir)
		}
		p.aTPath[n].x -= pVal.rAbs + pObj.w*pVal.rRel
		p.mTPath |= 1
	}
	pObj.outDir = dir
}

/* Process a movement attribute of one of these forms:
**
**         pDist   pHdgKW  rHdg    pEdgept
**     GO distance HEADING angle
**     GO distance               compasspoint
 */
func (p *Pik) pik_move_hdg(
	pDist *PRel, /* Distance to move */
	pHeading *PToken, /* "heading" keyword if present */
	rHdg PNum, /* Angle argument to "heading" keyword */
	pEdgept *PToken, /* EDGEPT keyword "ne", "sw", etc... */
	pErr *PToken, /* Token to use for error messages */
) {
	pObj := p.cur
	var rDist PNum = pDist.rAbs + p.pik_value("linewid", nil)*pDist.rRel
	if !pObj.typ.isLine {
		p.pik_error(pErr, "use with line-oriented objects only")
		return
	}
	p.pik_reset_samepath()
	n := 0
	for n < 1 {
		n = p.pik_next_rpath(pErr)
	}
	if pHeading != nil {
		if rHdg < 0.0 || rHdg > 360.0 {
			p.pik_error(pHeading, "headings should be between 0 and 360")
			return
		}
	} else if pEdgept.eEdge == CP_C {
		p.pik_error(pEdgept, "syntax error")
		return
	} else {
		rHdg = pik_hdg_angle[pEdgept.eEdge]
	}
	if rHdg <= 45.0 {
		pObj.outDir = DIR_UP
	} else if rHdg <= 135.0 {
		pObj.outDir = DIR_RIGHT
	} else if rHdg <= 225.0 {
		pObj.outDir = DIR_DOWN
	} else if rHdg <= 315.0 {
		pObj.outDir = DIR_LEFT
	} else {
		pObj.outDir = DIR_UP
	}
	rHdg *= 0.017453292519943295769 /* degrees to radians */
	p.aTPath[n].x += rDist * math.Sin(rHdg)
	p.aTPath[n].y += rDist * math.Cos(rHdg)
	p.mTPath = 2
}

/* Process a movement attribute of the form "right until even with ..."
 **
 ** pDir is the first keyword, "right" or "left" or "up" or "down".
 ** The movement is in that direction until its closest approach to
 ** the point specified by pPoint.
 */
func (p *Pik) pik_evenwith(pDir *PToken, pPlace *PPoint) {
	pObj := p.cur

	if !pObj.typ.isLine {
		p.pik_error(pDir, "use with line-oriented objects only")
		return
	}
	p.pik_reset_samepath()
	n := p.nTPath - 1
	if p.thenFlag || p.mTPath == 3 || n == 0 {
		n = p.pik_next_rpath(pDir)
		p.thenFlag = false
	}
	switch pDir.eCode {
	case DIR_DOWN, DIR_UP:
		if p.mTPath&2 != 0 {
			n = p.pik_next_rpath(pDir)
		}
		p.aTPath[n].y = pPlace.y
		p.mTPath |= 2
	case DIR_RIGHT, DIR_LEFT:
		if p.mTPath&1 != 0 {
			n = p.pik_next_rpath(pDir)
		}
		p.aTPath[n].x = pPlace.x
		p.mTPath |= 1
	}
	pObj.outDir = uint8(pDir.eCode)
}

/* If the last referenced object is centered at point pPt then return
** a pointer to that object.  If there is no prior object reference,
** or if the points are not the same, return NULL.
**
** This is a side-channel hack used to find the objects at which a
** line begins and ends.  For example, in
**
**        arrow from OBJ1 to OBJ2 chop
**
** The arrow object is normally just handed the coordinates of the
** centers for OBJ1 and OBJ2.  But we also want to know the specific
** object named in case there are multiple objects centered at the
** same point.
**
** See forum post 1d46e3a0bc
 */
func (p *Pik) pik_last_ref_object(pPt *PPoint) *PObj {
	var pRes *PObj
	if p.lastRef == nil {
		return nil
	}
	if p.lastRef.ptAt.x == pPt.x && p.lastRef.ptAt.y == pPt.y {
		pRes = p.lastRef
	}
	p.lastRef = nil
	return pRes
}

/* Set the "from" of an object
 */
func (p *Pik) pik_set_from(pObj *PObj, pTk *PToken, pPt *PPoint) {
	if !pObj.typ.isLine {
		p.pik_error(pTk, "use \"at\" to position this object")
		return
	}
	if pObj.mProp&A_FROM != 0 {
		p.pik_error(pTk, "line start location already fixed")
		return
	}
	if pObj.bClose {
		p.pik_error(pTk, "polygon is closed")
		return
	}
	if p.nTPath > 1 {
		var dx PNum = pPt.x - p.aTPath[0].x
		var dy PNum = pPt.y - p.aTPath[0].y
		for i := 1; i < p.nTPath; i++ {
			p.aTPath[i].x += dx
			p.aTPath[i].y += dy
		}
	}
	p.aTPath[0] = *pPt
	p.mTPath = 3
	pObj.mProp |= A_FROM
	pObj.pFrom = p.pik_last_ref_object(pPt)
}

/* Set the "to" of an object
 */
func (p *Pik) pik_add_to(pObj *PObj, pTk *PToken, pPt *PPoint) {
	n := p.nTPath - 1
	if !pObj.typ.isLine {
		p.pik_error(pTk, "use \"at\" to position this object")
		return
	}
	if pObj.bClose {
		p.pik_error(pTk, "polygon is closed")
		return
	}
	p.pik_reset_samepath()
	if n == 0 || p.mTPath == 3 || p.thenFlag {
		n = p.pik_next_rpath(pTk)
	}
	p.aTPath[n] = *pPt
	p.mTPath = 3
	pObj.pTo = p.pik_last_ref_object(pPt)
}

func (p *Pik) pik_close_path(pErr *PToken) {
	pObj := p.cur
	if p.nTPath < 3 {
		p.pik_error(pErr,
			"need at least 3 vertexes in order to close the polygon")
		return
	}
	if pObj.bClose {
		p.pik_error(pErr, "polygon already closed")
		return
	}
	pObj.bClose = true
}

/* Lower the layer of the current object so that it is behind the
** given object.
 */
func (p *Pik) pik_behind(pOther *PObj) {
	pObj := p.cur
	if p.nErr == 0 && pObj.iLayer >= pOther.iLayer {
		pObj.iLayer = pOther.iLayer - 1
	}
}

/* Set the "at" of an object
 */
func (p *Pik) pik_set_at(pEdge *PToken, pAt *PPoint, pErrTok *PToken) {
	eDirToCp := []uint8{CP_E, CP_S, CP_W, CP_N}
	if p.nErr != 0 {
		return
	}
	pObj := p.cur

	if pObj.typ.isLine {
		p.pik_error(pErrTok, "use \"from\" and \"to\" to position this object")
		return
	}
	if pObj.mProp&A_AT != 0 {
		p.pik_error(pErrTok, "location fixed by prior \"at\"")
		return
	}
	pObj.mProp |= A_AT
	pObj.eWith = CP_C
	if pEdge != nil {
		pObj.eWith = pEdge.eEdge
	}
	if pObj.eWith >= CP_END {
		dir := pObj.inDir
		if pObj.eWith == CP_END {
			dir = pObj.outDir
		}
		pObj.eWith = eDirToCp[int(dir)]
	}
	pObj.with = *pAt
}

/*
** Try to add a text attribute to an object
 */
func (p *Pik) pik_add_txt(pTxt *PToken, iPos int16) {
	pObj := p.cur
	if int(pObj.nTxt) >= len(pObj.aTxt) {
		p.pik_error(pTxt, "too many text terms")
		return
	}
	pT := &pObj.aTxt[pObj.nTxt]
	pObj.nTxt++
	*pT = *pTxt
	pT.eCode = iPos
}

/* Merge "text-position" flags
 */
func pik_text_position(iPrev int, pFlag *PToken) int {
	iRes := iPrev
	switch pFlag.eType {
	case T_LJUST:
		iRes = (iRes &^ TP_JMASK) | TP_LJUST
	case T_RJUST:
		iRes = (iRes &^ TP_JMASK) | TP_RJUST
	case T_ABOVE:
		iRes = (iRes &^ TP_VMASK) | TP_ABOVE
	case T_CENTER:
		iRes = (iRes &^ TP_VMASK) | TP_CENTER
	case T_BELOW:
		iRes = (iRes &^ TP_VMASK) | TP_BELOW
	case T_ITALIC:
		iRes |= TP_ITALIC
	case T_BOLD:
		iRes |= TP_BOLD
	case T_ALIGNED:
		iRes |= TP_ALIGN
	case T_BIG:
		if iRes&TP_BIG != 0 {
			iRes |= TP_XTRA
		} else {
			iRes = (iRes &^ TP_SZMASK) | TP_BIG
		}
	case T_SMALL:
		if iRes&TP_SMALL != 0 {
			iRes |= TP_XTRA
		} else {
			iRes = (iRes &^ TP_SZMASK) | TP_SMALL
		}
	}
	return iRes
}

/*
** Table of scale-factor estimates for variable-width characters.
** Actual character widths vary by font.  These numbers are only
** guesses.  And this table only provides data for ASCII.
**
** 100 means normal width.
 */
var awChar = []byte{
	/* Skip initial 32 control characters */
	/* ' ' */ 45,
	/* '!' */ 55,
	/* '"' */ 62,
	/* '#' */ 115,
	/* '$' */ 90,
	/* '%' */ 132,
	/* '&' */ 125,
	/* '\''*/ 40,

	/* '(' */ 55,
	/* ')' */ 55,
	/* '*' */ 71,
	/* '+' */ 115,
	/* ',' */ 45,
	/* '-' */ 48,
	/* '.' */ 45,
	/* '/' */ 50,

	/* '0' */ 91,
	/* '1' */ 91,
	/* '2' */ 91,
	/* '3' */ 91,
	/* '4' */ 91,
	/* '5' */ 91,
	/* '6' */ 91,
	/* '7' */ 91,

	/* '8' */ 91,
	/* '9' */ 91,
	/* ':' */ 50,
	/* ';' */ 50,
	/* '<' */ 120,
	/* '=' */ 120,
	/* '>' */ 120,
	/* '?' */ 78,

	/* '@' */ 142,
	/* 'A' */ 102,
	/* 'B' */ 105,
	/* 'C' */ 110,
	/* 'D' */ 115,
	/* 'E' */ 105,
	/* 'F' */ 98,
	/* 'G' */ 105,

	/* 'H' */ 125,
	/* 'I' */ 58,
	/* 'J' */ 58,
	/* 'K' */ 107,
	/* 'L' */ 95,
	/* 'M' */ 145,
	/* 'N' */ 125,
	/* 'O' */ 115,

	/* 'P' */ 95,
	/* 'Q' */ 115,
	/* 'R' */ 107,
	/* 'S' */ 95,
	/* 'T' */ 97,
	/* 'U' */ 118,
	/* 'V' */ 102,
	/* 'W' */ 150,

	/* 'X' */ 100,
	/* 'Y' */ 93,
	/* 'Z' */ 100,
	/* '[' */ 58,
	/* '\\'*/ 50,
	/* ']' */ 58,
	/* '^' */ 119,
	/* '_' */ 72,

	/* '`' */ 72,
	/* 'a' */ 86,
	/* 'b' */ 92,
	/* 'c' */ 80,
	/* 'd' */ 92,
	/* 'e' */ 85,
	/* 'f' */ 52,
	/* 'g' */ 92,

	/* 'h' */ 92,
	/* 'i' */ 47,
	/* 'j' */ 47,
	/* 'k' */ 88,
	/* 'l' */ 48,
	/* 'm' */ 135,
	/* 'n' */ 92,
	/* 'o' */ 86,

	/* 'p' */ 92,
	/* 'q' */ 92,
	/* 'r' */ 69,
	/* 's' */ 75,
	/* 't' */ 58,
	/* 'u' */ 92,
	/* 'v' */ 80,
	/* 'w' */ 121,

	/* 'x' */ 81,
	/* 'y' */ 80,
	/* 'z' */ 76,
	/* '{' */ 91,
	/* '|'*/ 49,
	/* '}' */ 91,
	/* '~' */ 118,
}

/* Return an estimate of the width of the displayed characters
** in a character string.  The returned value is 100 times the
** average character width.
**
** Omit "\" used to escape characters.  And count entities like
** "&lt;" as a single character.  Multi-byte UTF8 characters count
** as a single character.
**
** Attempt to scale the answer by the actual characters seen.  Wide
** characters count more than narrow characters.  But the widths are
** only guesses.
 */
func pik_text_length(pToken PToken) int {
	n := pToken.n
	z := pToken.z
	cnt := 0
	for j := 1; j < n-1; j++ {
		c := z[j]
		if c == '\\' && z[j+1] != '&' {
			j++
			c = z[j]
		} else if c == '&' {
			var k int
			for k = j + 1; k < j+7 && z[k] != 0 && z[k] != ';'; k++ {
			}
			if z[k] == ';' {
				j = k
			}
			cnt += 150
			continue
		}
		if (c & 0xc0) == 0xc0 {
			for j+1 < n-1 && (z[j+1]&0xc0) == 0x80 {
				j++
			}
			cnt += 100
			continue
		}
		if c >= 0x20 && c <= 0x7e {
			cnt += int(awChar[int(c-0x20)])
		} else {
			cnt += 100
		}
	}
	return cnt
}

/* Adjust the width, height, and/or radius of the object so that
** it fits around the text that has been added so far.
**
**    (1) Only text specified prior to this attribute is considered.
**    (2) The text size is estimated based on the charht and charwid
**        variable settings.
**    (3) The fitted attributes can be changed again after this
**        attribute, for example using "width 110%" if this auto-fit
**        underestimates the text size.
**    (4) Previously set attributes will not be altered.  In other words,
**        "width 1in fit" might cause the height to change, but the
**        width is now set.
**    (5) This only works for attributes that have an xFit method.
**
** The eWhich parameter is:
**
**    1:   Fit horizontally only
**    2:   Fit vertically only
**    3:   Fit both ways
 */
func (p *Pik) pik_size_to_fit(pFit *PToken, eWhich int) {
	var w, h PNum
	var bbox PBox

	if p.nErr != 0 {
		return
	}
	pObj := p.cur

	if pObj.nTxt == 0 {
		(*Pik)(nil).pik_error(pFit, "no text to fit to")
		return
	}
	if pObj.typ.xFit == nil {
		return
	}
	pik_bbox_init(&bbox)
	p.pik_compute_layout_settings()
	p.pik_append_txt(pObj, &bbox)
	if eWhich&1 != 0 {
		w = (bbox.ne.x - bbox.sw.x) + p.charWidth
	}
	if eWhich&2 != 0 {
		var h1, h2 PNum
		h1 = bbox.ne.y - pObj.ptAt.y
		h2 = pObj.ptAt.y - bbox.sw.y
		hmax := h1
		if h1 < h2 {
			hmax = h2
		}
		h = 2.0*hmax + 0.5*p.charHeight
	} else {
		h = 0
	}
	pObj.typ.xFit(p, pObj, w, h)
	pObj.mProp |= A_FIT
}

/* Set a local variable name to "val".
**
** The name might be a built-in variable or a color name.  In either case,
** a new application-defined variable is set.  Since app-defined variables
** are searched first, this will override any built-in variables.
 */
func (p *Pik) pik_set_var(pId *PToken, val PNum, pOp *PToken) {
	pVar := p.pVar
	for pVar != nil {
		if pik_token_eq(pId, pVar.zName) == 0 {
			break
		}
		pVar = pVar.pNext
	}
	if pVar == nil {
		pVar = &PVar{
			zName: pId.String(),
			pNext: p.pVar,
			val:   p.pik_value(pId.String(), nil),
		}
		p.pVar = pVar
	}
	switch pOp.eCode {
	case T_PLUS:
		pVar.val += val
	case T_STAR:
		pVar.val *= val
	case T_MINUS:
		pVar.val -= val
	case T_SLASH:
		if val == 0.0 {
			p.pik_error(pOp, "division by zero")
		} else {
			pVar.val /= val
		}
	default:
		pVar.val = val
	}
	p.bLayoutVars = false /* Clear the layout setting cache */
}

/*
** Round a PNum into the nearest integer
 */
func pik_round(v PNum) int {
	switch {
	case math.IsNaN(v):
		return 0
	case v < -2147483647:
		return (-2147483647 - 1)
	case v >= 2147483647:
		return 2147483647
	default:
		return int(v + math.Copysign(1e-15, v))
	}
}

/*
** Search for the variable named z[0..n-1] in:
**
**   * Application defined variables
**   * Built-in variables
**
** Return the value of the variable if found.  If not found
** return 0.0.  Also if pMiss is not NULL, then set it to 1
** if not found.
**
** This routine is a subroutine to pik_get_var().  But it is also
** used by object implementations to look up (possibly overwritten)
** values for built-in variables like "boxwid".
 */
func (p *Pik) pik_value(z string, pMiss *bool) PNum {
	for pVar := p.pVar; pVar != nil; pVar = pVar.pNext {
		if pVar.zName == z {
			return pVar.val
		}
	}
	first := 0
	last := len(aBuiltin) - 1
	for first <= last {
		mid := (first + last) / 2
		zName := aBuiltin[mid].zName

		if zName == z {
			return aBuiltin[mid].val
		} else if z > zName {
			first = mid + 1
		} else {
			last = mid - 1
		}
	}
	if pMiss != nil {
		*pMiss = true
	}
	return 0.0
}

func (p *Pik) pik_value_int(z string, pMiss *bool) int {
	return pik_round(p.pik_value(z, pMiss))
}

/*
** Look up a color-name.  Unlike other names in this program, the
** color-names are not case sensitive.  So "DarkBlue" and "darkblue"
** and "DARKBLUE" all find the same value (139).
**
** If not found, return -99.0.  Also post an error if p!=NULL.
**
** Special color names "None" and "Off" return -1.0 without causing
** an error.
 */
func (p *Pik) pik_lookup_color(pId *PToken) PNum {
	first := 0
	last := len(aColor) - 1
	zId := strings.ToLower(pId.String())
	for first <= last {
		mid := (first + last) / 2
		zClr := strings.ToLower(aColor[mid].zName)
		c := strings.Compare(zId, zClr)

		if c == 0 {
			return PNum(aColor[mid].val)
		}
		if c > 0 {
			first = mid + 1
		} else {
			last = mid - 1
		}
	}
	if p != nil {
		p.pik_error(pId, "not a known color name")
	}
	return -99.0
}

/* Get the value of a variable.
**
** Search in order:
**
**    *  Application defined variables
**    *  Built-in variables
**    *  Color names
**
** If no such variable is found, throw an error.
 */
func (p *Pik) pik_get_var(pId *PToken) PNum {
	miss := false
	v := p.pik_value(pId.String(), &miss)
	if !miss {
		return v
	}
	v = (*Pik)(nil).pik_lookup_color(pId)
	if v > -90.0 {
		return v
	}
	p.pik_error(pId, "no such variable")
	return 0.0
}

/* Convert a T_NTH token (ex: "2nd", "5th"} into a numeric value and
 ** return that value.  Throw an error if the value is too big.
 */
func (p *Pik) pik_nth_value(pNth *PToken) int16 {
	s := pNth.String()
	if s == "first" {
		return 1
	}

	i, err := strconv.Atoi(s[:len(s)-2])
	if err != nil {
		p.pik_error(pNth, "value can't be parsed as a number")
	}
	if i > 1000 {
		p.pik_error(pNth, "value too big - max '1000th'")
		i = 1
	}
	return int16(i)
}

/* Search for the NTH object.
**
** If pBasis is not NULL then it should be a [] object.  Use the
** sublist of that [] object for the search.  If pBasis is not a []
** object, then throw an error.
**
** The pNth token describes the N-th search.  The pNth.eCode value
** is one more than the number of items to skip.  It is negative
** to search backwards.  If pNth.eType==T_ID, then it is the name
** of a class to search for.  If pNth.eType==T_LB, then
** search for a [] object.  If pNth.eType==T_LAST, then search for
** any type.
**
** Raise an error if the item is not found.
 */
func (p *Pik) pik_find_nth(pBasis *PObj, pNth *PToken) *PObj {
	var pList PList
	var pClass *PClass
	if pBasis == nil {
		pList = p.list
	} else {
		pList = pBasis.pSublist
	}
	if pList == nil {
		p.pik_error(pNth, "no such object")
		return nil
	}
	if pNth.eType == T_LAST {
		pClass = nil
	} else if pNth.eType == T_LB {
		pClass = &sublistClass
	} else {
		pClass = pik_find_class(pNth)
		if pClass == nil {
			(*Pik)(nil).pik_error(pNth, "no such object type")
			return nil
		}
	}
	n := pNth.eCode
	if n < 0 {
		for i := len(pList) - 1; i >= 0; i-- {
			pObj := pList[i]
			if pClass != nil && pObj.typ != pClass {
				continue
			}
			n++
			if n == 0 {
				return pObj
			}
		}
	} else {
		for i := 0; i < len(pList); i++ {
			pObj := pList[i]
			if pClass != nil && pObj.typ != pClass {
				continue
			}
			n--
			if n == 0 {
				return pObj
			}
		}
	}
	p.pik_error(pNth, "no such object")
	return nil
}

/* Search for an object by name.
**
** Search in pBasis.pSublist if pBasis is not NULL.  If pBasis is NULL
** then search in p.list.
 */
func (p *Pik) pik_find_byname(pBasis *PObj, pName *PToken) *PObj {
	var pList PList
	if pBasis == nil {
		pList = p.list
	} else {
		pList = pBasis.pSublist
	}
	if pList == nil {
		p.pik_error(pName, "no such object")
		return nil
	}
	/* First look explicitly tagged objects */
	for i := len(pList) - 1; i >= 0; i-- {
		pObj := pList[i]
		if pObj.zName != "" && pik_token_eq(pName, pObj.zName) == 0 {
			p.lastRef = pObj
			return pObj
		}
	}
	/* If not found, do a second pass looking for any object containing
	 ** text which exactly matches pName */
	for i := len(pList) - 1; i >= 0; i-- {
		pObj := pList[i]
		for j := 0; j < int(pObj.nTxt); j++ {
			t := pObj.aTxt[j].n
			if t == pName.n+2 && bytesEq(pObj.aTxt[j].z[1:t-1], pName.z[:pName.n]) {
				p.lastRef = pObj
				return pObj
			}
		}
	}
	p.pik_error(pName, "no such object")
	return nil
}

/* Change most of the settings for the current object to be the
** same as the pOther object, or the most recent object of the same
** type if pOther is NULL.
 */
func (p *Pik) pik_same(pOther *PObj, pErrTok *PToken) {
	pObj := p.cur
	if p.nErr != 0 {
		return
	}
	if pOther == nil {
		var i int
		for i = len(p.list) - 1; i >= 0; i-- {
			pOther = p.list[i]
			if pOther.typ == pObj.typ {
				break
			}
		}
		if i < 0 {
			p.pik_error(pErrTok, "no prior objects of the same type")
			return
		}
	}
	if pOther.nPath != 0 && pObj.typ.isLine {
		var dx, dy PNum
		dx = p.aTPath[0].x - pOther.aPath[0].x
		dy = p.aTPath[0].y - pOther.aPath[0].y
		for i := 1; i < pOther.nPath; i++ {
			p.aTPath[i].x = pOther.aPath[i].x + dx
			p.aTPath[i].y = pOther.aPath[i].y + dy
		}
		p.nTPath = pOther.nPath
		p.mTPath = 3
		p.samePath = true
	}
	if !pObj.typ.isLine {
		pObj.w = pOther.w
		pObj.h = pOther.h
	}
	pObj.rad = pOther.rad
	pObj.sw = pOther.sw
	pObj.dashed = pOther.dashed
	pObj.dotted = pOther.dotted
	pObj.fill = pOther.fill
	pObj.color = pOther.color
	pObj.cw = pOther.cw
	pObj.larrow = pOther.larrow
	pObj.rarrow = pOther.rarrow
	pObj.bClose = pOther.bClose
	pObj.bChop = pOther.bChop
	pObj.inDir = pOther.inDir
	pObj.outDir = pOther.outDir
	pObj.iLayer = pOther.iLayer
}

/* Return a "Place" associated with object pObj.  If pEdge is NULL
** return the center of the object.  Otherwise, return the corner
** described by pEdge.
 */
func (p *Pik) pik_place_of_elem(pObj *PObj, pEdge *PToken) PPoint {
	pt := PPoint{}
	var pClass *PClass
	if pObj == nil {
		return pt
	}
	if pEdge == nil {
		return pObj.ptAt
	}
	pClass = pObj.typ
	if pEdge.eType == T_EDGEPT || (pEdge.eEdge > 0 && pEdge.eEdge < CP_END) {
		pt = pClass.xOffset(p, pObj, pEdge.eEdge)
		pt.x += pObj.ptAt.x
		pt.y += pObj.ptAt.y
		return pt
	}
	if pEdge.eType == T_START {
		return pObj.ptEnter
	} else {
		return pObj.ptExit
	}
}

/* Do a linear interpolation of two positions.
 */
func pik_position_between(x PNum, p1 PPoint, p2 PPoint) PPoint {
	var out PPoint
	out.x = p2.x*x + p1.x*(1.0-x)
	out.y = p2.y*x + p1.y*(1.0-x)
	return out
}

/* Compute the position that is dist away from pt at an heading angle of r
**
** The angle is a compass heading in degrees.  North is 0 (or 360).
** East is 90.  South is 180.  West is 270.  And so forth.
 */
func pik_position_at_angle(dist PNum, r PNum, pt PPoint) PPoint {
	r *= 0.017453292519943295769 /* degrees to radians */
	pt.x += dist * math.Sin(r)
	pt.y += dist * math.Cos(r)
	return pt
}

/* Compute the position that is dist away at a compass point
 */
func pik_position_at_hdg(dist PNum, pD *PToken, pt PPoint) PPoint {
	return pik_position_at_angle(dist, pik_hdg_angle[pD.eEdge], pt)
}

/* Return the coordinates for the n-th vertex of a line.
 */
func (p *Pik) pik_nth_vertex(pNth *PToken, pErr *PToken, pObj *PObj) PPoint {
	var n int
	zero := PPoint{}
	if p.nErr != 0 || pObj == nil {
		return p.aTPath[0]
	}
	if !pObj.typ.isLine {
		p.pik_error(pErr, "object is not a line")
		return zero
	}
	n, err := strconv.Atoi(string(pNth.z[:pNth.n-2]))
	if err != nil || n < 1 || n > pObj.nPath {
		p.pik_error(pNth, "no such vertex")
		return zero
	}
	return pObj.aPath[n-1]
}

/* Return the value of a property of an object.
 */
func pik_property_of(pObj *PObj, pProp *PToken) PNum {
	var v PNum
	if pObj != nil {
		switch pProp.eType {
		case T_HEIGHT:
			v = pObj.h
		case T_WIDTH:
			v = pObj.w
		case T_RADIUS:
			v = pObj.rad
		case T_DIAMETER:
			v = pObj.rad * 2.0
		case T_THICKNESS:
			v = pObj.sw
		case T_DASHED:
			v = pObj.dashed
		case T_DOTTED:
			v = pObj.dotted
		case T_FILL:
			v = pObj.fill
		case T_COLOR:
			v = pObj.color
		case T_X:
			v = pObj.ptAt.x
		case T_Y:
			v = pObj.ptAt.y
		case T_TOP:
			v = pObj.bbox.ne.y
		case T_BOTTOM:
			v = pObj.bbox.sw.y
		case T_LEFT:
			v = pObj.bbox.sw.x
		case T_RIGHT:
			v = pObj.bbox.ne.x
		}
	}
	return v
}

/* Compute one of the built-in functions
 */
func (p *Pik) pik_func(pFunc *PToken, x PNum, y PNum) PNum {
	var v PNum
	switch pFunc.eCode {
	case FN_ABS:
		v = x
		if v < 0 {
			v = -x
		}
	case FN_COS:
		v = math.Cos(x)
	case FN_INT:
		v = math.Trunc(x)
	case FN_SIN:
		v = math.Sin(x)
	case FN_SQRT:
		if x < 0.0 {
			p.pik_error(pFunc, "sqrt of negative value")
			v = 0.0
		} else {
			v = math.Sqrt(x)
		}
	case FN_MAX:
		if x > y {
			v = x
		} else {
			v = y
		}
	case FN_MIN:
		if x < y {
			v = x
		} else {
			v = y
		}
	default:
		v = 0.0
	}
	return v
}

/* Attach a name to an object
 */
func (p *Pik) pik_elem_setname(pObj *PObj, pName *PToken) {
	if pObj == nil {
		return
	}
	if pName == nil {
		return
	}
	pObj.zName = pName.String()
}

/*
** Search for object located at *pCenter that has an xChop method and
** that does not enclose point pOther.
**
** Return a pointer to the object, or NULL if not found.
 */
func pik_find_chopper(pList PList, pCenter *PPoint, pOther *PPoint) *PObj {
	if pList == nil {
		return nil
	}
	for i := len(pList) - 1; i >= 0; i-- {
		pObj := pList[i]
		if pObj.typ.xChop != nil &&
			pObj.ptAt.x == pCenter.x &&
			pObj.ptAt.y == pCenter.y &&
			!pik_bbox_contains_point(&pObj.bbox, pOther) {
			return pObj
		} else if pObj.pSublist != nil {
			pObj = pik_find_chopper(pObj.pSublist, pCenter, pOther)
			if pObj != nil {
				return pObj
			}
		}
	}
	return nil
}

/*
** There is a line traveling from pFrom to pTo.
**
** If pObj is not null and is a choppable object, then chop at
** the boundary of pObj - where the line crosses the boundary
** of pObj.
**
** If pObj is NULL or has no xChop method, then search for some
** other object centered at pTo that is choppable and use it
** instead.
 */
func (p *Pik) pik_autochop(pFrom *PPoint, pTo *PPoint, pObj *PObj) {
	if pObj == nil || pObj.typ.xChop == nil {
		pObj = pik_find_chopper(p.list, pTo, pFrom)
	}
	if pObj != nil {
		*pTo = pObj.typ.xChop(p, pObj, pFrom)
	}
}

/* This routine runs after all attributes have been received
** on an object.
 */
func (p *Pik) pik_after_adding_attributes(pObj *PObj) {
	if p.nErr != 0 {
		return
	}

	/* Position block objects */
	if !pObj.typ.isLine {
		/* A height or width less than or equal to zero means "autofit".
		 ** Change the height or width to be big enough to contain the text,
		 */
		if pObj.h <= 0.0 {
			if pObj.nTxt == 0 {
				pObj.h = 0.0
			} else if pObj.w <= 0.0 {
				p.pik_size_to_fit(&pObj.errTok, 3)
			} else {
				p.pik_size_to_fit(&pObj.errTok, 2)
			}
		}
		if pObj.w <= 0.0 {
			if pObj.nTxt == 0 {
				pObj.w = 0.0
			} else {
				p.pik_size_to_fit(&pObj.errTok, 1)
			}
		}
		ofst := p.pik_elem_offset(pObj, pObj.eWith)
		var dx PNum = (pObj.with.x - ofst.x) - pObj.ptAt.x
		var dy PNum = (pObj.with.y - ofst.y) - pObj.ptAt.y
		if dx != 0 || dy != 0 {
			pik_elem_move(pObj, dx, dy)
		}
	}

	/* For a line object with no movement specified, a single movement
	 ** of the default length in the current direction
	 */
	if pObj.typ.isLine && p.nTPath < 2 {
		p.pik_next_rpath(nil)
		assert(p.nTPath == 2, fmt.Sprintf("want p.nTPath==2; got %d", p.nTPath))
		switch pObj.inDir {
		default:
			p.aTPath[1].x += pObj.w
		case DIR_DOWN:
			p.aTPath[1].y -= pObj.h
		case DIR_LEFT:
			p.aTPath[1].x -= pObj.w
		case DIR_UP:
			p.aTPath[1].y += pObj.h
		}
		if pObj.typ.zName == "arc" {
			add := uint8(3)
			if pObj.cw {
				add = 1
			}
			pObj.outDir = (pObj.inDir + add) % 4
			p.eDir = pObj.outDir
			switch pObj.outDir {
			default:
				p.aTPath[1].x += pObj.w
			case DIR_DOWN:
				p.aTPath[1].y -= pObj.h
			case DIR_LEFT:
				p.aTPath[1].x -= pObj.w
			case DIR_UP:
				p.aTPath[1].y += pObj.h
			}
		}
	}

	/* Initialize the bounding box prior to running xCheck */
	pik_bbox_init(&pObj.bbox)

	/* Run object-specific code */
	if pObj.typ.xCheck != nil {
		pObj.typ.xCheck(p, pObj)
		if p.nErr != 0 {
			return
		}
	}

	/* Compute final bounding box, entry and exit points, center
	 ** point (ptAt) and path for the object
	 */
	if pObj.typ.isLine {
		pObj.aPath = make([]PPoint, p.nTPath)
		pObj.nPath = p.nTPath
		copy(pObj.aPath, p.aTPath[:p.nTPath])

		/* "chop" processing:
		 ** If the line goes to the center of an object with an
		 ** xChop method, then use the xChop method to trim the line.
		 */
		if pObj.bChop && pObj.nPath >= 2 {
			n := pObj.nPath
			p.pik_autochop(&pObj.aPath[n-2], &pObj.aPath[n-1], pObj.pTo)
			p.pik_autochop(&pObj.aPath[1], &pObj.aPath[0], pObj.pFrom)
		}

		pObj.ptEnter = pObj.aPath[0]
		pObj.ptExit = pObj.aPath[pObj.nPath-1]

		/* Compute the center of the line based on the bounding box over
		 ** the vertexes.  This is a difference from PIC.  In Pikchr, the
		 ** center of a line is the center of its bounding box. In PIC, the
		 ** center of a line is halfway between its .start and .end.  For
		 ** straight lines, this is the same point, but for multi-segment
		 ** lines the result is usually diferent */
		for i := 0; i < pObj.nPath; i++ {
			pik_bbox_add_xy(&pObj.bbox, pObj.aPath[i].x, pObj.aPath[i].y)
		}
		pObj.ptAt.x = (pObj.bbox.ne.x + pObj.bbox.sw.x) / 2.0
		pObj.ptAt.y = (pObj.bbox.ne.y + pObj.bbox.sw.y) / 2.0

		/* Reset the width and height of the object to be the width and height
		 ** of the bounding box over vertexes */
		pObj.w = pObj.bbox.ne.x - pObj.bbox.sw.x
		pObj.h = pObj.bbox.ne.y - pObj.bbox.sw.y

		/* If this is a polygon (if it has the "close" attribute), then
		 ** adjust the exit point */
		if pObj.bClose {
			/* For "closed" lines, the .end is one of the .e, .s, .w, or .n
			 ** points of the bounding box, as with block objects. */
			pik_elem_set_exit(pObj, pObj.inDir)
		}
	} else {
		var w2 PNum = pObj.w / 2.0
		var h2 PNum = pObj.h / 2.0
		pObj.ptEnter = pObj.ptAt
		pObj.ptExit = pObj.ptAt
		switch pObj.inDir {
		default:
			pObj.ptEnter.x -= w2
		case DIR_LEFT:
			pObj.ptEnter.x += w2
		case DIR_UP:
			pObj.ptEnter.y -= h2
		case DIR_DOWN:
			pObj.ptEnter.y += h2
		}
		switch pObj.outDir {
		default:
			pObj.ptExit.x += w2
		case DIR_LEFT:
			pObj.ptExit.x -= w2
		case DIR_UP:
			pObj.ptExit.y += h2
		case DIR_DOWN:
			pObj.ptExit.y -= h2
		}
		pik_bbox_add_xy(&pObj.bbox, pObj.ptAt.x-w2, pObj.ptAt.y-h2)
		pik_bbox_add_xy(&pObj.bbox, pObj.ptAt.x+w2, pObj.ptAt.y+h2)
	}
	p.eDir = pObj.outDir
}

/* Show basic information about each object as a comment in the
** generated HTML.  Used for testing and debugging.  Activated
** by the (undocumented) "debug = 1;"
** command.
 */
func (p *Pik) pik_elem_render(pObj *PObj) {
	var zDir string
	if pObj == nil {
		return
	}
	p.pik_append("<!-- ")
	if pObj.zName != "" {
		p.pik_append_text(pObj.zName, 0)
		p.pik_append(": ")
	}
	p.pik_append_text(pObj.typ.zName, 0)
	if pObj.nTxt != 0 {
		p.pik_append(" \"")
		z := pObj.aTxt[0]
		p.pik_append_text(string(z.z[1:z.n-1]), 1)
		p.pik_append("\"")
	}
	p.pik_append_num(" w=", pObj.w)
	p.pik_append_num(" h=", pObj.h)
	p.pik_append_point(" center=", &pObj.ptAt)
	p.pik_append_point(" enter=", &pObj.ptEnter)
	switch pObj.outDir {
	default:
		zDir = " right"
	case DIR_LEFT:
		zDir = " left"
	case DIR_UP:
		zDir = " up"
	case DIR_DOWN:
		zDir = " down"
	}
	p.pik_append_point(" exit=", &pObj.ptExit)
	p.pik_append(zDir)
	p.pik_append(" -->\n")
}

/* Render a list of objects
 */
func (p *Pik) pik_elist_render(pList PList) {
	var iNextLayer, iThisLayer int
	bMoreToDo := true
	mDebug := p.pik_value_int("debug", nil)
	for bMoreToDo {
		bMoreToDo = false
		iThisLayer = iNextLayer
		iNextLayer = 0x7fffffff
		for i := 0; i < len(pList); i++ {
			pObj := pList[i]
			if pObj.iLayer > iThisLayer {
				if pObj.iLayer < iNextLayer {
					iNextLayer = pObj.iLayer
				}
				bMoreToDo = true
				continue /* Defer until another round */
			} else if pObj.iLayer < iThisLayer {
				continue
			}
			if mDebug&1 != 0 {
				p.pik_elem_render(pObj)
			}
			xRender := pObj.typ.xRender
			if xRender != nil {
				xRender(p, pObj)
			}
			if pObj.pSublist != nil {
				p.pik_elist_render(pObj.pSublist)
			}
		}
	}

	/* If the color_debug_label value is defined, then go through
	 ** and paint a dot at every label location */
	miss := false
	var colorLabel PNum = p.pik_value("debug_label_color", &miss)
	if !miss && colorLabel >= 0.0 {
		dot := PObj{}
		dot.typ = &noopClass
		dot.rad = 0.015
		dot.sw = 0.015
		dot.fill = colorLabel
		dot.color = colorLabel
		dot.nTxt = 1
		dot.aTxt[0].eCode = TP_ABOVE
		for i := 0; i < len(pList); i++ {
			pObj := pList[i]
			if pObj.zName == "" {
				continue
			}
			dot.ptAt = pObj.ptAt
			dot.aTxt[0].z = []byte(pObj.zName)
			dot.aTxt[0].n = len(dot.aTxt[0].z)
			dotRender(p, &dot)
		}
	}
}

/* Add all objects of the list pList to the bounding box
 */
func (p *Pik) pik_bbox_add_elist(pList PList, wArrow PNum) {
	for i := 0; i < len(pList); i++ {
		pObj := pList[i]
		if pObj.sw > 0.0 {
			pik_bbox_addbox(&p.bbox, &pObj.bbox)
		}
		p.pik_append_txt(pObj, &p.bbox)
		if pObj.pSublist != nil {
			p.pik_bbox_add_elist(pObj.pSublist, wArrow)
		}

		/* Expand the bounding box to account for arrowheads on lines */
		if pObj.typ.isLine && pObj.nPath > 0 {
			if pObj.larrow {
				pik_bbox_addellipse(&p.bbox, pObj.aPath[0].x, pObj.aPath[0].y,
					wArrow, wArrow)
			}
			if pObj.rarrow {
				j := pObj.nPath - 1
				pik_bbox_addellipse(&p.bbox, pObj.aPath[j].x, pObj.aPath[j].y,
					wArrow, wArrow)
			}
		}
	}
}

/* Recompute key layout parameters from variables. */
func (p *Pik) pik_compute_layout_settings() {
	var thickness PNum /* Line thickness */
	var wArrow PNum    /* Width of arrowheads */

	/* Set up rendering parameters */
	if p.bLayoutVars {
		return
	}
	thickness = p.pik_value("thickness", nil)
	if thickness <= 0.01 {
		thickness = 0.01
	}
	wArrow = 0.5 * p.pik_value("arrowwid", nil)
	p.wArrow = wArrow / thickness
	p.hArrow = p.pik_value("arrowht", nil) / thickness
	p.fontScale = p.pik_value("fontscale", nil)
	if p.fontScale <= 0.0 {
		p.fontScale = 1.0
	}
	p.rScale = 144.0
	p.charWidth = p.pik_value("charwid", nil) * p.fontScale
	p.charHeight = p.pik_value("charht", nil) * p.fontScale
	p.bLayoutVars = true
}

/* Render a list of objects.  Write the SVG into p.zOut.
** Delete the input object_list before returnning.
 */
func (p *Pik) pik_render(pList PList) {
	if pList == nil {
		return
	}
	if p.nErr == 0 {
		var (
			thickness PNum /* Stroke width */
			margin    PNum /* Extra bounding box margin */
			w, h      PNum /* Drawing width and height */
			wArrow    PNum
			pikScale  PNum /* Value of the "scale" variable */
		)

		/* Set up rendering parameters */
		p.pik_compute_layout_settings()
		thickness = p.pik_value("thickness", nil)
		if thickness <= 0.01 {
			thickness = 0.01
		}
		margin = p.pik_value("margin", nil)
		margin += thickness
		wArrow = p.wArrow * thickness
		miss := false
		p.fgcolor = p.pik_value_int("fgcolor", &miss)
		if miss {
			var t PToken
			t.z = []byte("fgcolor")
			t.n = 7
			p.fgcolor = pik_round((*Pik)(nil).pik_lookup_color(&t))
		}
		miss = false
		p.bgcolor = p.pik_value_int("bgcolor", &miss)
		if miss {
			var t PToken
			t.z = []byte("bgcolor")
			t.n = 7
			p.bgcolor = pik_round((*Pik)(nil).pik_lookup_color(&t))
		}

		/* Compute a bounding box over all objects so that we can know
		 ** how big to declare the SVG canvas */
		pik_bbox_init(&p.bbox)
		p.pik_bbox_add_elist(pList, wArrow)

		/* Expand the bounding box slightly to account for line thickness
		 ** and the optional "margin = EXPR" setting. */
		p.bbox.ne.x += margin + p.pik_value("rightmargin", nil)
		p.bbox.ne.y += margin + p.pik_value("topmargin", nil)
		p.bbox.sw.x -= margin + p.pik_value("leftmargin", nil)
		p.bbox.sw.y -= margin + p.pik_value("bottommargin", nil)

		/* Output the SVG */
		p.pik_append("<svg xmlns='http://www.w3.org/2000/svg'")
		if p.zClass != "" {
			p.pik_append(" class=\"")
			p.pik_append(p.zClass)
			p.pik_append("\"")
		}
		w = p.bbox.ne.x - p.bbox.sw.x
		h = p.bbox.ne.y - p.bbox.sw.y
		p.wSVG = pik_round(p.rScale * w)
		p.hSVG = pik_round(p.rScale * h)
		pikScale = p.pik_value("scale", nil)
		if pikScale >= 0.001 && pikScale <= 1000.0 &&
			(pikScale < 0.99 || pikScale > 1.01) {
			p.wSVG = pik_round(PNum(p.wSVG) * pikScale)
			p.hSVG = pik_round(PNum(p.hSVG) * pikScale)
			p.pik_append_num(" width=\"", PNum(p.wSVG))
			p.pik_append_num("\" height=\"", PNum(p.hSVG))
			p.pik_append("\"")
		}
		p.pik_append_dis(" viewBox=\"0 0 ", w, "")
		p.pik_append_dis(" ", h, "\">\n")
		p.pik_elist_render(pList)
		p.pik_append("</svg>\n")
	} else {
		p.wSVG = -1
		p.hSVG = -1
	}
	p.pik_elist_free(&pList)
}

/*
** An array of this structure defines a list of keywords.
 */
type PikWord struct {
	zWord string /* Text of the keyword */
	//TODO(zellyn): do we need this?
	nChar uint8 /* Length of keyword text in bytes */
	eType uint8 /* Token code */
	eCode uint8 /* Extra code for the token */
	eEdge uint8 /* CP_* code for corner/edge keywords */
}

/*
** Keywords
 */
var pik_keywords = []PikWord{
	{"above", 5, T_ABOVE, 0, 0},
	{"abs", 3, T_FUNC1, FN_ABS, 0},
	{"aligned", 7, T_ALIGNED, 0, 0},
	{"and", 3, T_AND, 0, 0},
	{"as", 2, T_AS, 0, 0},
	{"assert", 6, T_ASSERT, 0, 0},
	{"at", 2, T_AT, 0, 0},
	{"behind", 6, T_BEHIND, 0, 0},
	{"below", 5, T_BELOW, 0, 0},
	{"between", 7, T_BETWEEN, 0, 0},
	{"big", 3, T_BIG, 0, 0},
	{"bold", 4, T_BOLD, 0, 0},
	{"bot", 3, T_EDGEPT, 0, CP_S},
	{"bottom", 6, T_BOTTOM, 0, CP_S},
	{"c", 1, T_EDGEPT, 0, CP_C},
	{"ccw", 3, T_CCW, 0, 0},
	{"center", 6, T_CENTER, 0, CP_C},
	{"chop", 4, T_CHOP, 0, 0},
	{"close", 5, T_CLOSE, 0, 0},
	{"color", 5, T_COLOR, 0, 0},
	{"cos", 3, T_FUNC1, FN_COS, 0},
	{"cw", 2, T_CW, 0, 0},
	{"dashed", 6, T_DASHED, 0, 0},
	{"define", 6, T_DEFINE, 0, 0},
	{"diameter", 8, T_DIAMETER, 0, 0},
	{"dist", 4, T_DIST, 0, 0},
	{"dotted", 6, T_DOTTED, 0, 0},
	{"down", 4, T_DOWN, DIR_DOWN, 0},
	{"e", 1, T_EDGEPT, 0, CP_E},
	{"east", 4, T_EDGEPT, 0, CP_E},
	{"end", 3, T_END, 0, CP_END},
	{"even", 4, T_EVEN, 0, 0},
	{"fill", 4, T_FILL, 0, 0},
	{"first", 5, T_NTH, 0, 0},
	{"fit", 3, T_FIT, 0, 0},
	{"from", 4, T_FROM, 0, 0},
	{"go", 2, T_GO, 0, 0},
	{"heading", 7, T_HEADING, 0, 0},
	{"height", 6, T_HEIGHT, 0, 0},
	{"ht", 2, T_HEIGHT, 0, 0},
	{"in", 2, T_IN, 0, 0},
	{"int", 3, T_FUNC1, FN_INT, 0},
	{"invis", 5, T_INVIS, 0, 0},
	{"invisible", 9, T_INVIS, 0, 0},
	{"italic", 6, T_ITALIC, 0, 0},
	{"last", 4, T_LAST, 0, 0},
	{"left", 4, T_LEFT, DIR_LEFT, CP_W},
	{"ljust", 5, T_LJUST, 0, 0},
	{"max", 3, T_FUNC2, FN_MAX, 0},
	{"min", 3, T_FUNC2, FN_MIN, 0},
	{"n", 1, T_EDGEPT, 0, CP_N},
	{"ne", 2, T_EDGEPT, 0, CP_NE},
	{"north", 5, T_EDGEPT, 0, CP_N},
	{"nw", 2, T_EDGEPT, 0, CP_NW},
	{"of", 2, T_OF, 0, 0},
	{"previous", 8, T_LAST, 0, 0},
	{"print", 5, T_PRINT, 0, 0},
	{"rad", 3, T_RADIUS, 0, 0},
	{"radius", 6, T_RADIUS, 0, 0},
	{"right", 5, T_RIGHT, DIR_RIGHT, CP_E},
	{"rjust", 5, T_RJUST, 0, 0},
	{"s", 1, T_EDGEPT, 0, CP_S},
	{"same", 4, T_SAME, 0, 0},
	{"se", 2, T_EDGEPT, 0, CP_SE},
	{"sin", 3, T_FUNC1, FN_SIN, 0},
	{"small", 5, T_SMALL, 0, 0},
	{"solid", 5, T_SOLID, 0, 0},
	{"south", 5, T_EDGEPT, 0, CP_S},
	{"sqrt", 4, T_FUNC1, FN_SQRT, 0},
	{"start", 5, T_START, 0, CP_START},
	{"sw", 2, T_EDGEPT, 0, CP_SW},
	{"t", 1, T_TOP, 0, CP_N},
	{"the", 3, T_THE, 0, 0},
	{"then", 4, T_THEN, 0, 0},
	{"thick", 5, T_THICK, 0, 0},
	{"thickness", 9, T_THICKNESS, 0, 0},
	{"thin", 4, T_THIN, 0, 0},
	{"this", 4, T_THIS, 0, 0},
	{"to", 2, T_TO, 0, 0},
	{"top", 3, T_TOP, 0, CP_N},
	{"until", 5, T_UNTIL, 0, 0},
	{"up", 2, T_UP, DIR_UP, 0},
	{"vertex", 6, T_VERTEX, 0, 0},
	{"w", 1, T_EDGEPT, 0, CP_W},
	{"way", 3, T_WAY, 0, 0},
	{"west", 4, T_EDGEPT, 0, CP_W},
	{"wid", 3, T_WIDTH, 0, 0},
	{"width", 5, T_WIDTH, 0, 0},
	{"with", 4, T_WITH, 0, 0},
	{"x", 1, T_X, 0, 0},
	{"y", 1, T_Y, 0, 0},
}

/*
** Search a PikWordlist for the given keyword.  Return a pointer to the
** keyword entry found.  Or return 0 if not found.
 */
func pik_find_word(
	zIn string, /* Word to search for */
	aList []PikWord, /* List to search */
) *PikWord {
	first := 0
	last := len(aList) - 1
	for first <= last {
		mid := (first + last) / 2
		c := strings.Compare(zIn, aList[mid].zWord)
		if c == 0 {
			return &aList[mid]
		}
		if c < 0 {
			last = mid - 1
		} else {
			first = mid + 1
		}
	}
	return nil
}

/*
** Set a symbolic debugger breakpoint on this routine to receive a
** breakpoint when the "#breakpoint" token is parsed.
 */
func pik_breakpoint(z []byte) {
	/* Prevent C compilers from optimizing out this routine. */
	if z[2] == 'X' {
		os.Exit(1)
	}
}

var aEntity = []struct {
	eCode   int    /* Corresponding token code */
	zEntity string /* Name of the HTML entity */
}{
	{T_RARROW, "&rarr;"},            /* Same as . */
	{T_RARROW, "&rightarrow;"},      /* Same as . */
	{T_LARROW, "&larr;"},            /* Same as <- */
	{T_LARROW, "&leftarrow;"},       /* Same as <- */
	{T_LRARROW, "&leftrightarrow;"}, /* Same as <. */
}

/*
** Return the length of next token.  The token starts on
** the pToken->z character.  Fill in other fields of the
** pToken object as appropriate.
 */
func pik_token_length(pToken *PToken, bAllowCodeBlock bool) int {
	z := pToken.z
	var i int
	switch z[0] {
	case '\\':
		pToken.eType = T_WHITESPACE
		for i = 1; z[i] == '\r' || z[i] == ' ' || z[i] == '\t'; i++ {
		}
		if z[i] == '\n' {
			return i + 1
		}
		pToken.eType = T_ERROR
		return 1

	case ';', '\n':
		pToken.eType = T_EOL
		return 1

	case '"':
		for i = 1; z[i] != 0; i++ {
			c := z[i]
			if c == '\\' {
				if z[i+1] == 0 {
					break
				}
				i++
				continue
			}
			if c == '"' {
				pToken.eType = T_STRING
				return i + 1
			}
		}
		pToken.eType = T_ERROR
		return i

	case ' ', '\t', '\f', '\r':
		for i = 1; z[i] == ' ' || z[i] == '\t' || z[i] == '\r' || z[i] == '\f'; i++ {
		}
		pToken.eType = T_WHITESPACE
		return i

	case '#':
		for i = 1; z[i] != 0 && z[i] != '\n'; i++ {
		}
		pToken.eType = T_WHITESPACE
		/* If the comment is "#breakpoint" then invoke the pik_breakpoint()
		 ** routine.  The pik_breakpoint() routie is a no-op that serves as
		 ** a convenient place to set a gdb breakpoint when debugging. */

		if i >= 11 && string(z[:11]) == "#breakpoint" {
			pik_breakpoint(z)
		}
		return i

	case '/':
		if z[1] == '*' {
			for i = 2; z[i] != 0 && (z[i] != '*' || z[i+1] != '/'); i++ {
			}
			if z[i] == '*' {
				pToken.eType = T_WHITESPACE
				return i + 2
			} else {
				pToken.eType = T_ERROR
				return i
			}
		} else if z[1] == '/' {
			for i = 2; z[i] != 0 && z[i] != '\n'; i++ {
			}
			pToken.eType = T_WHITESPACE
			return i
		} else if z[1] == '=' {
			pToken.eType = T_ASSIGN
			pToken.eCode = T_SLASH
			return 2
		} else {
			pToken.eType = T_SLASH
			return 1
		}

	case '+':
		if z[1] == '=' {
			pToken.eType = T_ASSIGN
			pToken.eCode = T_PLUS
			return 2
		}
		pToken.eType = T_PLUS
		return 1

	case '*':
		if z[1] == '=' {
			pToken.eType = T_ASSIGN
			pToken.eCode = T_STAR
			return 2
		}
		pToken.eType = T_STAR
		return 1

	case '%':
		pToken.eType = T_PERCENT
		return 1
	case '(':
		pToken.eType = T_LP
		return 1
	case ')':
		pToken.eType = T_RP
		return 1
	case '[':
		pToken.eType = T_LB
		return 1
	case ']':
		pToken.eType = T_RB
		return 1
	case ',':
		pToken.eType = T_COMMA
		return 1
	case ':':
		pToken.eType = T_COLON
		return 1
	case '>':
		pToken.eType = T_GT
		return 1
	case '=':
		if z[1] == '=' {
			pToken.eType = T_EQ
			return 2
		}
		pToken.eType = T_ASSIGN
		pToken.eCode = T_ASSIGN
		return 1

	case '-':
		if z[1] == '>' {
			pToken.eType = T_RARROW
			return 2
		} else if z[1] == '=' {
			pToken.eType = T_ASSIGN
			pToken.eCode = T_MINUS
			return 2
		} else {
			pToken.eType = T_MINUS
			return 1
		}

	case '<':
		if z[1] == '-' {
			if z[2] == '>' {
				pToken.eType = T_LRARROW
				return 3
			} else {
				pToken.eType = T_LARROW
				return 2
			}
		} else {
			pToken.eType = T_LT
			return 1
		}

	case 0xe2:
		if z[1] == 0x86 {
			if z[2] == 0x90 {
				pToken.eType = T_LARROW /* <- */
				return 3
			}
			if z[2] == 0x92 {
				pToken.eType = T_RARROW /* . */
				return 3
			}
			if z[2] == 0x94 {
				pToken.eType = T_LRARROW /* <. */
				return 3
			}
		}
		pToken.eType = T_ERROR
		return 1

	case '{':
		var depth int
		i = 1
		if bAllowCodeBlock {
			depth = 1
			for z[i] != 0 && depth > 0 {
				var x PToken
				x.z = z[i:]
				len := pik_token_length(&x, false)
				if len == 1 {
					if z[i] == '{' {
						depth++
					}
					if z[i] == '}' {
						depth--
					}
				}
				i += len
			}
		} else {
			depth = 0
		}
		if depth != 0 {
			pToken.eType = T_ERROR
			return 1
		}
		pToken.eType = T_CODEBLOCK
		return i

	case '&':
		for i, ent := range aEntity {
			if bytencmp(z, aEntity[i].zEntity, len(aEntity[i].zEntity)) == 0 {
				pToken.eType = uint8(ent.eCode)
				return len(aEntity[i].zEntity)
			}
		}
		pToken.eType = T_ERROR
		return 1

	default:
		c := z[0]
		if c == '.' {
			c1 := z[1]
			if islower(c1) {
				for i = 2; z[i] >= 'a' && z[i] <= 'z'; i++ {
				}
				pFound := pik_find_word(string(z[1:i]), pik_keywords)
				if pFound != nil && (pFound.eEdge > 0 ||
					pFound.eType == T_EDGEPT ||
					pFound.eType == T_START ||
					pFound.eType == T_END) {
					/* Dot followed by something that is a 2-D place value */
					pToken.eType = T_DOT_E
				} else if pFound != nil && (pFound.eType == T_X || pFound.eType == T_Y) {
					/* Dot followed by "x" or "y" */
					pToken.eType = T_DOT_XY
				} else {
					/* Any other "dot" */
					pToken.eType = T_DOT_L
				}
				return 1
			} else if isdigit(c1) {
				i = 0
				/* no-op.  Fall through to number handling */
			} else if isupper(c1) {
				for i = 2; z[i] != 0 && (isalnum(z[i]) || z[i] == '_'); i++ {
				}
				pToken.eType = T_DOT_U
				return 1
			} else {
				pToken.eType = T_ERROR
				return 1
			}
		}
		if (c >= '0' && c <= '9') || c == '.' {
			var nDigit int
			isInt := true
			if c != '.' {
				nDigit = 1
				for i = 1; ; i++ {
					c = z[i]
					if c < '0' || c > '9' {
						break
					}
					nDigit++
				}
				if i == 1 && (c == 'x' || c == 'X') {
					for i = 2; z[i] != 0 && isxdigit(z[i]); i++ {
					}
					pToken.eType = T_NUMBER
					return i
				}
			} else {
				isInt = false
				nDigit = 0
				i = 0
			}
			if c == '.' {
				isInt = false
				for i++; ; i++ {
					c = z[i]
					if c < '0' || c > '9' {
						break
					}
					nDigit++
				}
			}
			if nDigit == 0 {
				pToken.eType = T_ERROR
				return i
			}
			if c == 'e' || c == 'E' {
				iBefore := i
				i++
				c2 := z[i]
				if c2 == '+' || c2 == '-' {
					i++
					c2 = z[i]
				}
				if c2 < '0' || c > '9' {
					/* This is not an exp */
					i = iBefore
				} else {
					i++
					isInt = false
					for {
						c = z[i]
						if c < '0' || c > '9' {
							break
						}
						i++
					}
				}
			}
			var c2 byte
			if c != 0 {
				c2 = z[i+1]
			}
			if isInt {
				if (c == 't' && c2 == 'h') ||
					(c == 'r' && c2 == 'd') ||
					(c == 'n' && c2 == 'd') ||
					(c == 's' && c2 == 't') {
					pToken.eType = T_NTH
					return i + 2
				}
			}
			if (c == 'i' && c2 == 'n') ||
				(c == 'c' && c2 == 'm') ||
				(c == 'm' && c2 == 'm') ||
				(c == 'p' && c2 == 't') ||
				(c == 'p' && c2 == 'x') ||
				(c == 'p' && c2 == 'c') {
				i += 2
			}
			pToken.eType = T_NUMBER
			return i
		} else if islower(c) {
			for i = 1; z[i] != 0 && (isalnum(z[i]) || z[i] == '_'); i++ {
			}
			pFound := pik_find_word(string(z[:i]), pik_keywords)
			if pFound != nil {
				pToken.eType = pFound.eType
				pToken.eCode = int16(pFound.eCode)
				pToken.eEdge = pFound.eEdge
				return i
			}
			pToken.n = i
			if pik_find_class(pToken) != nil {
				pToken.eType = T_CLASSNAME
			} else {
				pToken.eType = T_ID
			}
			return i
		} else if c >= 'A' && c <= 'Z' {
			for i = 1; z[i] != 0 && (isalnum(z[i]) || z[i] == '_'); i++ {
			}
			pToken.eType = T_PLACENAME
			return i
		} else if c == '$' && z[1] >= '1' && z[1] <= '9' && !isdigit(z[2]) {
			pToken.eType = T_PARAMETER
			pToken.eCode = int16(z[1] - '1')
			return 2
		} else if c == '_' || c == '$' || c == '@' {
			for i = 1; z[i] != 0 && (isalnum(z[i]) || z[i] == '_'); i++ {
			}
			pToken.eType = T_ID
			return i
		} else {
			pToken.eType = T_ERROR
			return 1
		}
	}
}

/*
** Return a pointer to the next non-whitespace token after pThis.
** This is used to help form error messages.
 */
func pik_next_semantic_token(pThis *PToken) PToken {
	var x PToken
	i := pThis.n
	x.z = pThis.z
	for {
		x.z = pThis.z[i:]
		sz := pik_token_length(&x, true)
		if x.eType != T_WHITESPACE {
			x.n = sz
			return x
		}
		i += sz
	}
}

/* Parser arguments to a macro invocation
**
**     (arg1, arg2, ...)
**
** Arguments are comma-separated, except that commas within string
** literals or with (...), {...}, or [...] do not count.  The argument
** list begins and ends with parentheses.  There can be at most 9
** arguments.
**
** Return the number of bytes in the argument list.
 */
func (p *Pik) pik_parse_macro_args(
	z []byte, /* Start of the argument list */
	n int, /* Available bytes */
	args []PToken, /* Fill in with the arguments */
	pOuter []PToken, /* Arguments of the next outer context, or NULL */
) int {
	nArg := 0
	var i, sz int
	depth := 0
	var x PToken
	if z[0] != '(' {
		return 0
	}
	args[0].z = z[1:]
	iStart := 1
	for i = 1; i < n && z[i] != ')'; i += sz {
		x.z = z[i:]
		sz = pik_token_length(&x, false)
		if sz != 1 {
			continue
		}
		if z[i] == ',' && depth <= 0 {
			args[nArg].n = i - iStart
			if nArg == 8 {
				x.z = z
				x.n = 1
				p.pik_error(&x, "too many macro arguments - max 9")
				return 0
			}
			nArg++
			args[nArg].z = z[i+1:]
			iStart = i + 1
			depth = 0
		} else if z[i] == '(' || z[i] == '{' || z[i] == '[' {
			depth++
		} else if z[i] == ')' || z[i] == '}' || z[i] == ']' {
			depth--
		}
	}
	if z[i] == ')' {
		args[nArg].n = i - iStart
		/* Remove leading and trailing whitespace from each argument.
		 ** If what remains is one of $1, $2, ... $9 then transfer the
		 ** corresponding argument from the outer context */
		for j := 0; j <= nArg; j++ {
			t := &args[j]
			for t.n > 0 && isspace(t.z[0]) {
				t.n--
				t.z = t.z[1:]
			}
			for t.n > 0 && isspace(t.z[t.n-1]) {
				t.n--
			}
			if t.n == 2 && t.z[0] == '$' && t.z[1] >= '1' && t.z[1] <= '9' {
				if pOuter != nil {
					*t = pOuter[t.z[1]-'1']
				} else {
					t.n = 0
				}
			}
		}
		return i + 1
	}
	x.z = z
	x.n = 1
	p.pik_error(&x, "unterminated macro argument list")
	return 0
}

/*
** Split up the content of a PToken into multiple tokens and
** send each to the parser.
 */
func (p *Pik) pik_tokenize(pIn *PToken, pParser *yyParser, aParam []PToken) {
	sz := 0
	var token PToken
	for i := 0; i < pIn.n && pIn.z[i] != 0 && p.nErr == 0; i += sz {
		token.eCode = 0
		token.eEdge = 0
		token.z = pIn.z[i:]
		sz = pik_token_length(&token, true)
		if token.eType == T_WHITESPACE {
			continue
			/* no-op */
		}
		if sz > 50000 {
			token.n = 1
			p.pik_error(&token, "token is too long - max length 50000 bytes")
			break
		}
		if token.eType == T_ERROR {
			token.n = sz
			p.pik_error(&token, "unrecognized token")
			break
		}
		if sz+i > pIn.n {
			token.n = pIn.n - i
			p.pik_error(&token, "syntax error")
			break
		}
		if token.eType == T_PARAMETER {
			/* Substitute a parameter into the input stream */
			if aParam == nil || aParam[token.eCode].n == 0 {
				continue
			}
			token.n = sz
			if p.nCtx >= len(p.aCtx) {
				p.pik_error(&token, "macros nested too deep")
			} else {
				p.aCtx[p.nCtx] = token
				p.nCtx++
				p.pik_tokenize(&aParam[token.eCode], pParser, nil)
				p.nCtx--
			}
			continue
		}

		if token.eType == T_ID {
			token.n = sz
			pMac := p.pik_find_macro(&token)
			if pMac != nil {
				args := make([]PToken, 9)
				j := i + sz
				if pMac.inUse {
					p.pik_error(&pMac.macroName, "recursive macro definition")
					break
				}
				token.n = sz
				if p.nCtx >= len(p.aCtx) {
					p.pik_error(&token, "macros nested too deep")
					break
				}
				pMac.inUse = true
				p.aCtx[p.nCtx] = token
				p.nCtx++
				sz += p.pik_parse_macro_args(pIn.z[j:], pIn.n-j, args, aParam)
				p.pik_tokenize(&pMac.macroBody, pParser, args)
				p.nCtx--
				pMac.inUse = false
				continue
			}
		}
		if false { // #if 0
			n := sz
			if isspace(token.z[0]) {
				n = 0
			}

			fmt.Printf("******** Token %s (%d): \"%s\" **************\n",
				yyTokenName[token.eType], token.eType, string(token.z[:n]))
		} // #endif
		token.n = sz
		if p.nToken++; p.nToken > PIKCHR_TOKEN_LIMIT {
			p.pik_error(&token, "script is too complex")
			break
		}
		pParser.pik_parser(token.eType, token)
	}
}

/*
** Parse the PIKCHR script contained in zText[].  Return a rendering.  Or
** if an error is encountered, return the error text.  The error message
** is HTML formatted.  So regardless of what happens, the return text
** is safe to be insertd into an HTML output stream.
**
** If pnWidth and pnHeight are not NULL, then this routine writes the
** width and height of the <SVG> object into the integers that they
** point to.  A value of -1 is written if an error is seen.
**
** If zClass is not NULL, then it is a class name to be included in
** the <SVG> markup.
**
** The returned string is contained in memory obtained from malloc()
** and should be released by the caller.
 */
func Pikchr(
	zString string, /* Input PIKCHR source text.  zero-terminated */
	zClass string, /* Add class="%s" to <svg> markup */
	mFlags uint, /* Flags used to influence rendering behavior */
	pnWidth *int, /* Write width of <svg> here, if not NULL */
	pnHeight *int, /* Write height here, if not NULL */
) string {
	s := Pik{}
	var sParse yyParser

	zText := []byte(zString)
	s.sIn.n = len(zText)
	s.sIn.z = append(zText, 0)
	s.eDir = DIR_RIGHT
	s.zClass = zClass
	s.mFlags = mFlags
	sParse.pik_parserInit(&s)
	if false { // #if 0
		pik_parserTrace(os.Stdout, "parser: ")
	} // #endif
	s.pik_tokenize(&s.sIn, &sParse, nil)
	if s.nErr == 0 {
		var token PToken
		if s.sIn.n > 0 {
			token.z = zText[s.sIn.n-1:]
		} else {
			token.z = zText
		}
		token.n = 1
		sParse.pik_parser(0, token)
	}
	sParse.pik_parserFinalize()
	if s.zOut.Len() == 0 && s.nErr == 0 {
		s.pik_append("<!-- empty pikchr diagram -->\n")
	}
	if pnWidth != nil {
		if s.nErr != 0 {
			*pnWidth = -1
		} else {
			*pnWidth = s.wSVG
		}
	}
	if pnHeight != nil {
		if s.nErr != 0 {
			*pnHeight = -1
		} else {
			*pnHeight = s.hSVG
		}
	}
	return s.zOut.String()
}

// #if defined(PIKCHR_FUZZ)
// #include <stdint.h>
// int LLVMFuzzerTestOneInput(const uint8_t *aData, size_t nByte){
//   int w,h;
//   char *zIn, *zOut;
//   unsigned int mFlags = nByte & 3;
//   zIn = malloc( nByte + 1 );
//   if( zIn==0 ) return 0;
//   memcpy(zIn, aData, nByte);
//   zIn[nByte] = 0;
//   zOut = pikchr(zIn, "pikchr", mFlags, &w, &h);
//   free(zIn);
//   free(zOut);
//   return 0;
// }
// #endif /* PIKCHR_FUZZ */

// Helpers added for port to Go
func isxdigit(b byte) bool {
	return (b >= '0' && b <= '9') || (b >= 'a' && b <= 'f') || (b >= 'A' && b <= 'F')
}

func isalnum(b byte) bool {
	return (b >= '0' && b <= '9') || (b >= 'a' && b <= 'z') || (b >= 'A' && b <= 'Z')
}

func isdigit(b byte) bool {
	return (b >= '0' && b <= '9')
}

func isspace(b byte) bool {
	return b == ' ' || b == '\n' || b == '\t' || b == '\f'
}

func isupper(b byte) bool {
	return (b >= 'A' && b <= 'Z')
}

func islower(b byte) bool {
	return (b >= 'a' && b <= 'z')
}

func bytencmp(a []byte, s string, n int) int {
	return strings.Compare(string(a[:n]), s)
}

func bytesEq(a, b []byte) bool {
	if len(a) != len(b) {
		return false
	}
	for i, bb := range a {
		if b[i] != bb {
			return false
		}
	}
	return true
}

//line 7734 "pikchr.go"
